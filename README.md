# mkunion
Improves work with unions in golang by generating beautiful code (in other languages referred as sum types, variants, discriminators, tagged unions)

## Usage
Make sure that you have installed mkunion and is in GOPATH/bin
```bash
go install github.com/widmogrod/mkunion/cmd/mkunion@2.0.0
```

Create your first union
```go
package example

//go:generate mkunion -name=Tree -types=Branch,Leaf
type (
	Branch struct{ L, R Tree }
	Leaf   struct{ Value int }
)
```

Generated code will look like
```go
// Code generated by mkunion. DO NOT EDIT.
package example

type TreeVisitor interface {
	VisitBranch(v *Branch) any
	VisitLeaf(v *Leaf) any
}

type Tree interface {
	Accept(g TreeVisitor) any
}

func (r *Branch) Accept(v TreeVisitor) any { return v.VisitBranch(r) }
func (r *Leaf) Accept(v TreeVisitor) any   { return v.VisitLeaf(r) }

var (
	_ Tree = (*Branch)(nil)
	_ Tree = (*Leaf)(nil)
)

type TreeOneOf struct {
	Branch *Branch `json:",omitempty"`
	Leaf   *Leaf   `json:",omitempty"`
}

func (r *TreeOneOf) Accept(v TreeVisitor) any {
	switch {
	case r.Branch != nil:
		return v.VisitBranch(r.Branch)
	case r.Leaf != nil:
		return v.VisitLeaf(r.Leaf)
	default:
		panic("unexpected")
	}
}

var _ Tree = (*TreeOneOf)(nil)

type mapTreeToOneOf struct{}

func (t *mapTreeToOneOf) VisitBranch(v *Branch) any { return &TreeOneOf{Branch: v} }
func (t *mapTreeToOneOf) VisitLeaf(v *Leaf) any     { return &TreeOneOf{Leaf: v} }

var defaultMapTreeToOneOf TreeVisitor = &mapTreeToOneOf{}

func MapTreeToOneOf(v Tree) *TreeOneOf {
	return v.Accept(defaultMapTreeToOneOf).(*TreeOneOf)
}
```

it will generate also
```go
// Code generated by mkunion. DO NOT EDIT.
package example

type TreeNonExhaustiveG[A any] struct {
	Default  A
	OnBranch func(x *Branch) A
	OnLeaf   func(x *Leaf) A
}

func (t *TreeNonExhaustiveG[A]) VisitBranch(v *Branch) any {
	if t.OnBranch != nil {
		return t.OnBranch(v)
	}
	return t.Default
}
func (t *TreeNonExhaustiveG[A]) VisitLeaf(v *Leaf) any {
	if t.OnLeaf != nil {
		return t.OnLeaf(v)
	}
	return t.Default
}
```

and reducers that can travers structure
```go
// Code generated by mkunion. DO NOT EDIT.
package example

type (
	TreeReducer[A any] struct {
		Branch func(x *Branch, agg A) (result A, stop bool)
		Leaf   func(x *Leaf, agg A) (result A, stop bool)
	}
)

type dfsTree[A any] struct {
	stop   bool
	result A
	reduce TreeReducer[A]
}

var _ TreeVisitor = (*dfsTree[any])(nil)

func (d *dfsTree[A]) VisitBranch(v *Branch) any {
	d.result, d.stop = d.reduce.Branch(v, d.result)
	if d.stop {
		return nil
	}
	if _ = v.L.Accept(d); d.stop {
		return nil
	}
	if _ = v.R.Accept(d); d.stop {
		return nil
	}

	return nil
}

func (d *dfsTree[A]) VisitLeaf(v *Leaf) any {
	d.result, d.stop = d.reduce.Leaf(v, d.result)
	if d.stop {
		return nil
	}

	return nil
}

func ReduceTree[A any](r TreeReducer[A], v Tree, init A) A {
	reducer := &dfsTree[A]{
		result: init,
		reduce: r,
	}

	_ = v.Accept(reducer)

	return reducer.result
}
```

## Development
```
go generate ./...
go test ./...
```