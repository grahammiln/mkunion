{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkUnion","text":""},{"location":"#about","title":"About","text":"<p>Strongly typed union type in golang that supports generics*</p> <ul> <li>with exhaustive pattern matching support</li> <li>with json marshalling including generics</li> <li>and as a bonus, can generate compatible typescript types for end-to-end type safety in your application</li> </ul>"},{"location":"#why","title":"Why","text":"<p>Historically in languages without union types like golang, unions were solved either by using Visitor pattern, or using <code>iota</code> and <code>switch</code> statement, or other workarounds.</p> <p>Visitor pattern requires a lot of boiler plate code and hand crafting of the <code>Accept</code> method for each type in the union. <code>iota</code> and <code>switch</code> statement is not type safe and can lead to runtime errors, especially when new type is added and not all <code>case</code> statements are updated.</p> <p>On top of that, any data marshalling like to/from JSON requires additional, hand crafted code, to make it work.</p> <p>MkUnion solves all of those problems, by generating opinionated and strongly typed meaningful code for you.</p>"},{"location":"#example","title":"Example","text":"example/vehicle.go<pre><code>package example\n\n// union declaration\n//go:tag mkunion:\"Vehicle\"\ntype (\n    Car struct {\n        Color  string\n        Wheels int\n    }\n    Plane struct {\n        Color   string\n        Engines int\n    }\n    Boat struct {\n        Color      string\n        Propellers int\n    }\n)\n\nfunc CalculateFuelUsage(v Vehicle) int {\n    // example of pattern matching over Vehicle union type\n    return MatchVehicleR1(\n        v,\n        func(x *Car) int {\n            return x.Wheels * 2\n        },\n        func(x *Plane) int {\n            return x.Engines * 10\n        },\n        func(x *Boat) int {\n            return x.Propellers * 5\n        },\n    )\n}\n\nfunc ExampleToJSON() {\n    var vehicle Vehicle = &amp;Car{\n        Color:  \"black\",\n        Wheels: 4,\n    }\n    result, _ := shared.JSONMarshal(vehicle)\n    fmt.Println(string(result))\n    // Output: {\"$type\":\"example.Car\",\"example.Car\":{\"Color\":\"black\",\"Wheels\":4}}\n}\n\nfunc ExampleFromJSON() {\n    input := []byte(`{\"$type\":\"example.Car\",\"example.Car\":{\"Color\":\"black\",\"Wheels\":4}}`)\n    vehicle, _ := shared.JSONUnmarshal[Vehicle](input)\n    fmt.Printf(\"%#v\", vehicle)\n    // Output: &amp;example.Car{Color:\"black\", Wheels:4}\n}\n</code></pre> <p>Watch for changes in the file and generate code on the fly: <pre><code>mkunion watch ./...\n\n# or use -g flag to generate code without watching\nmkunion watch -g ./...\n</code></pre></p>"},{"location":"#next","title":"Next","text":"<ul> <li>Read getting started  to learn more.</li> <li>Or to understand better concepts jump and read value proposition</li> </ul>"},{"location":"getting_started/","title":"Getting started","text":""},{"location":"getting_started/#install-mkunion","title":"Install mkunion","text":"<p>Run in your terminal <pre><code>go install github.com/widmogrod/mkunion/cmd/mkunion@latest\n</code></pre></p>"},{"location":"getting_started/#define-your-first-union-type","title":"Define your first union type","text":"<p>Create your first union. In our simple example we will represent different types of vehicles. But in a more complex example you may want to represent different states of your application, model domain aggregates, or create your own DSL. example/vehicle.go<pre><code>package example\n\n//go:tag mkunion:\"Vehicle\"\ntype (\n    Car struct {\n        Color  string\n        Wheels int\n    }\n    Plane struct {\n        Color   string\n        Engines int\n    }\n    Boat struct {\n        Color      string\n        Propellers int\n    }\n)\n</code></pre></p> <p>In above example you can see a few important concepts:</p>"},{"location":"getting_started/#gotag-mkunionvehicle","title":"<code>//go:tag mkunion:\"Vehicle\"</code>","text":"<p>Tag are powerful and flexible way to add metadata to your code. You may be familiar with tags when you work with JSON in golang</p> <pre><code>type User struct {\n    Name string `json:\"name\"`\n}\n</code></pre> <p>Unfortunately Golang don't extend this feature to other parts of the language.</p> <p>MkUnion defines <code>//go:tag</code> comment, following other idiomatic definitions <code>go:generate</code>, <code>go:embed</code> to allow to add metadata to struct type. And MkUnion use it heavily to offer way of adding new behaviour to go types.</p>"},{"location":"getting_started/#tags-supported-by-mkunion","title":"Tags supported by MkUnion","text":"<ul> <li><code>go:tag mkunion:\"Vehicle\"</code> - define union type</li> <li><code>go:tag serde:\"json\"</code> - enable serialisation type (currently only JSON is supported), enbabled by default</li> <li><code>go:tag shape:\"-\"</code> - disable shape generation for this type, useful in cases x/shared package cannot depend on other x packages, to avid circular dependencies</li> <li><code>go:tag mkunion:\",no-type-registry\"</code> - if you want to disable generation type registry in a package, in one of go files above package declaration define tag <pre><code>//go:tag mkunion:\",no-type-registry\"\npackage example\n</code></pre></li> </ul>"},{"location":"getting_started/#type-convention","title":"<code>type (...)</code> convention","text":"<p>Union type is defined as a set of types in a single type declaration. You can think of it as \"one of\" type. To make it more readable, as convention I decided to use <code>type (...)</code> declaration block, instead of individual <code>type</code> declaration.</p>"},{"location":"getting_started/#generate-code-and-watch-for-changes","title":"Generate code and watch for changes","text":"<p>Run in your terminal to generate union type for your code and watch for changes <pre><code>mkunion watch ./...\n</code></pre></p> <p>To generate unions without watching for changes, you can run <pre><code>mkunion watch -g ./...\n</code></pre></p> <p>Alternatively you can run <code>mkunion</code> command directly <pre><code>mkunion -i example/vehicle.go\n</code></pre></p>"},{"location":"getting_started/#what-order-you-should-run-mkunion-watch-and-go-generate","title":"What order you should run <code>mkunion watch</code> and <code>go generate</code>?","text":"<p>First run <code>mkunion watch ./...</code> to generate union types, and then run <code>go generate ./...</code> to generate code that uses union types.</p> <p>I found that this order works best, especially with extension like <code>moq</code> that will fail to generate mocks when an type is not defined, which is the case for union types, unit you run <code>mkunion watch</code>.</p>"},{"location":"getting_started/#match-over-union-type","title":"Match over union type","text":"<p>When you run <code>mkunion</code> command, it will generate file alongside your original file with <code>union_gen.go</code> suffix (example vehicle_union_gen.go)</p> <p>You can use those function to do exhaustive matching on your union type.</p> <p>For example, you can calculate fuel usage for different types of vehicles, with function that looks like this:</p> example/vehicle.go<pre><code>func CalculateFuelUsage(v Vehicle) int {\n    return MatchVehicleR1(\n        v,\n        func(x *Car) int {\n            return x.Wheels * 2\n        },\n        func(x *Plane) int {\n            return x.Engines * 10\n        },\n        func(x *Boat) int {\n            return x.Propellers * 5\n        },\n    )\n}\n</code></pre> <p>And as you can see, it leverage generics to make it easy to write. No need to cast, or check type, or use <code>switch</code> statement.</p>"},{"location":"getting_started/#matching-functions-matchnamer1","title":"matching functions <code>Match{Name}R1</code>","text":"<p>Where <code>Name</code> is the name of your union type. Where <code>R0</code>, <code>R1</code>, <code>R2</code>, <code>R3</code> stands for number of return values.</p> <p>Example of <code>MatchVehicleR1</code> function signature: <pre><code>func MatchVehicleR1[T0 any](\n    x Vehicle,\n    f1 func(x *Car) T0,\n    f2 func(x *Plane) T0,\n    f3 func(x *Boat) T0,\n) T0 {\n    /* ... */\n}\n</code></pre></p>"},{"location":"getting_started/#json-marshalling","title":"JSON marshalling","text":"<p>MkUnion also generate JSON marshalling functions for you. You just need to use <code>shared.JSONMarshal</code> and <code>shared.JSONUnmarshal</code> functions to marshal and unmarshal your union type.</p> <p>Example:</p> <pre><code>func ExampleVehicleFromJSON() {\n    vehicle := &amp;Car{\n        Color:  \"black\",\n        Wheels: 4,\n    }\n    result, _ := shared.JSONMarshal[Vehicle](vehicle)\n    fmt.Println(string(result))\n    // Output: {\"$type\":\"example.Car\",\"example.Car\":{\"Color\":\"black\",\"Wheels\":4}}\n}\n\nfunc ExampleVehicleToJSON() {\n    input := []byte(`{\"$type\":\"example.Car\",\"example.Car\":{\"Color\":\"black\",\"Wheels\":4}}`)\n    vehicle, _ := shared.JSONUnmarshal[Vehicle](input)\n    fmt.Printf(\"%#v\", vehicle)\n    // Output: &amp;example.Car{Color:\"black\", Wheels:4}\n}\n</code></pre> <p>You can notice that it has opinionated way of marshalling and unmarshalling your union type. It uses <code>$type</code> field to store type information, and then store actual data in separate field, with corresponding name.</p> <p>You can read more about it in Marshaling union in JSON section.</p>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#learning-and-adoption","title":"Learning and adoption","text":"<ul> <li> docs: document simple state machine and how to use <code>mkunion</code> for it</li> <li> feature: <code>mkunion watch ./...</code> command that watches for changes in files and runs faster than <code>go generate ./...</code></li> <li> feature: <code>go:tag mkmatch</code> to generate pattern matching functions</li> <li> docs: document how to write custom pattern matching functions</li> <li> docs: document other packages in <code>x/</code> directory</li> <li> docs: document typescript types generation and end-to-end typs concepts (from backend to frontend)</li> <li> feature: expose functions to extract <code>go:tag</code> metadata</li> <li> docs: describe philosophy of \"data as resource\" and how it translates to some of library concepts</li> </ul>"},{"location":"roadmap/#long-tern-experiments-and-prototypes","title":"Long tern experiments and prototypes","text":"<ul> <li> experiment: generate other (de)serialization formats (e.g. grpc, sql, graphql)</li> <li> prototype: http &amp; gRPC client for end-to-end types.</li> <li> experiment: allow to derive behaviour for types, like derive(Map), would generated union type with Map() method</li> <li> experiment: consider adding explicit discriminator type names like <code>example.Branch[int]</code> instead of <code>example.Branch</code>. This may complicate TypeScript codegen but it could increase end-to-end type safety.</li> <li> refactor: <code>x/storage</code> instead of generic, leverage schema information to remove lookup of schemas (overhead), eventually generate storage code</li> </ul>"},{"location":"development/development/","title":"Contributing and development","text":""},{"location":"development/development/#contributing","title":"Contributing","text":"<p>If you want to contribute to <code>mkunion</code> project, please open issue first to discuss your idea.</p> <p>I have opinions about how <code>mkunion</code> should work, how I want to evolve it, and I want to make sure that your idea fits into the project.</p>"},{"location":"development/development/#development","title":"Development","text":"<p>Checkout repo and run: <pre><code>./dev/bootstrap.sh\n</code></pre></p> <p>This command starts docker container with all necessary tools to develop and test <code>mkunion</code> project.</p> <p>In separate terminal run: <pre><code>go generate ./...\ngo test ./...\n</code></pre></p> <p>This will generate code and run tests.</p> <p>Note: Some tests are flaky (yes I know, I'm working on it), so if you see some test failing, please run it again.</p>"},{"location":"development/development/#documentation","title":"Documentation","text":"<p>To preview documentation run: <pre><code> ./dev/docs.sh run\n</code></pre></p>"},{"location":"examples/generic_union/","title":"Union and generic types","text":"<p>MkUnion will generate generic unions for you.</p> <p>You only need to declare each variant type of the union with a type parameter, and library will figure out the rest.</p> <p>What is IMPORTANT is that each variant type (Branch, Leaf in this example) needs to have the same number of type parameters.</p> <p>For example, let's say you want to create a recursive tree data structure, that in leaves will hold value of <code>A</code> type.</p>"},{"location":"examples/generic_union/#declaration-and-generation","title":"Declaration and generation","text":"<p>You can use <code>mkunion</code> to create a union type for the tree:</p> example/tree.go<pre><code>package example\n\n//go:tag mkunion:\"Tree\"\ntype (\n    Branch[A any] struct{ L, R Tree[A] }\n    Leaf[A any]   struct{ Value A }\n)\n</code></pre> <p>After you run generation (as described in getting started),  you have access to the same features as with non-generic unions.</p>"},{"location":"examples/generic_union/#matching-function","title":"Matching function","text":"<p>Let's define higher order function <code>ReduceTree</code> that will travers leaves in <code>Tree</code> and produce a single value.</p> <p>This function uses <code>MatchTreeR1</code> function that is generated automatically for you.</p> example/tree.go<pre><code>func ReduceTree[A, B any](x Tree[A], f func(A, B) B, init B) B {\n    return MatchTreeR1(\n        x,\n        func(x *Branch[A]) B {\n            return ReduceTree(x.R, f, ReduceTree(x.L, f, init))\n        }, func(x *Leaf[A]) B {\n            return f(x.Value, init)\n        },\n    )\n}\n</code></pre>"},{"location":"examples/generic_union/#example-usage","title":"Example usage","text":"<p>You can use such function to sum all values in the tree, assuming that tree is of type <code>Tree[int]</code>:</p> example/tree_test.go<pre><code>func ExampleTreeSumValues() {\n    tree := &amp;Branch[int]{\n        L: &amp;Leaf[int]{Value: 1},\n        R: &amp;Branch[int]{\n            L: &amp;Branch[int]{\n                L: &amp;Leaf[int]{Value: 2},\n                R: &amp;Leaf[int]{Value: 3},\n            },\n            R: &amp;Leaf[int]{Value: 4},\n        },\n    }\n\n    result := ReduceTree(tree, func(x int, agg int) int {\n        return agg + x\n    }, 0)\n\n    fmt.Println(result)\n    // Output: 10\n}\n</code></pre> <p>You can also reduce tree to complex structure, for example to keep track of order of values in the tree, along with sum of all values in the tree.</p> example/tree_test.go<pre><code>func ExampleTreeCustomReduction() {\n    tree := &amp;Branch[int]{\n        L: &amp;Leaf[int]{Value: 1},\n        R: &amp;Branch[int]{\n            L: &amp;Branch[int]{\n                L: &amp;Leaf[int]{Value: 2},\n                R: &amp;Leaf[int]{Value: 3},\n            },\n            R: &amp;Leaf[int]{Value: 4},\n        },\n    }\n\n    result := ReduceTree(tree, func(x int, agg orderAgg) orderAgg {\n        return orderAgg{\n            Order:  append(agg.Order, x),\n            Result: agg.Result + x,\n        }\n    }, orderAgg{\n        Order:  []int{},\n        Result: 0,\n    })\n    fmt.Println(result.Order)\n    fmt.Println(result.Result)\n    // Output: [1 2 3 4]\n    // 10\n}\n</code></pre>"},{"location":"examples/generic_union/#either-option-types","title":"Either &amp; Option types","text":"<p>For educational purposes, let's create two most popular union types in functional languages: <code>Option</code> and <code>Either</code> with corresponding <code>Map</code> functions.</p> <ul> <li>Either type is used to represent one of two possible values. Many times left value holds success value, and right value holds error value.</li> <li>Option type is used to represent a value that may or may not be present. Replaces nulls in some languages.</li> </ul> f/datas.go<pre><code>//go:tag mkunion:\"Either\"\ntype (\n    Left[A, B any]  struct{ Value A }\n    Right[A, B any] struct{ Value B }\n)\n\n//go:tag mkunion:\"Option\"\ntype (\n    Some[A any] struct{ Value A }\n    None[A any] struct{}\n)\n\nfunc MapEither[A, B, C any](x Either[A, B], f func(A) C) Either[C, B] {\n    return MatchEitherR1(\n        x,\n        func(x *Left[A, B]) Either[C, B] {\n            return &amp;Left[C, B]{Value: f(x.Value)}\n        },\n        func(x *Right[A, B]) Either[C, B] {\n            return &amp;Right[C, B]{Value: x.Value}\n        },\n    )\n}\n\nfunc MapOption[A, B any](x Option[A], f func(A) B) Option[B] {\n    return MatchOptionR1(\n        x,\n        func(x *Some[A]) Option[B] {\n            return &amp;Some[B]{Value: f(x.Value)}\n        },\n        func(x *None[A]) Option[B] {\n            return &amp;None[B]{}\n        },\n    )\n}\n</code></pre> <p>In above example, we define <code>MapEither</code> and <code>MapOption</code> functions that will apply function <code>f</code> to value inside <code>Either</code> or <code>Option</code> type.</p> <p>It would be much better to have only one <code>Map</code> definition, but due to limitations of Go type system, we need to define separate functions for each type.</p> <p>I'm considering adding code generation for such behaviours in the future. Not yet due to focus on validating core concepts.</p>"},{"location":"examples/json/","title":"Marshaling union as JSON","text":"<p>MkUnion provides you with utility function that allows you to marshal and unmarshal union types to JSON,  reducing burden of writing custom marshaling and unmarshaling functions for union types.</p> <ul> <li><code>shared.JSONMarshal[A any](in A) ([]byte, error)</code></li> <li><code>shared.JSONUnmarshal[A any](data []byte) (A, error)</code></li> </ul> <p>Below is an example of how to use those functions and how the output JSON looks like.</p> example/tree_json_test.go<pre><code>import (\n    \"github.com/widmogrod/mkunion/x/shared\"\n)\n\n\nfunc ExampleTreeJson() {\n    tree := &amp;Branch[int]{\n        L: &amp;Leaf[int]{Value: 1},\n        R: &amp;Branch[int]{\n            L: &amp;Branch[int]{\n                L: &amp;Leaf[int]{Value: 2},\n                R: &amp;Leaf[int]{Value: 3},\n            },\n            R: &amp;Leaf[int]{Value: 4},\n        },\n    }\n\n    json, _ := shared.JSONMarshal[Tree[int]](tree)\n    result, _ := shared.JSONUnmarshal[Tree[int]](json)\n\n    fmt.Println(string(json))\n    if diff := cmp.Diff(tree, result); diff != \"\" {\n        fmt.Println(\"expected tree and result to be equal, but got diff:\", diff)\n    }\n    //Output: {\"$type\":\"example.Branch\",\"example.Branch\":{\"L\":{\"$type\":\"example.Leaf\",\"example.Leaf\":{\"Value\":1}},\"R\":{\"$type\":\"example.Branch\",\"example.Branch\":{\"L\":{\"$type\":\"example.Branch\",\"example.Branch\":{\"L\":{\"$type\":\"example.Leaf\",\"example.Leaf\":{\"Value\":2}},\"R\":{\"$type\":\"example.Leaf\",\"example.Leaf\":{\"Value\":3}}}},\"R\":{\"$type\":\"example.Leaf\",\"example.Leaf\":{\"Value\":4}}}}}}\n}\n</code></pre> <p>Formated JSON output of the example above: <pre><code>{\n  \"$type\": \"example.Branch\",\n  \"example.Branch\": {\n    \"L\": {\n      \"$type\": \"example.Leaf\",\n      \"example.Leaf\": {\n        \"Value\": 1\n      }\n    },\n    \"R\": {\n      \"$type\": \"example.Branch\",\n      \"example.Branch\": {\n        \"L\": {\n          \"$type\": \"example.Branch\",\n          \"example.Branch\": {\n            \"L\": {\n              \"$type\": \"example.Leaf\",\n              \"example.Leaf\": {\n                \"Value\": 2\n              }\n            },\n            \"R\": {\n              \"$type\": \"example.Leaf\",\n              \"example.Leaf\": {\n                \"Value\": 3\n              }\n            }\n          }\n        },\n        \"R\": {\n          \"$type\": \"example.Leaf\",\n          \"example.Leaf\": {\n            \"Value\": 4\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre></p> <p>There are few things that you can notice in this example:</p> <ul> <li> <p>Each union type discriminator field <code>$type</code> field that holds the type name, and corresponding key with the name of the type, that holds value of union variant.</p> <ul> <li>This is opinionated way, and library don't allow to change it.   I was experimenting with making this behaviour customizable, but it make code and API mode complex, and I prefer to keep it simple, and increase interoperability between different libraries and applications, that way.</li> </ul> </li> <li> <p>Recursive union types are supported, and they are marshaled as nested JSON objects.]</p> </li> <li> <p><code>$type</code> don't have to have full package import name, nor type parameter,   mostly because in <code>shared.JSONUnmarshal[Tree[int]](json)</code> you hint that your code accepts <code>Tree[int]</code>.</p> <ul> <li>I'm considering adding explicit type discriminators like <code>example.Branch[int]</code> or <code>example.Leaf[int]</code>.   It could increase type strictness on client side, BUT it makes generating TypeScript types more complex, and I'm not sure if it's worth it.</li> </ul> </li> <li> <p>It's not shown on this example, but you can also reference types and union types from other packages, and serialization will work as expected.</p> </li> </ul>"},{"location":"examples/state_machine/","title":"MkUnion and state machines in golang","text":"<p>This document will show how to use <code>mkunion</code> to manage application state on example of an Order Service.  You will learn:</p> <ul> <li>how to model state machines in golang, and find similarities to \"clean architecture\"</li> <li>How to test state machines (with fuzzing), and as a bonus you will get mermaid diagrams for free</li> <li>How to persist state in database and how optimistic concurrency helps resolve concurrency conflicts</li> <li>How to handle errors in state machines, and build foundations for self-healing systems</li> </ul>"},{"location":"examples/state_machine/#working-example","title":"Working example","text":"<p>As an driving example, we will use e-commerce inspired Order Service that can be in one of the following states:</p> <ul> <li><code>Pending</code> - order is created, and is waiting for someone to process it</li> <li><code>Processing</code> - order is being processed, an human is going to pick up items from warehouse and pack them</li> <li><code>Cancelled</code> - order was cancelled, there can be many reason, one of them is that warehouse is out of stock.</li> <li><code>Completed</code> - order is completed, and can be shipped to customer.</li> </ul> <p>Such states, have rules that govern transitions, like order cannot be cancelled if it's already completed, and so on.</p> <p>We need to have a wayt to trigger changes in state, like create order that pending for processing, or cancel order. We will call those triggers commands.</p> <p>Some of those rules could change in future, and we want to be able to change them without rewriting whole application. This also informs us that our design should be open for extensions.</p> <p>Side note, if you want go strait to final code product, then into example/state/ directory and have fun exploring.</p>"},{"location":"examples/state_machine/#modeling-commands-and-states","title":"Modeling commands and states","text":"<p>Our example can be represented as state machine that looks like this: simple_machine_test.go.state_diagram.mmd <pre><code>stateDiagram\n    \"*state.OrderProcessing\" --&gt; \"*state.OrderCancelled\": \"*state.CancelOrderCMD\"\n    [*] --&gt; \"*state.OrderPending\": \"*state.CreateOrderCMD\"\n    \"*state.OrderPending\" --&gt; \"*state.OrderProcessing\": \"*state.MarkAsProcessingCMD\"\n    \"*state.OrderProcessing\" --&gt; \"*state.OrderCompleted\": \"*state.MarkOrderCompleteCMD\"\n    \"*state.OrderProcessing\" --&gt; \"*state.OrderError\": \"*state.MarkOrderCompleteCMD\"\n    \"*state.OrderError\" --&gt; \"*state.OrderCompleted\": \"*state.TryRecoverErrorCMD\"</code></pre></p> <p>In this diagram, we can see that we have 5 states, and 6 commands that can trigger transitions between states shown as arrows.</p> <p>Because this diagram is generated from code, it has names that represent types in golang that we use in implementation. </p> <p>For example <code>*state.CreateOrderCMD</code>:</p> <ul> <li><code>state</code> it's a package name</li> <li><code>CreateOrderCMD</code> is a struct name in that package.</li> <li><code>CMD</code> suffix it's naming convention, that it's optional, but I find it makes code more readable, and easier to distinguish commands from states.</li> </ul> <p>Below is a code snippet that demonstrate complete model of state and commands of Order Service, that we talked about.</p> <p>Notice that we use <code>mkunion</code> to group commands and states. (Look for <code>//go:tag mkunion:\"Command\"</code>)</p> <p>This is one example how union types can be used in golang.  Historically in golang it would be very hard to achieve such thing, and it would require a lot of boilerplate code. Here interface that group those types is generated automatically. You can focus on modeling your domain.</p> example/state/model.go<pre><code>package state\n\nimport \"time\"\n\n//go:tag mkunion:\"Command\"\ntype (\n    CreateOrderCMD struct {\n        OrderID OrderID\n        Attr    OrderAttr\n    }\n    MarkAsProcessingCMD struct {\n        OrderID  OrderID\n        WorkerID WorkerID\n    }\n    CancelOrderCMD struct {\n        OrderID OrderID\n        Reason  string\n    }\n    MarkOrderCompleteCMD struct {\n        OrderID OrderID\n    }\n    // TryRecoverErrorCMD is a special command that can be used to recover from error state\n    // you can have different \"self-healing\" rules based on the error code or even return to previous healthy state\n    TryRecoverErrorCMD struct {\n        OrderID OrderID\n    }\n)\n\n//go:tag mkunion:\"State\"\ntype (\n    OrderPending struct {\n        Order Order\n    }\n    OrderProcessing struct {\n        Order Order\n    }\n    OrderCompleted struct {\n        Order Order\n    }\n    OrderCancelled struct {\n        Order Order\n    }\n    // OrderError is a special state that represent an error\n    // during order processing, you can have different \"self-healing jobs\" based on the error code\n    // like retrying the order, cancel the order, etc.\n    // treating error as state is a good practice in state machine, it allow you to centralise the error handling\n    OrderError struct {\n        // error information\n        Retried   int\n        RetriedAt *time.Time\n\n        ProblemCode ProblemCode\n\n        ProblemCommand Command\n        ProblemState   State\n    }\n)\n\ntype (\n    // OrderID Price, Quantity are placeholders for value objects, to ensure better data semantic and type safety\n    OrderID  = string\n    Price    = float64\n    Quantity = int\n\n    OrderAttr struct {\n        // placeholder for order attributes\n        // like customer name, address, etc.\n        // like product name, price, etc.\n        // for simplicity we only have Price and Quantity\n        Price    Price\n        Quantity Quantity\n    }\n\n    // WorkerID represent human that process the order\n    WorkerID = string\n\n    // Order everything we know about order\n    Order struct {\n        ID               OrderID\n        OrderAttr        OrderAttr\n        WorkerID         WorkerID\n        StockRemovedAt   *time.Time\n        PaymentChargedAt *time.Time\n        DeliveredAt      *time.Time\n        CancelledAt      *time.Time\n        CancelledReason  string\n    }\n)\n\ntype ProblemCode int\n\nconst (\n    ProblemWarehouseAPIUnreachable ProblemCode = iota\n    ProblemPaymentAPIUnreachable\n)\n</code></pre>"},{"location":"examples/state_machine/#modeling-transitions","title":"Modeling transitions","text":"<p>One thing that is missing is implementation of transitions between states.  There are few ways to do it. I will show you how to do it using functional approach (think  <code>reduce</code> or <code>map</code> function).</p> <p>Let's name function that we will build <code>Transition</code> and define it as:</p> <pre><code>func Transition(ctx context.Context, dep Dependencies, cmd Command, state State) (State, error)\n</code></pre> <p>Our function has few arguments, let's break them down:</p> <ul> <li><code>ctx</code> standard golang context, that is used to pass deadlines, and cancelation signals, etc.</li> <li><code>dep</code> encapsulates dependencies like API clients, database connection, configuration, context etc.    everything that is needed for complete production implementation.</li> <li><code>cmd</code> it's a command that we want to apply to state,     and it has <code>Command</code> interface, that was generate by <code>mkunion</code> when it was used to group commands.</li> <li><code>state</code> it's a state that we want to apply our command to and change it,     and it has <code>State</code> interface, that was generate similarly to <code>Command</code> interface.</li> </ul> <p>Our function must return either new state, or error when something went wrong during transition, like network error, or validation error.</p> <p>Below is snippet of implementation of <code>Transition</code> function for our Order Service:</p> example/state/machine.go<pre><code>//go:generate moq -with-resets -stub -out machine_mock.go . Dependency\ntype Dependency interface {\n    TimeNow() *time.Time\n    WarehouseRemoveStock(ctx context.Context, quantity Quantity) error\n    PaymentCharge(ctx context.Context, price Price) error\n}\n\nfunc Transition(ctx context.Context, di Dependency, cmd Command, state State) (State, error) {\n    return MatchCommandR2(\n        cmd,\n        func(x *CreateOrderCMD) (State, error) {\n            if x.OrderID == \"\" {\n                return nil, ErrOrderIDRequired\n            }\n\n            switch state.(type) {\n            case nil:\n                o := Order{\n                    ID:        x.OrderID,\n                    OrderAttr: x.Attr,\n                }\n                return &amp;OrderPending{\n                    Order: o,\n                }, nil\n            }\n\n            return nil, ErrOrderAlreadyExist\n        },\n        func(x *MarkAsProcessingCMD) (State, error) {\n            if x.OrderID == \"\" {\n                return nil, ErrOrderIDRequired\n            }\n            if x.WorkerID == \"\" {\n                return nil, ErrWorkerIDRequired\n            }\n\n            switch s := state.(type) {\n            case *OrderPending:\n                if s.Order.ID != x.OrderID {\n                    return nil, ErrOrderIDMismatch\n                }\n\n                o := s.Order\n                o.WorkerID = x.WorkerID\n\n                return &amp;OrderProcessing{\n                    Order: o,\n                }, nil\n            }\n\n            return nil, ErrInvalidTransition\n// ...\n// rest remove for brevity \n// ...\n</code></pre> <p>You can notice few patterns in this snippet:</p> <ul> <li><code>Dependency</code> interface help us to keep, well  dependencies - well defined, which helps greatly in testability and readability of the code. </li> <li>Use of generated function <code>MatchCommandR2</code> to exhaustively match all commands.    This is powerful, when new command is added, you can be sure that you will get compile time error, if you don't handle it.</li> <li>Validation of commands in done in transition function. Current implementation is simple, but you can use go-validate to make it more robust, or refactor code and introduce domain helper functions or methods to the types.</li> <li>Each command check state to which is being applied using <code>switch</code> statement, it ignore states that it does not care about.    Which means as implementation you have to focus only on small bit of the picture, and not worry about rest of the states.    This is also example where non-exhaustive use of <code>switch</code> statement is welcome.</li> </ul> <p>Simple, isn't it? Simplicity also comes from fact that we don't have to worry about marshalling/unmarshalling data, working with database, those are things that will be done in other parts of the application, keeping this part clean and focused on business logic.</p> <p>Note: Implementation for educational purposes is kept in one big function,  but for large projects it may be better to split it into smaller functions,  or define OrderService struct that conforms to visitor pattern interface, that was also generated for you:</p> example/state/model_union_gen.go<pre><code>type CommandVisitor interface {\n    VisitCreateOrderCMD(v *CreateOrderCMD) any\n    VisitMarkAsProcessingCMD(v *MarkAsProcessingCMD) any\n    VisitCancelOrderCMD(v *CancelOrderCMD) any\n    VisitMarkOrderCompleteCMD(v *MarkOrderCompleteCMD) any\n    VisitTryRecoverErrorCMD(v *TryRecoverErrorCMD) any\n}\n</code></pre>"},{"location":"examples/state_machine/#testing-state-machines-self-documenting","title":"Testing state machines &amp; self-documenting","text":"<p>Before we go further, let's talk about testing our implementation.</p> <p>Testing will help us not only ensure that our implementation is correct, but also will help us to document our state machine,  and discover transition that we didn't think about, that should or shouldn't be possible.</p> <p>Here is how you can test state machine, in declarative way, using <code>mkunion/x/machine</code> package:</p> <p>example/state/machine_test.go<pre><code>    var di Dependency = &amp;DependencyMock{\n        TimeNowFunc: func() *time.Time {\n            return &amp;now\n        },\n    }\n\n    order := OrderAttr{\n        Price:    100,\n        Quantity: 3,\n    }\n\n    suite := machine.NewTestSuite(di, NewMachine)\n    suite.Case(t, \"happy path of order state transition\",\n        func(t *testing.T, c *machine.Case[Dependency, Command, State]) {\n            c.\n                GivenCommand(&amp;CreateOrderCMD{OrderID: \"123\", Attr: order}).\n                ThenState(t, &amp;OrderPending{\n                    Order: Order{\n                        ID:        \"123\",\n                        OrderAttr: order,\n                    },\n                }).\n                ForkCase(t, \"start processing order\", func(t *testing.T, c *machine.Case[Dependency, Command, State]) {\n                    c.\n                        GivenCommand(&amp;MarkAsProcessingCMD{\n                            OrderID:  \"123\",\n                            WorkerID: \"worker-1\",\n                        }).\n                        ThenState(t, &amp;OrderProcessing{\n                            Order: Order{\n                                ID:        \"123\",\n                                OrderAttr: order,\n                                WorkerID:  \"worker-1\",\n                            },\n                        }).\n                        ForkCase(t, \"mark order as completed\", func(t *testing.T, c *machine.Case[Dependency, Command, State]) {\n                            c.\n                                GivenCommand(&amp;MarkOrderCompleteCMD{\n                                    OrderID: \"123\",\n                                }).\n                                ThenState(t, &amp;OrderCompleted{\n                                    Order: Order{\n                                        ID:               \"123\",\n                                        OrderAttr:        order,\n                                        WorkerID:         \"worker-1\",\n                                        DeliveredAt:      &amp;now,\n                                        StockRemovedAt:   &amp;now,\n                                        PaymentChargedAt: &amp;now,\n                                    },\n                                })\n                        }).\n                        ForkCase(t, \"cancel order\", func(t *testing.T, c *machine.Case[Dependency, Command, State]) {\n                            c.\n                                GivenCommand(&amp;CancelOrderCMD{\n                                    OrderID: \"123\",\n                                    Reason:  \"out of stock\",\n                                }).\n                                ThenState(t, &amp;OrderCancelled{\n                                    Order: Order{\n                                        ID:              \"123\",\n                                        OrderAttr:       order,\n                                        WorkerID:        \"worker-1\",\n                                        CancelledAt:     &amp;now,\n                                        CancelledReason: \"out of stock\",\n                                    },\n                                })\n                        }).\n                        ForkCase(t, \"try complete order but removing products from stock fails\", func(t *testing.T, c *machine.Case[Dependency, Command, State]) {\n                            c.\n                                GivenCommand(&amp;MarkOrderCompleteCMD{\n                                    OrderID: \"123\",\n                                }).\n                                BeforeCommand(func(t testing.TB, di Dependency) {\n                                    di.(*DependencyMock).ResetCalls()\n                                    di.(*DependencyMock).WarehouseRemoveStockFunc = func(ctx context.Context, quantity int) error {\n                                        return fmt.Errorf(\"warehouse api unreachable\")\n                                    }\n                                }).\n                                AfterCommand(func(t testing.TB, di Dependency) {\n                                    dep := di.(*DependencyMock)\n                                    dep.WarehouseRemoveStockFunc = nil\n                                    if assert.Len(t, dep.WarehouseRemoveStockCalls(), 1) {\n                                        assert.Equal(t, order.Quantity, dep.WarehouseRemoveStockCalls()[0].Quantity)\n                                    }\n\n                                    assert.Len(t, dep.PaymentChargeCalls(), 0)\n                                }).\n                                ThenState(t, &amp;OrderError{\n                                    Retried:        0,\n                                    RetriedAt:      nil,\n                                    ProblemCode:    ProblemWarehouseAPIUnreachable,\n                                    ProblemCommand: &amp;MarkOrderCompleteCMD{OrderID: \"123\"},\n                                    ProblemState: &amp;OrderProcessing{\n                                        Order: Order{\n                                            ID:        \"123\",\n                                            OrderAttr: order,\n                                            WorkerID:  \"worker-1\",\n                                        },\n                                    },\n                                }).\n                                ForkCase(t, \"successfully recover\", func(t *testing.T, c *machine.Case[Dependency, Command, State]) {\n                                    c.\n                                        GivenCommand(&amp;TryRecoverErrorCMD{OrderID: \"123\"}).\n                                        BeforeCommand(func(t testing.TB, di Dependency) {\n                                            di.(*DependencyMock).ResetCalls()\n                                        }).\n                                        AfterCommand(func(t testing.TB, di Dependency) {\n                                            dep := di.(*DependencyMock)\n                                            if assert.Len(t, dep.WarehouseRemoveStockCalls(), 1) {\n                                                assert.Equal(t, order.Quantity, dep.WarehouseRemoveStockCalls()[0].Quantity)\n                                            }\n                                            if assert.Len(t, dep.PaymentChargeCalls(), 1) {\n                                                assert.Equal(t, order.Price, dep.PaymentChargeCalls()[0].Price)\n                                            }\n                                        }).\n                                        ThenState(t, &amp;OrderCompleted{\n                                            Order: Order{\n                                                ID:               \"123\",\n                                                OrderAttr:        order,\n                                                WorkerID:         \"worker-1\",\n                                                DeliveredAt:      &amp;now,\n                                                StockRemovedAt:   &amp;now,\n                                                PaymentChargedAt: &amp;now,\n                                            },\n                                        })\n                                })\n                        })\n                })\n        },\n    )\n\n    if suite.AssertSelfDocumentStateDiagram(t, \"machine_test.go\") {\n        suite.SelfDocumentStateDiagram(t, \"machine_test.go\")\n    }\n}\n\nfunc TestStateTransition_UsingTableTests(t *testing.T) {\n</code></pre> Few things to notice in this test:</p> <ul> <li>We use standard go testing</li> <li>We use <code>machine.NewTestSuite</code> as an standard way to test state machines</li> <li>We start with describing happy path, and use <code>suite.Case</code> to define test case.</li> <li>But most importantly, we define test cases using <code>GivenCommand</code> and <code>ThenState</code> functions, that help in making test more readable, and hopefully self-documenting.</li> <li>You can see use of <code>ForkCase</code> command, that allow you to take a definition of a state declared in <code>ThenState</code> command, and apply new command to it, and expect new state.</li> <li>Less visible is use of <code>moq</code> to generate <code>DependencyMock</code> for dependencies, but still important to write more concise code.</li> </ul> <p>I know it's subjective, but I find it very readable, and easy to understand, even for non-programmers.</p>"},{"location":"examples/state_machine/#generating-state-diagram-from-tests","title":"Generating state diagram from tests","text":"<p>Last bit is this line at the bottom of the test file:</p> example/state/machine_test.go<pre><code>if suite.AssertSelfDocumentStateDiagram(t, \"machine_test.go\") {\n   suite.SelfDocumentStateDiagram(t, \"machine_test.go\")\n}\n</code></pre> <p>This code takes all inputs provided in test suit and fuzzy them, apply commands to random states, and records result of those transitions.</p> <ul> <li><code>SelfDocumentStateDiagram</code> - produce two <code>mermaid</code> diagrams, that show all possible transitions that are possible in our state machine.</li> <li><code>AssertSelfDocumentStateDiagram</code> can be used to compare new generated diagrams to diagrams committed in repository, and fail test if they are different.    You don't have to use it, but it's good practice to ensure that your state machine is well tested and don't regress without you noticing.</li> </ul> <p>There are two diagrams that are generated.</p> <p>One is a diagram of ONLY successful transitions, that you saw at the beginning of this post.</p> <pre><code>stateDiagram\n    \"*state.OrderProcessing\" --&gt; \"*state.OrderCancelled\": \"*state.CancelOrderCMD\"\n    [*] --&gt; \"*state.OrderPending\": \"*state.CreateOrderCMD\"\n    \"*state.OrderPending\" --&gt; \"*state.OrderProcessing\": \"*state.MarkAsProcessingCMD\"\n    \"*state.OrderProcessing\" --&gt; \"*state.OrderCompleted\": \"*state.MarkOrderCompleteCMD\"\n    \"*state.OrderProcessing\" --&gt; \"*state.OrderError\": \"*state.MarkOrderCompleteCMD\"\n    \"*state.OrderError\" --&gt; \"*state.OrderCompleted\": \"*state.TryRecoverErrorCMD\"</code></pre> <p>Second is a diagram that includes commands that resulted in an errors: <pre><code>stateDiagram\n %% error=cannot cancel order, order must be processing to cancel it; invalid transition \n    \"*state.OrderCancelled\" --&gt; \"*state.OrderCancelled\": \"\u274c*state.CancelOrderCMD\"\n %% error=cannot cancel order, order must be processing to cancel it; invalid transition \n    \"*state.OrderCompleted\" --&gt; \"*state.OrderCompleted\": \"\u274c*state.CancelOrderCMD\"\n %% error=cannot cancel order, order must be processing to cancel it; invalid transition \n    \"*state.OrderError\" --&gt; \"*state.OrderError\": \"\u274c*state.CancelOrderCMD\"\n %% error=cannot cancel order, order must be processing to cancel it; invalid transition \n    \"*state.OrderPending\" --&gt; \"*state.OrderPending\": \"\u274c*state.CancelOrderCMD\"\n    \"*state.OrderProcessing\" --&gt; \"*state.OrderCancelled\": \"*state.CancelOrderCMD\"\n %% error=cannot cancel order, order must be processing to cancel it; invalid transition \n    [*] --&gt; [*]: \"\u274c*state.CancelOrderCMD\"\n %% error=cannot attemp order creation, order exists: invalid transition \n    \"*state.OrderCancelled\" --&gt; \"*state.OrderCancelled\": \"\u274c*state.CreateOrderCMD\"\n %% error=cannot attemp order creation, order exists: invalid transition \n    \"*state.OrderCompleted\" --&gt; \"*state.OrderCompleted\": \"\u274c*state.CreateOrderCMD\"\n %% error=cannot attemp order creation, order exists: invalid transition \n    \"*state.OrderError\" --&gt; \"*state.OrderError\": \"\u274c*state.CreateOrderCMD\"\n %% error=cannot attemp order creation, order exists: invalid transition \n    \"*state.OrderPending\" --&gt; \"*state.OrderPending\": \"\u274c*state.CreateOrderCMD\"\n %% error=cannot attemp order creation, order exists: invalid transition \n    \"*state.OrderProcessing\" --&gt; \"*state.OrderProcessing\": \"\u274c*state.CreateOrderCMD\"\n    [*] --&gt; \"*state.OrderPending\": \"*state.CreateOrderCMD\"\n %% error=invalid transition \n    \"*state.OrderCancelled\" --&gt; \"*state.OrderCancelled\": \"\u274c*state.MarkAsProcessingCMD\"\n %% error=invalid transition \n    \"*state.OrderCompleted\" --&gt; \"*state.OrderCompleted\": \"\u274c*state.MarkAsProcessingCMD\"\n %% error=invalid transition \n    \"*state.OrderError\" --&gt; \"*state.OrderError\": \"\u274c*state.MarkAsProcessingCMD\"\n    \"*state.OrderPending\" --&gt; \"*state.OrderProcessing\": \"*state.MarkAsProcessingCMD\"\n %% error=invalid transition \n    \"*state.OrderProcessing\" --&gt; \"*state.OrderProcessing\": \"\u274c*state.MarkAsProcessingCMD\"\n %% error=invalid transition \n    [*] --&gt; [*]: \"\u274c*state.MarkAsProcessingCMD\"\n %% error=cannot mark order as complete, order is not being process; invalid transition \n    \"*state.OrderCancelled\" --&gt; \"*state.OrderCancelled\": \"\u274c*state.MarkOrderCompleteCMD\"\n %% error=cannot mark order as complete, order is not being process; invalid transition \n    \"*state.OrderCompleted\" --&gt; \"*state.OrderCompleted\": \"\u274c*state.MarkOrderCompleteCMD\"\n %% error=cannot mark order as complete, order is not being process; invalid transition \n    \"*state.OrderError\" --&gt; \"*state.OrderError\": \"\u274c*state.MarkOrderCompleteCMD\"\n %% error=cannot mark order as complete, order is not being process; invalid transition \n    \"*state.OrderPending\" --&gt; \"*state.OrderPending\": \"\u274c*state.MarkOrderCompleteCMD\"\n    \"*state.OrderProcessing\" --&gt; \"*state.OrderCompleted\": \"*state.MarkOrderCompleteCMD\"\n    \"*state.OrderProcessing\" --&gt; \"*state.OrderError\": \"*state.MarkOrderCompleteCMD\"\n %% error=cannot mark order as complete, order is not being process; invalid transition \n    [*] --&gt; [*]: \"\u274c*state.MarkOrderCompleteCMD\"\n %% error=cannot recover from non error state; invalid transition \n    \"*state.OrderCancelled\" --&gt; \"*state.OrderCancelled\": \"\u274c*state.TryRecoverErrorCMD\"\n %% error=cannot recover from non error state; invalid transition \n    \"*state.OrderCompleted\" --&gt; \"*state.OrderCompleted\": \"\u274c*state.TryRecoverErrorCMD\"\n    \"*state.OrderError\" --&gt; \"*state.OrderCompleted\": \"*state.TryRecoverErrorCMD\"\n %% error=cannot recover from non error state; invalid transition \n    \"*state.OrderPending\" --&gt; \"*state.OrderPending\": \"\u274c*state.TryRecoverErrorCMD\"\n %% error=cannot recover from non error state; invalid transition \n    \"*state.OrderProcessing\" --&gt; \"*state.OrderProcessing\": \"\u274c*state.TryRecoverErrorCMD\"\n %% error=cannot recover from non error state; invalid transition \n    [*] --&gt; [*]: \"\u274c*state.TryRecoverErrorCMD\"</code></pre></p> <p>Those diagrams are stored in the same directory as test file, and are prefixed with name used in <code>AssertSelfDocumentStateDiagram</code> function. <pre><code>machine_test.go.state_diagram.mmd\nmachine_test.go.state_diagram_with_errors.mmd\n</code></pre></p>"},{"location":"examples/state_machine/#state-machines-builder","title":"State machines builder","text":"<p>MkUnion provide <code>*machine.Machine[Dependency, Command, State]</code> struct that wires Transition, dependencies and state together. It provide methods like:</p> <ul> <li><code>Handle(ctx context.Context, cmd C) error</code> that apply command to state, and return error if something went wrong during transition.</li> <li><code>State() S</code> that return current state of the machine</li> <li><code>Dep() D</code> that return dependencies that machine was build with.</li> </ul> <p>This standard helps build on top of it, for example testing library that we use in Testing state machines &amp; self-documenting leverage it.</p> <p>Another good practice is that every package that defines state machine in the way described here,  should provide <code>NewMachine</code> function that will return bootstrapped machine with package types, like so:</p> example/state/machine.go<pre><code>func NewMachine(di Dependency, init State) *machine.Machine[Dependency, Command, State] {\n    return machine.NewMachine(di, Transition, init)\n}\n</code></pre>"},{"location":"examples/state_machine/#conclusion","title":"Conclusion","text":"<p>Now we have all pieces in place, and we can start building our application.</p> <ul> <li>We have NewMachine constructor that will give us object to use in our application.</li> <li>We have tests that will ensure that our state machine is correct, fuzzy test help to discover edge cases, and lastly we get diagrams showing which path we tested and cover.</li> <li>We saw how this approach focus on business logic, and keep it separate from other concerns like database, or API clients. Which is one of the principles of clean architecture.</li> </ul>"},{"location":"examples/state_machine/#next-steps","title":"Next steps","text":"<ul> <li>Persisting union in database will help answer question how to persist state in database, and how to handle concurrency conflicts</li> <li>Handling errors in state machines will help answer question how to handle errors in state machines, and how to build self-healing systems</li> </ul>"},{"location":"examples/state_storage/","title":"Persisting union in database","text":""},{"location":"examples/state_storage/#persisting-state-in-database","title":"Persisting state in database","text":"<p>TODO complete description!</p> <p>At this point of time, we have implemented and tested Order Service state machine.</p> <p>Next thing that we need to address in our road to the production is to persist state in database.</p> <p>MkUnion aims to support you in this task, by providing you <code>x/storage/schemaless</code> package that will take care of:</p> <ul> <li>mapping  golang structs to database representation and back from database to struct.</li> <li>leveraging optimistic concurrency control to resolve conflicts</li> <li>providing you with simple API to work with database</li> <li>and more</li> </ul> <p>Below is test case that demonstrate complete example of initializing database, building an state using <code>NewMachine</code> , and saving and loading state from database.</p> example/state/machine_database_test.go<pre><code>func ExampleStoreStateInDatabase() {\n    now := time.Date(2021, 1, 1, 0, 0, 0, 0, time.UTC)\n\n    // example state\n    state := &amp;OrderCompleted{\n        Order: Order{\n            ID:          \"123\",\n            OrderAttr:   OrderAttr{Price: 100, Quantity: 3},\n            DeliveredAt: &amp;now,\n        },\n    }\n\n    // let's use in memory storage for storing State union\n    storage := schemaless.NewInMemoryRepository[State]()\n\n    // let's save it to storage\n    _, err := storage.UpdateRecords(schemaless.Save(schemaless.Record[State]{\n        ID:   state.Order.ID,\n        Type: \"orders\",\n        Data: state,\n    }))\n\n    records, err := storage.FindingRecords(schemaless.FindingRecords[schemaless.Record[State]]{\n        RecordType: \"orders\",\n    })\n\n    fmt.Println(err)\n    fmt.Printf(\"%+#v\\n\", *records.Items[0].Data.(*OrderCompleted))\n    //Output: &lt;nil&gt;\n    //state.OrderCompleted{Order:state.Order{ID:\"123\", OrderAttr:state.OrderAttr{Price:100, Quantity:3}, WorkerID:\"\", StockRemovedAt:&lt;nil&gt;, PaymentChargedAt:&lt;nil&gt;, DeliveredAt:time.Date(2021, time.January, 1, 0, 0, 0, 0, time.UTC), CancelledAt:&lt;nil&gt;, CancelledReason:\"\"}}\n}\n</code></pre> <pre><code>sequenceDiagram\n    participant R as Request\n    participant Store as Store\n\n    activate R\n    R-&gt;&gt;R: Validate(request) -&gt; error\n\n    R-&gt;&gt;Store: Load state from database by request.ObjectId\n    activate Store\n    Store-&gt;&gt;R: Ok(State)\n    deactivate Store\n\n    R-&gt;&gt;R: Create machine with state\n    R-&gt;&gt;R: Apply command on a state\n\n    R-&gt;&gt;Store: Save state in database under request.ObjectId\n    activate Store\n    Store-&gt;&gt;R: Ok()\n    deactivate Store\n\n    deactivate R</code></pre> <p>Example implementation of such sequence diagram:</p> <pre><code>func Handle(rq Request, response Resopnse) {\n    ctx := rq.Context()\n\n    // extract objectId and command from request + do some validation\n    id := rq.ObjectId\n    command := rq.Command\n\n    // Load state from store\n    state, err := store.Find(ctx, id)\n    if err != nil { /*handle error*/ }\n\n    machine := NewSimpleMachineWithState(Transition, state)\n    newState, err := machine.Apply(cmd, state)\n    if err != nil { /*handle error*/ }\n\n    err := store.Save(ctx, newState)\n    if err != nil { /*handle error*/ }\n\n    // serialize response\n    response.Write(newState)\n}\n</code></pre>"},{"location":"examples/state_storage/#error-as-state-self-healing-systems","title":"Error as state. Self-healing systems.","text":"<p>In request-response situation, handing errors is easy, but what if in some long-lived process something goes wrong? How to handle errors in such situation? Without making what we learn about state machines useless or hard to use?</p> <p>One solution is to treat errors as state. In such case, our state machines will never return error, but instead will return new state, that will represent error.</p> <p>When we introduce explicit command responsible for correcting RecoverableError, we can create self-healing systems. Thanks to that, even in situation when errors are unknown, we can retroactivly introduce self-healing logic that correct states.</p> <p>Because there is always there is only one error state, it makes such state machines easy to reason about.</p> <pre><code>//go:generate mkunion -name State\ntype (\n    // ...\n    RecoverableError struct {\n        ErrCode int\n        PrevState State\n        RetryCount int\n    }\n)\n\n//go:generate mkunion -name Command\ntype (\n    // ...\n    CorrectStateCMD struct {}\n)\n</code></pre> <p>Now, we have to implement recoverable logic in our state machine. We show example above how to do it in <code>Transition</code> function.</p> <p>Here is example implementation of such transition function:</p> <pre><code>func Transition(cmd Command, state State) (State, error) {\nreturn MustMatchCommandR2(\n    cmd,\n    /* ... */\n    func(cmd *CorrectStateCMD) (State, error) {\n        switch state := state.(type) {\n        case *RecoverableError:\n            state.RetryCount = state.RetryCount + 1\n\n            // here we can do some self-healing logic\n            if state.ErrCode == DuplicateServiceUnavailable {\n                newState, err := Transition(&amp;MarkAsDuplicateCMD{}, state.PrevState)\n                 if err != nil {\n                    // we failed to correct error, so we return error state \n                     return &amp;RecoverableError{\n                        ErrCode: err,\n                        PrevState: state.PrevState,\n                        RetryCount: state.RetryCount,\n                    }, nil\n                }\n\n                 // we manage to fix state, so we return new state\n                 return newState, nil\n             } else {\n                 // log information that we have new code, that we don't know how to handle\n             }\n\n            // try to correct error in next iteration\n            return state, nil\n        }\n    }\n}\n</code></pre> <p>Now, to correct states we have to select from database all states that are in error state. It can be use in many ways, example below use a abstraction called <code>TaskQueue</code> that is responsible for running tasks in background.</p> <p>This abstraction guaranties that all records (historical and new ones) will be processed. You can think about it, as a queue that is populated by records from database, that meet SQL query criteria.</p> <p>You can use CRON job and pull database.</p> <pre><code>//go:generate mms deployyml -type=TaskQueue -name=CorrectMSPErrors -autoscale=1,10 -memory=128Mi -cpu=100m -timeout=10s -schedule=\"0 0 * * *\"\nfunc main()\n    sql := \"SELECT * FROM ObjectState WHERE RecoverableError.RetryCount &lt; 3\"\n    store := datalayer.DefaultStore()\n    queue := TaskQueueFrom(\"correct-msp-errors\", sql, store)\n    queue.OnTask(func (ctx context.Context, task Task) error {\n        state := task.State()\n        cmd := &amp;CorrectStateCMD{}\n        machine := NewSimpleMachineWithState(Transition, state)\n        newState, err := machine.Apply(cmd, state)\n        if err != nil {\n            return err\n        }\n        return task.Save(ctx, newState)\n    })\n    err := queue.Run(ctx)\n    if err != nil {\n        log.Panic(err)\n    }\n}\n</code></pre>"},{"location":"examples/state_storage/#state-machines-and-command-queues-and-workflows","title":"State machines and command queues and workflows","text":"<p>What if command would initiate state \"to process\" and save it in db What if task queue would take such state and process it Woudn't this be something like command queue?</p> <p>When to make a list of background processes that transition such states?</p>"},{"location":"examples/state_storage/#processors-per-state","title":"processors per state","text":"<p>It's like micromanage TaskQueue, where each state has it's own state, and it knows what command to apply to given state This could be good starting point, when there is not a lot of good tooling</p>"},{"location":"examples/state_storage/#processor-for-state-machine","title":"processor for state machine","text":"<p>With good tooling, transition of states can be declared in one place, and deployment to task queue could be done automatically.</p> <p>Note, that only some of the transitions needs to happen in background, other can be done in request-response manner.</p>"},{"location":"examples/state_storage/#processor-for-state-machine-with-workflow","title":"processor for state machine with workflow","text":"<p>State machine could be generalized to workflow. We can think about it as set of generic Command and State (like a turing machine).</p> <p>States like Pending, Completed, Failed Commands like Process, Retry, Cancel</p> <p>And workflow DSL with commands like: Invoke, Choose, Assign Where function is some ID string, and functions needs to be either pulled from registry, or called remotely (InvokeRemote). some operations would require callback (InvokeAndAwait)</p> <p>Then background processor would be responsible for executing such workflow (using task queue) Program would be responsible for defining workflow, and registering functions.</p> <p>Such programs could be also optimised for deployment, if some function would be better to run on same machine that do RPC call like function doing RPC call to database, and caching result in memory or in cache cluster dedicated to specific BFF</p>"},{"location":"examples/type_script/","title":"End-to-End types between Go and TypeScript","text":"<p>TODO description of generating TypeScript Definitions from using MkUnion</p> example/my-app/server.go<pre><code>// this command make sure that all types that are imported will have generated typescript mapping\n//go:generate ../../cmd/mkunion/mkunion shape-export --language=typescript -o ./src/workflow\n\n// this lines defines all types that should have typescript mapping generated by above command\ntype (\n    Workflow       = workflow.Workflow\n    State          = workflow.State\n    Command        = workflow.Command\n    Expr           = workflow.Expr\n    Predicate      = workflow.Predicate\n    Reshaper       = workflow.Reshaper\n    Schema         = schema.Schema\n    UpdateRecords  = schemaless.UpdateRecords[schemaless.Record[any]]\n    FindRecords    = schemaless.FindingRecords[schemaless.Record[any]]\n    PageResult     = schemaless.PageResult[schemaless.Record[any]]\n    FunctionOutput = workflow.FunctionOutput\n    FunctionInput  = workflow.FunctionInput\n)\n\n//go:tag mkunion:\"ChatCMD\"\ntype (\n    UserMessage struct {\n</code></pre>"}]}