// Code generated by mkunion. DO NOT EDIT.
package schemaless

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/x/shape"
	"github.com/widmogrod/mkunion/x/shared"
)

func init() {
	shape.Register(OpenSearchSearchResultShape())
	shape.Register(OpenSearchSearchResultHitsShape())
	shape.Register(OpenSearchSearchResultHitShape())
}

var (
	_ json.Unmarshaler = (*OpenSearchSearchResult[any])(nil)
	_ json.Marshaler   = (*OpenSearchSearchResult[any])(nil)
)

func (r *OpenSearchSearchResult[A]) MarshalJSON() ([]byte, error) {
	var err error
	result := make(map[string]json.RawMessage)

	fieldHits, err := shared.JSONMarshal[OpenSearchSearchResultHits[A]](r.Hits)
	if err != nil {
		return nil, fmt.Errorf("schemaless.OpenSearchSearchResult[A].MarshalJSON: field Hits; %w", err)
	}
	result["hits"] = fieldHits

	output, err := json.Marshal(result)
	if err != nil {
		return nil, fmt.Errorf("schemaless.OpenSearchSearchResult[A].MarshalJSON: final step; %w", err)
	}

	return output, nil
}

func (r *OpenSearchSearchResult[A]) UnmarshalJSON(bytes []byte) error {
	return shared.JSONParseObject(bytes, func(key string, bytes []byte) error {
		switch key {
		case "hits":
			var err error
			r.Hits, err = shared.JSONUnmarshal[OpenSearchSearchResultHits[A]](bytes)
			if err != nil {
				return fmt.Errorf("schemaless.OpenSearchSearchResult[A].UnmarshalJSON: field Hits; %w", err)
			}
			return nil

		}

		return nil
	})
}

func OpenSearchSearchResultShape() shape.Shape {
	return &shape.StructLike{
		Name:          "OpenSearchSearchResult",
		PkgName:       "schemaless",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless",
		TypeParams: []shape.TypeParam{
			shape.TypeParam{
				Name: "A",
				Type: &shape.Any{},
			},
		},
		Fields: []*shape.FieldLike{
			{
				Name: "Hits",
				Type: &shape.RefName{
					Name:          "OpenSearchSearchResultHits",
					PkgName:       "schemaless",
					PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless",
					Indexed: []shape.Shape{
						&shape.RefName{
							Name:          "A",
							PkgName:       "",
							PkgImportName: "",
						},
					},
				},
				Tags: map[string]shape.Tag{
					"json": {
						Value: "hits",
					},
				},
			},
		},
		Tags: map[string]shape.Tag{
			"serde": {
				Value: "json",
			},
		},
	}
}

var (
	_ json.Unmarshaler = (*OpenSearchSearchResultHits[any])(nil)
	_ json.Marshaler   = (*OpenSearchSearchResultHits[any])(nil)
)

func (r *OpenSearchSearchResultHits[A]) MarshalJSON() ([]byte, error) {
	var err error
	result := make(map[string]json.RawMessage)

	fieldHits := make([]json.RawMessage, len(r.Hits))
	for i, v := range r.Hits {
		fieldHits[i], err = shared.JSONMarshal[OpenSearchSearchResultHit[A]](v)
		if err != nil {
			return nil, fmt.Errorf("schemaless.OpenSearchSearchResultHits[A].MarshalJSON: field Hits[%d]; %w", i, err)
		}
	}
	result["hits"], err = json.Marshal(fieldHits)
	if err != nil {
		return nil, fmt.Errorf("schemaless.OpenSearchSearchResultHits[A].MarshalJSON: field Hits; %w", err)
	}

	output, err := json.Marshal(result)
	if err != nil {
		return nil, fmt.Errorf("schemaless.OpenSearchSearchResultHits[A].MarshalJSON: final step; %w", err)
	}

	return output, nil
}

func (r *OpenSearchSearchResultHits[A]) UnmarshalJSON(bytes []byte) error {
	return shared.JSONParseObject(bytes, func(key string, bytes []byte) error {
		switch key {
		case "hits":
			err := shared.JSONParseList(bytes, func(index int, bytes []byte) error {
				item, err := shared.JSONUnmarshal[OpenSearchSearchResultHit[A]](bytes)
				if err != nil {
					return fmt.Errorf("schemaless.OpenSearchSearchResultHits[A].UnmarshalJSON: field Hits[%d]; %w", index, err)
				}
				r.Hits = append(r.Hits, item)
				return nil
			})
			if err != nil {
				return fmt.Errorf("schemaless.OpenSearchSearchResultHits[A].UnmarshalJSON: field Hits; %w", err)
			}
			return nil

		}

		return nil
	})
}

func OpenSearchSearchResultHitsShape() shape.Shape {
	return &shape.StructLike{
		Name:          "OpenSearchSearchResultHits",
		PkgName:       "schemaless",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless",
		TypeParams: []shape.TypeParam{
			shape.TypeParam{
				Name: "A",
				Type: &shape.Any{},
			},
		},
		Fields: []*shape.FieldLike{
			{
				Name: "Hits",
				Type: &shape.ListLike{
					Element: &shape.RefName{
						Name:          "OpenSearchSearchResultHit",
						PkgName:       "schemaless",
						PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless",
						Indexed: []shape.Shape{
							&shape.RefName{
								Name:          "A",
								PkgName:       "",
								PkgImportName: "",
							},
						},
					},
				},
				Tags: map[string]shape.Tag{
					"json": {
						Value: "hits",
					},
				},
			},
		},
		Tags: map[string]shape.Tag{
			"serde": {
				Value: "json",
			},
		},
	}
}

var (
	_ json.Unmarshaler = (*OpenSearchSearchResultHit[any])(nil)
	_ json.Marshaler   = (*OpenSearchSearchResultHit[any])(nil)
)

func (r *OpenSearchSearchResultHit[A]) MarshalJSON() ([]byte, error) {
	var err error
	result := make(map[string]json.RawMessage)

	fieldItem, err := shared.JSONMarshal[A](r.Item)
	if err != nil {
		return nil, fmt.Errorf("schemaless.OpenSearchSearchResultHit[A].MarshalJSON: field Item; %w", err)
	}
	result["_source"] = fieldItem

	fieldSort := make([]json.RawMessage, len(r.Sort))
	for i, v := range r.Sort {
		fieldSort[i], err = shared.JSONMarshal[string](v)
		if err != nil {
			return nil, fmt.Errorf("schemaless.OpenSearchSearchResultHit[A].MarshalJSON: field Sort[%d]; %w", i, err)
		}
	}
	result["sort"], err = json.Marshal(fieldSort)
	if err != nil {
		return nil, fmt.Errorf("schemaless.OpenSearchSearchResultHit[A].MarshalJSON: field Sort; %w", err)
	}

	output, err := json.Marshal(result)
	if err != nil {
		return nil, fmt.Errorf("schemaless.OpenSearchSearchResultHit[A].MarshalJSON: final step; %w", err)
	}

	return output, nil
}

func (r *OpenSearchSearchResultHit[A]) UnmarshalJSON(bytes []byte) error {
	return shared.JSONParseObject(bytes, func(key string, bytes []byte) error {
		switch key {
		case "_source":
			var err error
			r.Item, err = shared.JSONUnmarshal[A](bytes)
			if err != nil {
				return fmt.Errorf("schemaless.OpenSearchSearchResultHit[A].UnmarshalJSON: field Item; %w", err)
			}
			return nil

		case "sort":
			err := shared.JSONParseList(bytes, func(index int, bytes []byte) error {
				item, err := shared.JSONUnmarshal[string](bytes)
				if err != nil {
					return fmt.Errorf("schemaless.OpenSearchSearchResultHit[A].UnmarshalJSON: field Sort[%d]; %w", index, err)
				}
				r.Sort = append(r.Sort, item)
				return nil
			})
			if err != nil {
				return fmt.Errorf("schemaless.OpenSearchSearchResultHit[A].UnmarshalJSON: field Sort; %w", err)
			}
			return nil

		}

		return nil
	})
}

func OpenSearchSearchResultHitShape() shape.Shape {
	return &shape.StructLike{
		Name:          "OpenSearchSearchResultHit",
		PkgName:       "schemaless",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless",
		TypeParams: []shape.TypeParam{
			shape.TypeParam{
				Name: "A",
				Type: &shape.Any{},
			},
		},
		Fields: []*shape.FieldLike{
			{
				Name: "Item",
				Type: &shape.RefName{
					Name:          "A",
					PkgName:       "",
					PkgImportName: "",
				},
				Tags: map[string]shape.Tag{
					"json": {
						Value: "_source",
					},
				},
			},
			{
				Name: "Sort",
				Type: &shape.ListLike{
					Element: &shape.StringLike{},
				},
				Tags: map[string]shape.Tag{
					"json": {
						Value: "sort",
					},
				},
			},
		},
		Tags: map[string]shape.Tag{
			"serde": {
				Value: "json",
			},
		},
	}
}
