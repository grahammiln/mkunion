// Code generated by mkunion. DO NOT EDIT.
package predicate

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/f"
	"github.com/widmogrod/mkunion/x/shape"
	"github.com/widmogrod/mkunion/x/shared"
)

func init() {
	shape.Register(PredicateShape())
	shape.Register(AndShape())
	shape.Register(OrShape())
	shape.Register(NotShape())
	shape.Register(CompareShape())
}

//mkunion-extension:visitor

type PredicateVisitor interface {
	VisitAnd(v *And) any
	VisitOr(v *Or) any
	VisitNot(v *Not) any
	VisitCompare(v *Compare) any
}

type Predicate interface {
	AcceptPredicate(g PredicateVisitor) any
}

func (r *And) AcceptPredicate(v PredicateVisitor) any     { return v.VisitAnd(r) }
func (r *Or) AcceptPredicate(v PredicateVisitor) any      { return v.VisitOr(r) }
func (r *Not) AcceptPredicate(v PredicateVisitor) any     { return v.VisitNot(r) }
func (r *Compare) AcceptPredicate(v PredicateVisitor) any { return v.VisitCompare(r) }

var (
	_ Predicate = (*And)(nil)
	_ Predicate = (*Or)(nil)
	_ Predicate = (*Not)(nil)
	_ Predicate = (*Compare)(nil)
)

func MatchPredicate[TOut any](
	x Predicate,
	f1 func(x *And) TOut,
	f2 func(x *Or) TOut,
	f3 func(x *Not) TOut,
	f4 func(x *Compare) TOut,
	df func(x Predicate) TOut,
) TOut {
	return f.Match4(x, f1, f2, f3, f4, df)
}

func MatchPredicateR2[TOut1, TOut2 any](
	x Predicate,
	f1 func(x *And) (TOut1, TOut2),
	f2 func(x *Or) (TOut1, TOut2),
	f3 func(x *Not) (TOut1, TOut2),
	f4 func(x *Compare) (TOut1, TOut2),
	df func(x Predicate) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.Match4R2(x, f1, f2, f3, f4, df)
}

func MustMatchPredicate[TOut any](
	x Predicate,
	f1 func(x *And) TOut,
	f2 func(x *Or) TOut,
	f3 func(x *Not) TOut,
	f4 func(x *Compare) TOut,
) TOut {
	return f.MustMatch4(x, f1, f2, f3, f4)
}

func MustMatchPredicateR0(
	x Predicate,
	f1 func(x *And),
	f2 func(x *Or),
	f3 func(x *Not),
	f4 func(x *Compare),
) {
	f.MustMatch4R0(x, f1, f2, f3, f4)
}

func MustMatchPredicateR2[TOut1, TOut2 any](
	x Predicate,
	f1 func(x *And) (TOut1, TOut2),
	f2 func(x *Or) (TOut1, TOut2),
	f3 func(x *Not) (TOut1, TOut2),
	f4 func(x *Compare) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.MustMatch4R2(x, f1, f2, f3, f4)
}

// mkunion-extension:shape
func PredicateShape() shape.Shape {
	return &shape.UnionLike{
		Name:          "Predicate",
		PkgName:       "predicate",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/predicate",
		Variant: []shape.Shape{
			AndShape(),
			OrShape(),
			NotShape(),
			CompareShape(),
		},
	}
}

func AndShape() shape.Shape {
	return &shape.StructLike{
		Name:          "And",
		PkgName:       "predicate",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/predicate",
		Fields: []*shape.FieldLike{
			{
				Name: "L",
				Type: &shape.ListLike{
					Element: &shape.RefName{
						Name:          "Predicate",
						PkgName:       "predicate",
						PkgImportName: "github.com/widmogrod/mkunion/x/storage/predicate",
						IsPointer:     false,
					},
					ElementIsPointer: false,
				},
			},
		},
	}
}

func OrShape() shape.Shape {
	return &shape.StructLike{
		Name:          "Or",
		PkgName:       "predicate",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/predicate",
		Fields: []*shape.FieldLike{
			{
				Name: "L",
				Type: &shape.ListLike{
					Element: &shape.RefName{
						Name:          "Predicate",
						PkgName:       "predicate",
						PkgImportName: "github.com/widmogrod/mkunion/x/storage/predicate",
						IsPointer:     false,
					},
					ElementIsPointer: false,
				},
			},
		},
	}
}

func NotShape() shape.Shape {
	return &shape.StructLike{
		Name:          "Not",
		PkgName:       "predicate",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/predicate",
		Fields: []*shape.FieldLike{
			{
				Name: "P",
				Type: &shape.RefName{
					Name:          "Predicate",
					PkgName:       "predicate",
					PkgImportName: "github.com/widmogrod/mkunion/x/storage/predicate",
					IsPointer:     false,
				},
			},
		},
	}
}

func CompareShape() shape.Shape {
	return &shape.StructLike{
		Name:          "Compare",
		PkgName:       "predicate",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/predicate",
		Fields: []*shape.FieldLike{
			{
				Name: "Location",
				Type: &shape.StringLike{},
			},
			{
				Name: "Operation",
				Type: &shape.StringLike{},
			},
			{
				Name: "BindValue",
				Type: &shape.RefName{
					Name:          "Bindable",
					PkgName:       "predicate",
					PkgImportName: "github.com/widmogrod/mkunion/x/storage/predicate",
					IsPointer:     false,
				},
			},
		},
	}
}

// mkunion-extension:json
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/predicate.Predicate", PredicateFromJSON, PredicateToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/predicate.And", AndFromJSON, AndToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/predicate.Or", OrFromJSON, OrToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/predicate.Not", NotFromJSON, NotToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/predicate.Compare", CompareFromJSON, CompareToJSON)
}

type PredicateUnionJSON struct {
	Type    string          `json:"$type,omitempty"`
	And     json.RawMessage `json:"predicate.And,omitempty"`
	Or      json.RawMessage `json:"predicate.Or,omitempty"`
	Not     json.RawMessage `json:"predicate.Not,omitempty"`
	Compare json.RawMessage `json:"predicate.Compare,omitempty"`
}

func PredicateFromJSON(x []byte) (Predicate, error) {
	var data PredicateUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, err
	}

	switch data.Type {
	case "predicate.And":
		return AndFromJSON(data.And)
	case "predicate.Or":
		return OrFromJSON(data.Or)
	case "predicate.Not":
		return NotFromJSON(data.Not)
	case "predicate.Compare":
		return CompareFromJSON(data.Compare)
	}

	if data.And != nil {
		return AndFromJSON(data.And)
	} else if data.Or != nil {
		return OrFromJSON(data.Or)
	} else if data.Not != nil {
		return NotFromJSON(data.Not)
	} else if data.Compare != nil {
		return CompareFromJSON(data.Compare)
	}

	return nil, fmt.Errorf("predicate.Predicate: unknown type %s", data.Type)
}

func PredicateToJSON(x Predicate) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return MustMatchPredicateR2(
		x,
		func(x *And) ([]byte, error) {
			body, err := AndToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(PredicateUnionJSON{
				Type: "predicate.And",
				And:  body,
			})
		},
		func(x *Or) ([]byte, error) {
			body, err := OrToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(PredicateUnionJSON{
				Type: "predicate.Or",
				Or:   body,
			})
		},
		func(x *Not) ([]byte, error) {
			body, err := NotToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(PredicateUnionJSON{
				Type: "predicate.Not",
				Not:  body,
			})
		},
		func(x *Compare) ([]byte, error) {
			body, err := CompareToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(PredicateUnionJSON{
				Type:    "predicate.Compare",
				Compare: body,
			})
		},
	)
}

func AndFromJSON(x []byte) (*And, error) {
	result := new(And)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func AndToJSON(x *And) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*And)(nil)
	_ json.Marshaler   = (*And)(nil)
)

func (r *And) MarshalJSON() ([]byte, error) {
	var err error
	result := make(map[string]json.RawMessage)

	fieldL := make([]json.RawMessage, len(r.L))
	for i, v := range r.L {
		fieldL[i], err = shared.JSONMarshal[Predicate](v)
		if err != nil {
			return nil, fmt.Errorf("predicate.And.MarshalJSON: field L[%d]; %w", i, err)
		}
	}
	result["L"], err = json.Marshal(fieldL)
	if err != nil {
		return nil, fmt.Errorf("predicate.And.MarshalJSON: field L; %w", err)
	}

	output, err := json.Marshal(result)
	if err != nil {
		return nil, fmt.Errorf("predicate.And.MarshalJSON: final step; %w", err)
	}

	return output, nil
}

func (r *And) UnmarshalJSON(bytes []byte) error {
	return shared.JSONParseObject(bytes, func(key string, bytes []byte) error {
		switch key {
		case "L":
			err := shared.JSONParseList(bytes, func(index int, bytes []byte) error {
				item, err := shared.JSONUnmarshal[Predicate](bytes)
				if err != nil {
					return fmt.Errorf("predicate.And.UnmarshalJSON: field L[%d]; %w", index, err)
				}
				r.L = append(r.L, item)
				return nil
			})
			if err != nil {
				return fmt.Errorf("predicate.And.UnmarshalJSON: field L; %w", err)
			}
			return nil

		}

		return nil
	})
}

func OrFromJSON(x []byte) (*Or, error) {
	result := new(Or)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func OrToJSON(x *Or) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Or)(nil)
	_ json.Marshaler   = (*Or)(nil)
)

func (r *Or) MarshalJSON() ([]byte, error) {
	var err error
	result := make(map[string]json.RawMessage)

	fieldL := make([]json.RawMessage, len(r.L))
	for i, v := range r.L {
		fieldL[i], err = shared.JSONMarshal[Predicate](v)
		if err != nil {
			return nil, fmt.Errorf("predicate.Or.MarshalJSON: field L[%d]; %w", i, err)
		}
	}
	result["L"], err = json.Marshal(fieldL)
	if err != nil {
		return nil, fmt.Errorf("predicate.Or.MarshalJSON: field L; %w", err)
	}

	output, err := json.Marshal(result)
	if err != nil {
		return nil, fmt.Errorf("predicate.Or.MarshalJSON: final step; %w", err)
	}

	return output, nil
}

func (r *Or) UnmarshalJSON(bytes []byte) error {
	return shared.JSONParseObject(bytes, func(key string, bytes []byte) error {
		switch key {
		case "L":
			err := shared.JSONParseList(bytes, func(index int, bytes []byte) error {
				item, err := shared.JSONUnmarshal[Predicate](bytes)
				if err != nil {
					return fmt.Errorf("predicate.Or.UnmarshalJSON: field L[%d]; %w", index, err)
				}
				r.L = append(r.L, item)
				return nil
			})
			if err != nil {
				return fmt.Errorf("predicate.Or.UnmarshalJSON: field L; %w", err)
			}
			return nil

		}

		return nil
	})
}

func NotFromJSON(x []byte) (*Not, error) {
	result := new(Not)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func NotToJSON(x *Not) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Not)(nil)
	_ json.Marshaler   = (*Not)(nil)
)

func (r *Not) MarshalJSON() ([]byte, error) {
	var err error
	result := make(map[string]json.RawMessage)

	fieldP, err := shared.JSONMarshal[Predicate](r.P)
	if err != nil {
		return nil, fmt.Errorf("predicate.Not.MarshalJSON: field P; %w", err)
	}
	result["P"] = fieldP

	output, err := json.Marshal(result)
	if err != nil {
		return nil, fmt.Errorf("predicate.Not.MarshalJSON: final step; %w", err)
	}

	return output, nil
}

func (r *Not) UnmarshalJSON(bytes []byte) error {
	return shared.JSONParseObject(bytes, func(key string, bytes []byte) error {
		switch key {
		case "P":
			var err error
			r.P, err = shared.JSONUnmarshal[Predicate](bytes)
			if err != nil {
				return fmt.Errorf("predicate.Not.UnmarshalJSON: field P; %w", err)
			}
			return nil

		}

		return nil
	})
}

func CompareFromJSON(x []byte) (*Compare, error) {
	result := new(Compare)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func CompareToJSON(x *Compare) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Compare)(nil)
	_ json.Marshaler   = (*Compare)(nil)
)

func (r *Compare) MarshalJSON() ([]byte, error) {
	var err error
	result := make(map[string]json.RawMessage)

	fieldLocation, err := shared.JSONMarshal[string](r.Location)
	if err != nil {
		return nil, fmt.Errorf("predicate.Compare.MarshalJSON: field Location; %w", err)
	}
	result["Location"] = fieldLocation

	fieldOperation, err := shared.JSONMarshal[string](r.Operation)
	if err != nil {
		return nil, fmt.Errorf("predicate.Compare.MarshalJSON: field Operation; %w", err)
	}
	result["Operation"] = fieldOperation

	fieldBindValue, err := shared.JSONMarshal[Bindable](r.BindValue)
	if err != nil {
		return nil, fmt.Errorf("predicate.Compare.MarshalJSON: field BindValue; %w", err)
	}
	result["BindValue"] = fieldBindValue

	output, err := json.Marshal(result)
	if err != nil {
		return nil, fmt.Errorf("predicate.Compare.MarshalJSON: final step; %w", err)
	}

	return output, nil
}

func (r *Compare) UnmarshalJSON(bytes []byte) error {
	return shared.JSONParseObject(bytes, func(key string, bytes []byte) error {
		switch key {
		case "Location":
			var err error
			r.Location, err = shared.JSONUnmarshal[string](bytes)
			if err != nil {
				return fmt.Errorf("predicate.Compare.UnmarshalJSON: field Location; %w", err)
			}
			return nil

		case "Operation":
			var err error
			r.Operation, err = shared.JSONUnmarshal[string](bytes)
			if err != nil {
				return fmt.Errorf("predicate.Compare.UnmarshalJSON: field Operation; %w", err)
			}
			return nil

		case "BindValue":
			var err error
			r.BindValue, err = shared.JSONUnmarshal[Bindable](bytes)
			if err != nil {
				return fmt.Errorf("predicate.Compare.UnmarshalJSON: field BindValue; %w", err)
			}
			return nil

		}

		return nil
	})
}
