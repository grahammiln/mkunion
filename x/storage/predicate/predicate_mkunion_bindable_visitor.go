// Code generated by mkunion. DO NOT EDIT.
package predicate

import (
	"github.com/widmogrod/mkunion/f"
)

type BindableVisitor interface {
	VisitBindValue(v *BindValue) any
	VisitLiteral(v *Literal) any
	VisitLocatable(v *Locatable) any
}

type Bindable interface {
	AcceptBindable(g BindableVisitor) any
}

func (r *BindValue) AcceptBindable(v BindableVisitor) any { return v.VisitBindValue(r) }
func (r *Literal) AcceptBindable(v BindableVisitor) any   { return v.VisitLiteral(r) }
func (r *Locatable) AcceptBindable(v BindableVisitor) any { return v.VisitLocatable(r) }

var (
	_ Bindable = (*BindValue)(nil)
	_ Bindable = (*Literal)(nil)
	_ Bindable = (*Locatable)(nil)
)

func MatchBindable[TOut any](
	x Bindable,
	f1 func(x *BindValue) TOut,
	f2 func(x *Literal) TOut,
	f3 func(x *Locatable) TOut,
	df func(x Bindable) TOut,
) TOut {
	return f.Match3(x, f1, f2, f3, df)
}

func MatchBindableR2[TOut1, TOut2 any](
	x Bindable,
	f1 func(x *BindValue) (TOut1, TOut2),
	f2 func(x *Literal) (TOut1, TOut2),
	f3 func(x *Locatable) (TOut1, TOut2),
	df func(x Bindable) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.Match3R2(x, f1, f2, f3, df)
}

func MustMatchBindable[TOut any](
	x Bindable,
	f1 func(x *BindValue) TOut,
	f2 func(x *Literal) TOut,
	f3 func(x *Locatable) TOut,
) TOut {
	return f.MustMatch3(x, f1, f2, f3)
}

func MustMatchBindableR0(
	x Bindable,
	f1 func(x *BindValue),
	f2 func(x *Literal),
	f3 func(x *Locatable),
) {
	f.MustMatch3R0(x, f1, f2, f3)
}

func MustMatchBindableR2[TOut1, TOut2 any](
	x Bindable,
	f1 func(x *BindValue) (TOut1, TOut2),
	f2 func(x *Literal) (TOut1, TOut2),
	f3 func(x *Locatable) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.MustMatch3R2(x, f1, f2, f3)
}
