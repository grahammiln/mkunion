// Code generated by mkunion. DO NOT EDIT.
package predicate

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/f"
	"github.com/widmogrod/mkunion/x/schema"
	"github.com/widmogrod/mkunion/x/shape"
	"github.com/widmogrod/mkunion/x/shared"
)

func init() {
	shape.Register(BindableShape())
	shape.Register(BindValueShape())
	shape.Register(LiteralShape())
	shape.Register(LocatableShape())
}

//mkunion-extension:visitor

type BindableVisitor interface {
	VisitBindValue(v *BindValue) any
	VisitLiteral(v *Literal) any
	VisitLocatable(v *Locatable) any
}

type Bindable interface {
	AcceptBindable(g BindableVisitor) any
}

func (r *BindValue) AcceptBindable(v BindableVisitor) any { return v.VisitBindValue(r) }
func (r *Literal) AcceptBindable(v BindableVisitor) any   { return v.VisitLiteral(r) }
func (r *Locatable) AcceptBindable(v BindableVisitor) any { return v.VisitLocatable(r) }

var (
	_ Bindable = (*BindValue)(nil)
	_ Bindable = (*Literal)(nil)
	_ Bindable = (*Locatable)(nil)
)

func MatchBindable[TOut any](
	x Bindable,
	f1 func(x *BindValue) TOut,
	f2 func(x *Literal) TOut,
	f3 func(x *Locatable) TOut,
	df func(x Bindable) TOut,
) TOut {
	return f.Match3(x, f1, f2, f3, df)
}

func MatchBindableR2[TOut1, TOut2 any](
	x Bindable,
	f1 func(x *BindValue) (TOut1, TOut2),
	f2 func(x *Literal) (TOut1, TOut2),
	f3 func(x *Locatable) (TOut1, TOut2),
	df func(x Bindable) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.Match3R2(x, f1, f2, f3, df)
}

func MustMatchBindable[TOut any](
	x Bindable,
	f1 func(x *BindValue) TOut,
	f2 func(x *Literal) TOut,
	f3 func(x *Locatable) TOut,
) TOut {
	return f.MustMatch3(x, f1, f2, f3)
}

func MustMatchBindableR0(
	x Bindable,
	f1 func(x *BindValue),
	f2 func(x *Literal),
	f3 func(x *Locatable),
) {
	f.MustMatch3R0(x, f1, f2, f3)
}

func MustMatchBindableR2[TOut1, TOut2 any](
	x Bindable,
	f1 func(x *BindValue) (TOut1, TOut2),
	f2 func(x *Literal) (TOut1, TOut2),
	f3 func(x *Locatable) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.MustMatch3R2(x, f1, f2, f3)
}

// mkunion-extension:shape
func BindableShape() shape.Shape {
	return &shape.UnionLike{
		Name:          "Bindable",
		PkgName:       "predicate",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/predicate",
		Variant: []shape.Shape{
			BindValueShape(),
			LiteralShape(),
			LocatableShape(),
		},
	}
}

func BindValueShape() shape.Shape {
	return &shape.StructLike{
		Name:          "BindValue",
		PkgName:       "predicate",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/predicate",
		Fields: []*shape.FieldLike{
			{
				Name: "BindName",
				Type: &shape.RefName{
					Name:          "BindName",
					PkgName:       "predicate",
					PkgImportName: "github.com/widmogrod/mkunion/x/storage/predicate",
					IsPointer:     false,
				},
			},
		},
	}
}

func LiteralShape() shape.Shape {
	return &shape.StructLike{
		Name:          "Literal",
		PkgName:       "predicate",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/predicate",
		Fields: []*shape.FieldLike{
			{
				Name: "Value",
				Type: &shape.RefName{
					Name:          "Schema",
					PkgName:       "schema",
					PkgImportName: "github.com/widmogrod/mkunion/x/schema",
					IsPointer:     false,
				},
			},
		},
	}
}

func LocatableShape() shape.Shape {
	return &shape.StructLike{
		Name:          "Locatable",
		PkgName:       "predicate",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/predicate",
		Fields: []*shape.FieldLike{
			{
				Name: "Location",
				Type: &shape.StringLike{},
			},
		},
	}
}

// mkunion-extension:json
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/predicate.Bindable", BindableFromJSON, BindableToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/predicate.BindValue", BindValueFromJSON, BindValueToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/predicate.Literal", LiteralFromJSON, LiteralToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/predicate.Locatable", LocatableFromJSON, LocatableToJSON)
}

type BindableUnionJSON struct {
	Type      string          `json:"$type,omitempty"`
	BindValue json.RawMessage `json:"predicate.BindValue,omitempty"`
	Literal   json.RawMessage `json:"predicate.Literal,omitempty"`
	Locatable json.RawMessage `json:"predicate.Locatable,omitempty"`
}

func BindableFromJSON(x []byte) (Bindable, error) {
	var data BindableUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, err
	}

	switch data.Type {
	case "predicate.BindValue":
		return BindValueFromJSON(data.BindValue)
	case "predicate.Literal":
		return LiteralFromJSON(data.Literal)
	case "predicate.Locatable":
		return LocatableFromJSON(data.Locatable)
	}

	if data.BindValue != nil {
		return BindValueFromJSON(data.BindValue)
	} else if data.Literal != nil {
		return LiteralFromJSON(data.Literal)
	} else if data.Locatable != nil {
		return LocatableFromJSON(data.Locatable)
	}

	return nil, fmt.Errorf("predicate.Bindable: unknown type %s", data.Type)
}

func BindableToJSON(x Bindable) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return MustMatchBindableR2(
		x,
		func(x *BindValue) ([]byte, error) {
			body, err := BindValueToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(BindableUnionJSON{
				Type:      "predicate.BindValue",
				BindValue: body,
			})
		},
		func(x *Literal) ([]byte, error) {
			body, err := LiteralToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(BindableUnionJSON{
				Type:    "predicate.Literal",
				Literal: body,
			})
		},
		func(x *Locatable) ([]byte, error) {
			body, err := LocatableToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(BindableUnionJSON{
				Type:      "predicate.Locatable",
				Locatable: body,
			})
		},
	)
}

func BindValueFromJSON(x []byte) (*BindValue, error) {
	result := new(BindValue)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func BindValueToJSON(x *BindValue) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*BindValue)(nil)
	_ json.Marshaler   = (*BindValue)(nil)
)

func (r *BindValue) MarshalJSON() ([]byte, error) {
	var err error
	result := make(map[string]json.RawMessage)

	fieldBindName, err := shared.JSONMarshal[BindName](r.BindName)
	if err != nil {
		return nil, fmt.Errorf("predicate.BindValue.MarshalJSON: field BindName; %w", err)
	}
	result["BindName"] = fieldBindName

	output, err := json.Marshal(result)
	if err != nil {
		return nil, fmt.Errorf("predicate.BindValue.MarshalJSON: final step; %w", err)
	}

	return output, nil
}

func (r *BindValue) UnmarshalJSON(bytes []byte) error {
	return shared.JSONParseObject(bytes, func(key string, bytes []byte) error {
		switch key {
		case "BindName":
			var err error
			r.BindName, err = shared.JSONUnmarshal[BindName](bytes)
			if err != nil {
				return fmt.Errorf("predicate.BindValue.UnmarshalJSON: field BindName; %w", err)
			}
			return nil

		}

		return nil
	})
}

func LiteralFromJSON(x []byte) (*Literal, error) {
	result := new(Literal)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func LiteralToJSON(x *Literal) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Literal)(nil)
	_ json.Marshaler   = (*Literal)(nil)
)

func (r *Literal) MarshalJSON() ([]byte, error) {
	var err error
	result := make(map[string]json.RawMessage)

	fieldValue, err := shared.JSONMarshal[schema.Schema](r.Value)
	if err != nil {
		return nil, fmt.Errorf("predicate.Literal.MarshalJSON: field Value; %w", err)
	}
	result["Value"] = fieldValue

	output, err := json.Marshal(result)
	if err != nil {
		return nil, fmt.Errorf("predicate.Literal.MarshalJSON: final step; %w", err)
	}

	return output, nil
}

func (r *Literal) UnmarshalJSON(bytes []byte) error {
	return shared.JSONParseObject(bytes, func(key string, bytes []byte) error {
		switch key {
		case "Value":
			var err error
			r.Value, err = shared.JSONUnmarshal[schema.Schema](bytes)
			if err != nil {
				return fmt.Errorf("predicate.Literal.UnmarshalJSON: field Value; %w", err)
			}
			return nil

		}

		return nil
	})
}

func LocatableFromJSON(x []byte) (*Locatable, error) {
	result := new(Locatable)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func LocatableToJSON(x *Locatable) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Locatable)(nil)
	_ json.Marshaler   = (*Locatable)(nil)
)

func (r *Locatable) MarshalJSON() ([]byte, error) {
	var err error
	result := make(map[string]json.RawMessage)

	fieldLocation, err := shared.JSONMarshal[string](r.Location)
	if err != nil {
		return nil, fmt.Errorf("predicate.Locatable.MarshalJSON: field Location; %w", err)
	}
	result["Location"] = fieldLocation

	output, err := json.Marshal(result)
	if err != nil {
		return nil, fmt.Errorf("predicate.Locatable.MarshalJSON: final step; %w", err)
	}

	return output, nil
}

func (r *Locatable) UnmarshalJSON(bytes []byte) error {
	return shared.JSONParseObject(bytes, func(key string, bytes []byte) error {
		switch key {
		case "Location":
			var err error
			r.Location, err = shared.JSONUnmarshal[string](bytes)
			if err != nil {
				return fmt.Errorf("predicate.Locatable.UnmarshalJSON: field Location; %w", err)
			}
			return nil

		}

		return nil
	})
}
