// Code generated by mkunion. DO NOT EDIT.
package predicate

var _ PredicateReducer[any] = (*PredicateDefaultReduction[any])(nil)

type (
	PredicateDefaultReduction[A any] struct {
		PanicOnFallback      bool
		DefaultStopReduction bool
		OnAnd                func(x *And, agg A) (result A, stop bool)
		OnOr                 func(x *Or, agg A) (result A, stop bool)
		OnNot                func(x *Not, agg A) (result A, stop bool)
		OnCompare            func(x *Compare, agg A) (result A, stop bool)
	}
)

func (t *PredicateDefaultReduction[A]) ReduceAnd(x *And, agg A) (result A, stop bool) {
	if t.OnAnd != nil {
		return t.OnAnd(x, agg)
	}
	if t.PanicOnFallback {
		panic("no fallback allowed on undefined ReduceBranch")
	}
	return agg, t.DefaultStopReduction
}

func (t *PredicateDefaultReduction[A]) ReduceOr(x *Or, agg A) (result A, stop bool) {
	if t.OnOr != nil {
		return t.OnOr(x, agg)
	}
	if t.PanicOnFallback {
		panic("no fallback allowed on undefined ReduceBranch")
	}
	return agg, t.DefaultStopReduction
}

func (t *PredicateDefaultReduction[A]) ReduceNot(x *Not, agg A) (result A, stop bool) {
	if t.OnNot != nil {
		return t.OnNot(x, agg)
	}
	if t.PanicOnFallback {
		panic("no fallback allowed on undefined ReduceBranch")
	}
	return agg, t.DefaultStopReduction
}

func (t *PredicateDefaultReduction[A]) ReduceCompare(x *Compare, agg A) (result A, stop bool) {
	if t.OnCompare != nil {
		return t.OnCompare(x, agg)
	}
	if t.PanicOnFallback {
		panic("no fallback allowed on undefined ReduceBranch")
	}
	return agg, t.DefaultStopReduction
}
