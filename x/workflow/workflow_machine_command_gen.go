// Code generated by mkunion. DO NOT EDIT.
package workflow

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/f"
	"github.com/widmogrod/mkunion/x/schema"
	"github.com/widmogrod/mkunion/x/shape"
	"github.com/widmogrod/mkunion/x/shared"
)

func init() {
	shape.Register(CommandShape())
	shape.Register(RunShape())
	shape.Register(CallbackShape())
	shape.Register(TryRecoverShape())
	shape.Register(StopScheduleShape())
	shape.Register(ResumeScheduleShape())
}

//mkunion-extension:visitor

type CommandVisitor interface {
	VisitRun(v *Run) any
	VisitCallback(v *Callback) any
	VisitTryRecover(v *TryRecover) any
	VisitStopSchedule(v *StopSchedule) any
	VisitResumeSchedule(v *ResumeSchedule) any
}

type Command interface {
	AcceptCommand(g CommandVisitor) any
}

func (r *Run) AcceptCommand(v CommandVisitor) any            { return v.VisitRun(r) }
func (r *Callback) AcceptCommand(v CommandVisitor) any       { return v.VisitCallback(r) }
func (r *TryRecover) AcceptCommand(v CommandVisitor) any     { return v.VisitTryRecover(r) }
func (r *StopSchedule) AcceptCommand(v CommandVisitor) any   { return v.VisitStopSchedule(r) }
func (r *ResumeSchedule) AcceptCommand(v CommandVisitor) any { return v.VisitResumeSchedule(r) }

var (
	_ Command = (*Run)(nil)
	_ Command = (*Callback)(nil)
	_ Command = (*TryRecover)(nil)
	_ Command = (*StopSchedule)(nil)
	_ Command = (*ResumeSchedule)(nil)
)

func MatchCommand[TOut any](
	x Command,
	f1 func(x *Run) TOut,
	f2 func(x *Callback) TOut,
	f3 func(x *TryRecover) TOut,
	f4 func(x *StopSchedule) TOut,
	f5 func(x *ResumeSchedule) TOut,
	df func(x Command) TOut,
) TOut {
	return f.Match5(x, f1, f2, f3, f4, f5, df)
}

func MatchCommandR2[TOut1, TOut2 any](
	x Command,
	f1 func(x *Run) (TOut1, TOut2),
	f2 func(x *Callback) (TOut1, TOut2),
	f3 func(x *TryRecover) (TOut1, TOut2),
	f4 func(x *StopSchedule) (TOut1, TOut2),
	f5 func(x *ResumeSchedule) (TOut1, TOut2),
	df func(x Command) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.Match5R2(x, f1, f2, f3, f4, f5, df)
}

func MustMatchCommand[TOut any](
	x Command,
	f1 func(x *Run) TOut,
	f2 func(x *Callback) TOut,
	f3 func(x *TryRecover) TOut,
	f4 func(x *StopSchedule) TOut,
	f5 func(x *ResumeSchedule) TOut,
) TOut {
	return f.MustMatch5(x, f1, f2, f3, f4, f5)
}

func MustMatchCommandR0(
	x Command,
	f1 func(x *Run),
	f2 func(x *Callback),
	f3 func(x *TryRecover),
	f4 func(x *StopSchedule),
	f5 func(x *ResumeSchedule),
) {
	f.MustMatch5R0(x, f1, f2, f3, f4, f5)
}

func MustMatchCommandR2[TOut1, TOut2 any](
	x Command,
	f1 func(x *Run) (TOut1, TOut2),
	f2 func(x *Callback) (TOut1, TOut2),
	f3 func(x *TryRecover) (TOut1, TOut2),
	f4 func(x *StopSchedule) (TOut1, TOut2),
	f5 func(x *ResumeSchedule) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.MustMatch5R2(x, f1, f2, f3, f4, f5)
}

//mkunion-extension:shape

func CommandShape() shape.Shape {
	return &shape.UnionLike{
		Name:          "Command",
		PkgName:       "workflow",
		PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
		Variant: []shape.Shape{
			RunShape(),
			CallbackShape(),
			TryRecoverShape(),
			StopScheduleShape(),
			ResumeScheduleShape(),
		},
	}
}

func RunShape() shape.Shape {
	return &shape.StructLike{
		Name:          "Run",
		PkgName:       "workflow",
		PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
		Fields: []*shape.FieldLike{
			{
				Name: "Flow",
				Type: &shape.RefName{
					Name:          "Workflow",
					PkgName:       "workflow",
					PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
				},
			},
			{
				Name: "Input",
				Type: &shape.RefName{
					Name:          "Schema",
					PkgName:       "schema",
					PkgImportName: "github.com/widmogrod/mkunion/x/schema",
				},
			},
			{
				Name: "RunOption",
				Type: &shape.RefName{
					Name:          "RunOption",
					PkgName:       "workflow",
					PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
				},
			},
		},
	}
}

func CallbackShape() shape.Shape {
	return &shape.StructLike{
		Name:          "Callback",
		PkgName:       "workflow",
		PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
		Fields: []*shape.FieldLike{
			{
				Name: "CallbackID",
				Type: &shape.StringLike{},
			},
			{
				Name: "Result",
				Type: &shape.RefName{
					Name:          "Schema",
					PkgName:       "schema",
					PkgImportName: "github.com/widmogrod/mkunion/x/schema",
				},
			},
		},
	}
}

func TryRecoverShape() shape.Shape {
	return &shape.StructLike{
		Name:          "TryRecover",
		PkgName:       "workflow",
		PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
		Fields: []*shape.FieldLike{
			{
				Name: "RunID",
				Type: &shape.StringLike{},
			},
		},
	}
}

func StopScheduleShape() shape.Shape {
	return &shape.StructLike{
		Name:          "StopSchedule",
		PkgName:       "workflow",
		PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
		Fields: []*shape.FieldLike{
			{
				Name: "ParentRunID",
				Type: &shape.StringLike{},
			},
		},
	}
}

func ResumeScheduleShape() shape.Shape {
	return &shape.StructLike{
		Name:          "ResumeSchedule",
		PkgName:       "workflow",
		PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
		Fields: []*shape.FieldLike{
			{
				Name: "ParentRunID",
				Type: &shape.StringLike{},
			},
		},
	}
}

// mkunion-extension:json
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Command", CommandFromJSON, CommandToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Run", RunFromJSON, RunToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Callback", CallbackFromJSON, CallbackToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.TryRecover", TryRecoverFromJSON, TryRecoverToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.StopSchedule", StopScheduleFromJSON, StopScheduleToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.ResumeSchedule", ResumeScheduleFromJSON, ResumeScheduleToJSON)
}

type CommandUnionJSON struct {
	Type           string          `json:"$type,omitempty"`
	Run            json.RawMessage `json:"workflow.Run,omitempty"`
	Callback       json.RawMessage `json:"workflow.Callback,omitempty"`
	TryRecover     json.RawMessage `json:"workflow.TryRecover,omitempty"`
	StopSchedule   json.RawMessage `json:"workflow.StopSchedule,omitempty"`
	ResumeSchedule json.RawMessage `json:"workflow.ResumeSchedule,omitempty"`
}

func CommandFromJSON(x []byte) (Command, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}

	var data CommandUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, err
	}

	switch data.Type {
	case "workflow.Run":
		return RunFromJSON(data.Run)
	case "workflow.Callback":
		return CallbackFromJSON(data.Callback)
	case "workflow.TryRecover":
		return TryRecoverFromJSON(data.TryRecover)
	case "workflow.StopSchedule":
		return StopScheduleFromJSON(data.StopSchedule)
	case "workflow.ResumeSchedule":
		return ResumeScheduleFromJSON(data.ResumeSchedule)
	}

	if data.Run != nil {
		return RunFromJSON(data.Run)
	} else if data.Callback != nil {
		return CallbackFromJSON(data.Callback)
	} else if data.TryRecover != nil {
		return TryRecoverFromJSON(data.TryRecover)
	} else if data.StopSchedule != nil {
		return StopScheduleFromJSON(data.StopSchedule)
	} else if data.ResumeSchedule != nil {
		return ResumeScheduleFromJSON(data.ResumeSchedule)
	}

	return nil, fmt.Errorf("workflow.Command: unknown type %s", data.Type)
}

func CommandToJSON(x Command) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return MustMatchCommandR2(
		x,
		func(x *Run) ([]byte, error) {
			body, err := RunToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(CommandUnionJSON{
				Type: "workflow.Run",
				Run:  body,
			})
		},
		func(x *Callback) ([]byte, error) {
			body, err := CallbackToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(CommandUnionJSON{
				Type:     "workflow.Callback",
				Callback: body,
			})
		},
		func(x *TryRecover) ([]byte, error) {
			body, err := TryRecoverToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(CommandUnionJSON{
				Type:       "workflow.TryRecover",
				TryRecover: body,
			})
		},
		func(x *StopSchedule) ([]byte, error) {
			body, err := StopScheduleToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(CommandUnionJSON{
				Type:         "workflow.StopSchedule",
				StopSchedule: body,
			})
		},
		func(x *ResumeSchedule) ([]byte, error) {
			body, err := ResumeScheduleToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(CommandUnionJSON{
				Type:           "workflow.ResumeSchedule",
				ResumeSchedule: body,
			})
		},
	)
}

func RunFromJSON(x []byte) (*Run, error) {
	result := new(Run)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func RunToJSON(x *Run) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Run)(nil)
	_ json.Marshaler   = (*Run)(nil)
)

func (r *Run) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONRun(*r)
}
func (r *Run) _marshalJSONRun(x Run) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldFlow []byte
	fieldFlow, err = r._marshalJSONWorkflow(x.Flow)
	if err != nil {
		return nil, fmt.Errorf("workflow: Run._marshalJSONRun: field name Flow; %w", err)
	}
	partial["Flow"] = fieldFlow
	var fieldInput []byte
	fieldInput, err = r._marshalJSONschema_Schema(x.Input)
	if err != nil {
		return nil, fmt.Errorf("workflow: Run._marshalJSONRun: field name Input; %w", err)
	}
	partial["Input"] = fieldInput
	var fieldRunOption []byte
	fieldRunOption, err = r._marshalJSONRunOption(x.RunOption)
	if err != nil {
		return nil, fmt.Errorf("workflow: Run._marshalJSONRun: field name RunOption; %w", err)
	}
	partial["RunOption"] = fieldRunOption
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Run._marshalJSONRun: struct; %w", err)
	}
	return result, nil
}
func (r *Run) _marshalJSONWorkflow(x Workflow) ([]byte, error) {
	result, err := shared.JSONMarshal[Workflow](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Run._marshalJSONWorkflow:; %w", err)
	}
	return result, nil
}
func (r *Run) _marshalJSONschema_Schema(x schema.Schema) ([]byte, error) {
	result, err := shared.JSONMarshal[schema.Schema](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Run._marshalJSONschema_Schema:; %w", err)
	}
	return result, nil
}
func (r *Run) _marshalJSONRunOption(x RunOption) ([]byte, error) {
	result, err := shared.JSONMarshal[RunOption](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Run._marshalJSONRunOption:; %w", err)
	}
	return result, nil
}
func (r *Run) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONRun(data)
	if err != nil {
		return fmt.Errorf("workflow: Run.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Run) _unmarshalJSONRun(data []byte) (Run, error) {
	result := Run{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Run._unmarshalJSONRun: native struct unwrap; %w", err)
	}
	if fieldFlow, ok := partial["Flow"]; ok {
		result.Flow, err = r._unmarshalJSONWorkflow(fieldFlow)
		if err != nil {
			return result, fmt.Errorf("workflow: Run._unmarshalJSONRun: field Flow; %w", err)
		}
	}
	if fieldInput, ok := partial["Input"]; ok {
		result.Input, err = r._unmarshalJSONschema_Schema(fieldInput)
		if err != nil {
			return result, fmt.Errorf("workflow: Run._unmarshalJSONRun: field Input; %w", err)
		}
	}
	if fieldRunOption, ok := partial["RunOption"]; ok {
		result.RunOption, err = r._unmarshalJSONRunOption(fieldRunOption)
		if err != nil {
			return result, fmt.Errorf("workflow: Run._unmarshalJSONRun: field RunOption; %w", err)
		}
	}
	return result, nil
}
func (r *Run) _unmarshalJSONWorkflow(data []byte) (Workflow, error) {
	result, err := shared.JSONUnmarshal[Workflow](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Run._unmarshalJSONWorkflow: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *Run) _unmarshalJSONschema_Schema(data []byte) (schema.Schema, error) {
	result, err := shared.JSONUnmarshal[schema.Schema](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Run._unmarshalJSONschema_Schema: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *Run) _unmarshalJSONRunOption(data []byte) (RunOption, error) {
	result, err := shared.JSONUnmarshal[RunOption](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Run._unmarshalJSONRunOption: native ref unwrap; %w", err)
	}
	return result, nil
}

func CallbackFromJSON(x []byte) (*Callback, error) {
	result := new(Callback)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func CallbackToJSON(x *Callback) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Callback)(nil)
	_ json.Marshaler   = (*Callback)(nil)
)

func (r *Callback) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONCallback(*r)
}
func (r *Callback) _marshalJSONCallback(x Callback) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldCallbackID []byte
	fieldCallbackID, err = r._marshalJSONstring(x.CallbackID)
	if err != nil {
		return nil, fmt.Errorf("workflow: Callback._marshalJSONCallback: field name CallbackID; %w", err)
	}
	partial["CallbackID"] = fieldCallbackID
	var fieldResult []byte
	fieldResult, err = r._marshalJSONschema_Schema(x.Result)
	if err != nil {
		return nil, fmt.Errorf("workflow: Callback._marshalJSONCallback: field name Result; %w", err)
	}
	partial["Result"] = fieldResult
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Callback._marshalJSONCallback: struct; %w", err)
	}
	return result, nil
}
func (r *Callback) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Callback._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *Callback) _marshalJSONschema_Schema(x schema.Schema) ([]byte, error) {
	result, err := shared.JSONMarshal[schema.Schema](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Callback._marshalJSONschema_Schema:; %w", err)
	}
	return result, nil
}
func (r *Callback) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONCallback(data)
	if err != nil {
		return fmt.Errorf("workflow: Callback.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Callback) _unmarshalJSONCallback(data []byte) (Callback, error) {
	result := Callback{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Callback._unmarshalJSONCallback: native struct unwrap; %w", err)
	}
	if fieldCallbackID, ok := partial["CallbackID"]; ok {
		result.CallbackID, err = r._unmarshalJSONstring(fieldCallbackID)
		if err != nil {
			return result, fmt.Errorf("workflow: Callback._unmarshalJSONCallback: field CallbackID; %w", err)
		}
	}
	if fieldResult, ok := partial["Result"]; ok {
		result.Result, err = r._unmarshalJSONschema_Schema(fieldResult)
		if err != nil {
			return result, fmt.Errorf("workflow: Callback._unmarshalJSONCallback: field Result; %w", err)
		}
	}
	return result, nil
}
func (r *Callback) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: Callback._unmarshalJSONstring: native string unwrap; %w", err)
	}
	return result, nil
}
func (r *Callback) _unmarshalJSONschema_Schema(data []byte) (schema.Schema, error) {
	result, err := shared.JSONUnmarshal[schema.Schema](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Callback._unmarshalJSONschema_Schema: native ref unwrap; %w", err)
	}
	return result, nil
}

func TryRecoverFromJSON(x []byte) (*TryRecover, error) {
	result := new(TryRecover)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func TryRecoverToJSON(x *TryRecover) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*TryRecover)(nil)
	_ json.Marshaler   = (*TryRecover)(nil)
)

func (r *TryRecover) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONTryRecover(*r)
}
func (r *TryRecover) _marshalJSONTryRecover(x TryRecover) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldRunID []byte
	fieldRunID, err = r._marshalJSONstring(x.RunID)
	if err != nil {
		return nil, fmt.Errorf("workflow: TryRecover._marshalJSONTryRecover: field name RunID; %w", err)
	}
	partial["RunID"] = fieldRunID
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: TryRecover._marshalJSONTryRecover: struct; %w", err)
	}
	return result, nil
}
func (r *TryRecover) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: TryRecover._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *TryRecover) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONTryRecover(data)
	if err != nil {
		return fmt.Errorf("workflow: TryRecover.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *TryRecover) _unmarshalJSONTryRecover(data []byte) (TryRecover, error) {
	result := TryRecover{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: TryRecover._unmarshalJSONTryRecover: native struct unwrap; %w", err)
	}
	if fieldRunID, ok := partial["RunID"]; ok {
		result.RunID, err = r._unmarshalJSONstring(fieldRunID)
		if err != nil {
			return result, fmt.Errorf("workflow: TryRecover._unmarshalJSONTryRecover: field RunID; %w", err)
		}
	}
	return result, nil
}
func (r *TryRecover) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: TryRecover._unmarshalJSONstring: native string unwrap; %w", err)
	}
	return result, nil
}

func StopScheduleFromJSON(x []byte) (*StopSchedule, error) {
	result := new(StopSchedule)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func StopScheduleToJSON(x *StopSchedule) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*StopSchedule)(nil)
	_ json.Marshaler   = (*StopSchedule)(nil)
)

func (r *StopSchedule) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONStopSchedule(*r)
}
func (r *StopSchedule) _marshalJSONStopSchedule(x StopSchedule) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldParentRunID []byte
	fieldParentRunID, err = r._marshalJSONstring(x.ParentRunID)
	if err != nil {
		return nil, fmt.Errorf("workflow: StopSchedule._marshalJSONStopSchedule: field name ParentRunID; %w", err)
	}
	partial["ParentRunID"] = fieldParentRunID
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: StopSchedule._marshalJSONStopSchedule: struct; %w", err)
	}
	return result, nil
}
func (r *StopSchedule) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: StopSchedule._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *StopSchedule) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONStopSchedule(data)
	if err != nil {
		return fmt.Errorf("workflow: StopSchedule.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *StopSchedule) _unmarshalJSONStopSchedule(data []byte) (StopSchedule, error) {
	result := StopSchedule{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: StopSchedule._unmarshalJSONStopSchedule: native struct unwrap; %w", err)
	}
	if fieldParentRunID, ok := partial["ParentRunID"]; ok {
		result.ParentRunID, err = r._unmarshalJSONstring(fieldParentRunID)
		if err != nil {
			return result, fmt.Errorf("workflow: StopSchedule._unmarshalJSONStopSchedule: field ParentRunID; %w", err)
		}
	}
	return result, nil
}
func (r *StopSchedule) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: StopSchedule._unmarshalJSONstring: native string unwrap; %w", err)
	}
	return result, nil
}

func ResumeScheduleFromJSON(x []byte) (*ResumeSchedule, error) {
	result := new(ResumeSchedule)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func ResumeScheduleToJSON(x *ResumeSchedule) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*ResumeSchedule)(nil)
	_ json.Marshaler   = (*ResumeSchedule)(nil)
)

func (r *ResumeSchedule) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONResumeSchedule(*r)
}
func (r *ResumeSchedule) _marshalJSONResumeSchedule(x ResumeSchedule) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldParentRunID []byte
	fieldParentRunID, err = r._marshalJSONstring(x.ParentRunID)
	if err != nil {
		return nil, fmt.Errorf("workflow: ResumeSchedule._marshalJSONResumeSchedule: field name ParentRunID; %w", err)
	}
	partial["ParentRunID"] = fieldParentRunID
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: ResumeSchedule._marshalJSONResumeSchedule: struct; %w", err)
	}
	return result, nil
}
func (r *ResumeSchedule) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: ResumeSchedule._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *ResumeSchedule) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONResumeSchedule(data)
	if err != nil {
		return fmt.Errorf("workflow: ResumeSchedule.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *ResumeSchedule) _unmarshalJSONResumeSchedule(data []byte) (ResumeSchedule, error) {
	result := ResumeSchedule{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: ResumeSchedule._unmarshalJSONResumeSchedule: native struct unwrap; %w", err)
	}
	if fieldParentRunID, ok := partial["ParentRunID"]; ok {
		result.ParentRunID, err = r._unmarshalJSONstring(fieldParentRunID)
		if err != nil {
			return result, fmt.Errorf("workflow: ResumeSchedule._unmarshalJSONResumeSchedule: field ParentRunID; %w", err)
		}
	}
	return result, nil
}
func (r *ResumeSchedule) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: ResumeSchedule._unmarshalJSONstring: native string unwrap; %w", err)
	}
	return result, nil
}
