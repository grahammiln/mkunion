// Code generated by mkunion. DO NOT EDIT.
package workflow

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/f"
	"github.com/widmogrod/mkunion/x/shape"
	"github.com/widmogrod/mkunion/x/shared"
)

func init() {
	shape.Register(RunOptionShape())
	shape.Register(ScheduleRunShape())
	shape.Register(DelayRunShape())
}

//mkunion-extension:visitor

type RunOptionVisitor interface {
	VisitScheduleRun(v *ScheduleRun) any
	VisitDelayRun(v *DelayRun) any
}

type RunOption interface {
	AcceptRunOption(g RunOptionVisitor) any
}

func (r *ScheduleRun) AcceptRunOption(v RunOptionVisitor) any { return v.VisitScheduleRun(r) }
func (r *DelayRun) AcceptRunOption(v RunOptionVisitor) any    { return v.VisitDelayRun(r) }

var (
	_ RunOption = (*ScheduleRun)(nil)
	_ RunOption = (*DelayRun)(nil)
)

func MatchRunOption[TOut any](
	x RunOption,
	f1 func(x *ScheduleRun) TOut,
	f2 func(x *DelayRun) TOut,
	df func(x RunOption) TOut,
) TOut {
	return f.Match2(x, f1, f2, df)
}

func MatchRunOptionR2[TOut1, TOut2 any](
	x RunOption,
	f1 func(x *ScheduleRun) (TOut1, TOut2),
	f2 func(x *DelayRun) (TOut1, TOut2),
	df func(x RunOption) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.Match2R2(x, f1, f2, df)
}

func MustMatchRunOption[TOut any](
	x RunOption,
	f1 func(x *ScheduleRun) TOut,
	f2 func(x *DelayRun) TOut,
) TOut {
	return f.MustMatch2(x, f1, f2)
}

func MustMatchRunOptionR0(
	x RunOption,
	f1 func(x *ScheduleRun),
	f2 func(x *DelayRun),
) {
	f.MustMatch2R0(x, f1, f2)
}

func MustMatchRunOptionR2[TOut1, TOut2 any](
	x RunOption,
	f1 func(x *ScheduleRun) (TOut1, TOut2),
	f2 func(x *DelayRun) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.MustMatch2R2(x, f1, f2)
}

//mkunion-extension:shape

func RunOptionShape() shape.Shape {
	return &shape.UnionLike{
		Name:          "RunOption",
		PkgName:       "workflow",
		PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
		Variant: []shape.Shape{
			ScheduleRunShape(),
			DelayRunShape(),
		},
	}
}

func ScheduleRunShape() shape.Shape {
	return &shape.StructLike{
		Name:          "ScheduleRun",
		PkgName:       "workflow",
		PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
		Fields: []*shape.FieldLike{
			{
				Name: "Interval",
				Type: &shape.StringLike{},
			},
			{
				Name: "ParentRunID",
				Type: &shape.StringLike{},
			},
		},
	}
}

func DelayRunShape() shape.Shape {
	return &shape.StructLike{
		Name:          "DelayRun",
		PkgName:       "workflow",
		PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
		Fields: []*shape.FieldLike{
			{
				Name: "DelayBySeconds",
				Type: &shape.NumberLike{
					Kind: &shape.Int64{},
				},
			},
		},
	}
}

// mkunion-extension:json
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.RunOption", RunOptionFromJSON, RunOptionToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.ScheduleRun", ScheduleRunFromJSON, ScheduleRunToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.DelayRun", DelayRunFromJSON, DelayRunToJSON)
}

type RunOptionUnionJSON struct {
	Type        string          `json:"$type,omitempty"`
	ScheduleRun json.RawMessage `json:"workflow.ScheduleRun,omitempty"`
	DelayRun    json.RawMessage `json:"workflow.DelayRun,omitempty"`
}

func RunOptionFromJSON(x []byte) (RunOption, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}

	var data RunOptionUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, err
	}

	switch data.Type {
	case "workflow.ScheduleRun":
		return ScheduleRunFromJSON(data.ScheduleRun)
	case "workflow.DelayRun":
		return DelayRunFromJSON(data.DelayRun)
	}

	if data.ScheduleRun != nil {
		return ScheduleRunFromJSON(data.ScheduleRun)
	} else if data.DelayRun != nil {
		return DelayRunFromJSON(data.DelayRun)
	}

	return nil, fmt.Errorf("workflow.RunOption: unknown type %s", data.Type)
}

func RunOptionToJSON(x RunOption) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return MustMatchRunOptionR2(
		x,
		func(x *ScheduleRun) ([]byte, error) {
			body, err := ScheduleRunToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(RunOptionUnionJSON{
				Type:        "workflow.ScheduleRun",
				ScheduleRun: body,
			})
		},
		func(x *DelayRun) ([]byte, error) {
			body, err := DelayRunToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(RunOptionUnionJSON{
				Type:     "workflow.DelayRun",
				DelayRun: body,
			})
		},
	)
}

func ScheduleRunFromJSON(x []byte) (*ScheduleRun, error) {
	result := new(ScheduleRun)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func ScheduleRunToJSON(x *ScheduleRun) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*ScheduleRun)(nil)
	_ json.Marshaler   = (*ScheduleRun)(nil)
)

func (r *ScheduleRun) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONScheduleRun(*r)
}
func (r *ScheduleRun) _marshalJSONScheduleRun(x ScheduleRun) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldInterval []byte
	fieldInterval, err = r._marshalJSONstring(x.Interval)
	if err != nil {
		return nil, fmt.Errorf("workflow: ScheduleRun._marshalJSONScheduleRun: field name Interval; %w", err)
	}
	partial["Interval"] = fieldInterval
	var fieldParentRunID []byte
	fieldParentRunID, err = r._marshalJSONstring(x.ParentRunID)
	if err != nil {
		return nil, fmt.Errorf("workflow: ScheduleRun._marshalJSONScheduleRun: field name ParentRunID; %w", err)
	}
	partial["ParentRunID"] = fieldParentRunID
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: ScheduleRun._marshalJSONScheduleRun: struct; %w", err)
	}
	return result, nil
}
func (r *ScheduleRun) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: ScheduleRun._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *ScheduleRun) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONScheduleRun(data)
	if err != nil {
		return fmt.Errorf("workflow: ScheduleRun.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *ScheduleRun) _unmarshalJSONScheduleRun(data []byte) (ScheduleRun, error) {
	result := ScheduleRun{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: ScheduleRun._unmarshalJSONScheduleRun: native struct unwrap; %w", err)
	}
	if fieldInterval, ok := partial["Interval"]; ok {
		result.Interval, err = r._unmarshalJSONstring(fieldInterval)
		if err != nil {
			return result, fmt.Errorf("workflow: ScheduleRun._unmarshalJSONScheduleRun: field Interval; %w", err)
		}
	}
	if fieldParentRunID, ok := partial["ParentRunID"]; ok {
		result.ParentRunID, err = r._unmarshalJSONstring(fieldParentRunID)
		if err != nil {
			return result, fmt.Errorf("workflow: ScheduleRun._unmarshalJSONScheduleRun: field ParentRunID; %w", err)
		}
	}
	return result, nil
}
func (r *ScheduleRun) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: ScheduleRun._unmarshalJSONstring: native string unwrap; %w", err)
	}
	return result, nil
}

func DelayRunFromJSON(x []byte) (*DelayRun, error) {
	result := new(DelayRun)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func DelayRunToJSON(x *DelayRun) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*DelayRun)(nil)
	_ json.Marshaler   = (*DelayRun)(nil)
)

func (r *DelayRun) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONDelayRun(*r)
}
func (r *DelayRun) _marshalJSONDelayRun(x DelayRun) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldDelayBySeconds []byte
	fieldDelayBySeconds, err = r._marshalJSONint64(x.DelayBySeconds)
	if err != nil {
		return nil, fmt.Errorf("workflow: DelayRun._marshalJSONDelayRun: field name DelayBySeconds; %w", err)
	}
	partial["DelayBySeconds"] = fieldDelayBySeconds
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: DelayRun._marshalJSONDelayRun: struct; %w", err)
	}
	return result, nil
}
func (r *DelayRun) _marshalJSONint64(x int64) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: DelayRun._marshalJSONint64:; %w", err)
	}
	return result, nil
}
func (r *DelayRun) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONDelayRun(data)
	if err != nil {
		return fmt.Errorf("workflow: DelayRun.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *DelayRun) _unmarshalJSONDelayRun(data []byte) (DelayRun, error) {
	result := DelayRun{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: DelayRun._unmarshalJSONDelayRun: native struct unwrap; %w", err)
	}
	if fieldDelayBySeconds, ok := partial["DelayBySeconds"]; ok {
		result.DelayBySeconds, err = r._unmarshalJSONint64(fieldDelayBySeconds)
		if err != nil {
			return result, fmt.Errorf("workflow: DelayRun._unmarshalJSONDelayRun: field DelayBySeconds; %w", err)
		}
	}
	return result, nil
}
func (r *DelayRun) _unmarshalJSONint64(data []byte) (int64, error) {
	var result int64
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: DelayRun._unmarshalJSONint64: native number unwrap; %w", err)
	}
	return result, nil
}
