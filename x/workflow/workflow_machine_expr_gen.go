// Code generated by mkunion. DO NOT EDIT.
package workflow

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/f"
	"github.com/widmogrod/mkunion/x/shape"
	"github.com/widmogrod/mkunion/x/shared"
)

func init() {
	shape.Register(ExprShape())
	shape.Register(EndShape())
	shape.Register(AssignShape())
	shape.Register(ApplyShape())
	shape.Register(ChooseShape())
}

//mkunion-extension:visitor

type ExprVisitor interface {
	VisitEnd(v *End) any
	VisitAssign(v *Assign) any
	VisitApply(v *Apply) any
	VisitChoose(v *Choose) any
}

type Expr interface {
	AcceptExpr(g ExprVisitor) any
}

func (r *End) AcceptExpr(v ExprVisitor) any    { return v.VisitEnd(r) }
func (r *Assign) AcceptExpr(v ExprVisitor) any { return v.VisitAssign(r) }
func (r *Apply) AcceptExpr(v ExprVisitor) any  { return v.VisitApply(r) }
func (r *Choose) AcceptExpr(v ExprVisitor) any { return v.VisitChoose(r) }

var (
	_ Expr = (*End)(nil)
	_ Expr = (*Assign)(nil)
	_ Expr = (*Apply)(nil)
	_ Expr = (*Choose)(nil)
)

func MatchExpr[TOut any](
	x Expr,
	f1 func(x *End) TOut,
	f2 func(x *Assign) TOut,
	f3 func(x *Apply) TOut,
	f4 func(x *Choose) TOut,
	df func(x Expr) TOut,
) TOut {
	return f.Match4(x, f1, f2, f3, f4, df)
}

func MatchExprR2[TOut1, TOut2 any](
	x Expr,
	f1 func(x *End) (TOut1, TOut2),
	f2 func(x *Assign) (TOut1, TOut2),
	f3 func(x *Apply) (TOut1, TOut2),
	f4 func(x *Choose) (TOut1, TOut2),
	df func(x Expr) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.Match4R2(x, f1, f2, f3, f4, df)
}

func MustMatchExpr[TOut any](
	x Expr,
	f1 func(x *End) TOut,
	f2 func(x *Assign) TOut,
	f3 func(x *Apply) TOut,
	f4 func(x *Choose) TOut,
) TOut {
	return f.MustMatch4(x, f1, f2, f3, f4)
}

func MustMatchExprR0(
	x Expr,
	f1 func(x *End),
	f2 func(x *Assign),
	f3 func(x *Apply),
	f4 func(x *Choose),
) {
	f.MustMatch4R0(x, f1, f2, f3, f4)
}

func MustMatchExprR2[TOut1, TOut2 any](
	x Expr,
	f1 func(x *End) (TOut1, TOut2),
	f2 func(x *Assign) (TOut1, TOut2),
	f3 func(x *Apply) (TOut1, TOut2),
	f4 func(x *Choose) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.MustMatch4R2(x, f1, f2, f3, f4)
}

//mkunion-extension:shape

func ExprShape() shape.Shape {
	return &shape.UnionLike{
		Name:          "Expr",
		PkgName:       "workflow",
		PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
		Variant: []shape.Shape{
			EndShape(),
			AssignShape(),
			ApplyShape(),
			ChooseShape(),
		},
	}
}

func EndShape() shape.Shape {
	return &shape.StructLike{
		Name:          "End",
		PkgName:       "workflow",
		PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
		Fields: []*shape.FieldLike{
			{
				Name: "ID",
				Type: &shape.StringLike{},
			},
			{
				Name: "Result",
				Type: &shape.RefName{
					Name:          "Reshaper",
					PkgName:       "workflow",
					PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
				},
			},
		},
	}
}

func AssignShape() shape.Shape {
	return &shape.StructLike{
		Name:          "Assign",
		PkgName:       "workflow",
		PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
		Fields: []*shape.FieldLike{
			{
				Name: "ID",
				Type: &shape.StringLike{},
			},
			{
				Name: "VarOk",
				Type: &shape.StringLike{},
			},
			{
				Name: "VarErr",
				Type: &shape.StringLike{},
			},
			{
				Name: "Val",
				Type: &shape.RefName{
					Name:          "Expr",
					PkgName:       "workflow",
					PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
				},
			},
		},
	}
}

func ApplyShape() shape.Shape {
	return &shape.StructLike{
		Name:          "Apply",
		PkgName:       "workflow",
		PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
		Fields: []*shape.FieldLike{
			{
				Name: "ID",
				Type: &shape.StringLike{},
			},
			{
				Name: "Name",
				Type: &shape.StringLike{},
			},
			{
				Name: "Args",
				Type: &shape.ListLike{
					Element: &shape.RefName{
						Name:          "Reshaper",
						PkgName:       "workflow",
						PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
					},
				},
			},
			{
				Name: "Await",
				Type: &shape.RefName{
					Name:          "ApplyAwaitOptions",
					PkgName:       "workflow",
					PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
					IsPointer:     true,
				},
				IsPointer: true,
			},
		},
	}
}

func ChooseShape() shape.Shape {
	return &shape.StructLike{
		Name:          "Choose",
		PkgName:       "workflow",
		PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
		Fields: []*shape.FieldLike{
			{
				Name: "ID",
				Type: &shape.StringLike{},
			},
			{
				Name: "If",
				Type: &shape.RefName{
					Name:          "Predicate",
					PkgName:       "workflow",
					PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
				},
			},
			{
				Name: "Then",
				Type: &shape.ListLike{
					Element: &shape.RefName{
						Name:          "Expr",
						PkgName:       "workflow",
						PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
					},
				},
			},
			{
				Name: "Else",
				Type: &shape.ListLike{
					Element: &shape.RefName{
						Name:          "Expr",
						PkgName:       "workflow",
						PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
					},
				},
			},
		},
	}
}

// mkunion-extension:json
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Expr", ExprFromJSON, ExprToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.End", EndFromJSON, EndToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Assign", AssignFromJSON, AssignToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Apply", ApplyFromJSON, ApplyToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Choose", ChooseFromJSON, ChooseToJSON)
}

type ExprUnionJSON struct {
	Type   string          `json:"$type,omitempty"`
	End    json.RawMessage `json:"workflow.End,omitempty"`
	Assign json.RawMessage `json:"workflow.Assign,omitempty"`
	Apply  json.RawMessage `json:"workflow.Apply,omitempty"`
	Choose json.RawMessage `json:"workflow.Choose,omitempty"`
}

func ExprFromJSON(x []byte) (Expr, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}

	var data ExprUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, err
	}

	switch data.Type {
	case "workflow.End":
		return EndFromJSON(data.End)
	case "workflow.Assign":
		return AssignFromJSON(data.Assign)
	case "workflow.Apply":
		return ApplyFromJSON(data.Apply)
	case "workflow.Choose":
		return ChooseFromJSON(data.Choose)
	}

	if data.End != nil {
		return EndFromJSON(data.End)
	} else if data.Assign != nil {
		return AssignFromJSON(data.Assign)
	} else if data.Apply != nil {
		return ApplyFromJSON(data.Apply)
	} else if data.Choose != nil {
		return ChooseFromJSON(data.Choose)
	}

	return nil, fmt.Errorf("workflow.Expr: unknown type %s", data.Type)
}

func ExprToJSON(x Expr) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return MustMatchExprR2(
		x,
		func(x *End) ([]byte, error) {
			body, err := EndToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(ExprUnionJSON{
				Type: "workflow.End",
				End:  body,
			})
		},
		func(x *Assign) ([]byte, error) {
			body, err := AssignToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(ExprUnionJSON{
				Type:   "workflow.Assign",
				Assign: body,
			})
		},
		func(x *Apply) ([]byte, error) {
			body, err := ApplyToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(ExprUnionJSON{
				Type:  "workflow.Apply",
				Apply: body,
			})
		},
		func(x *Choose) ([]byte, error) {
			body, err := ChooseToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(ExprUnionJSON{
				Type:   "workflow.Choose",
				Choose: body,
			})
		},
	)
}

func EndFromJSON(x []byte) (*End, error) {
	result := new(End)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func EndToJSON(x *End) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*End)(nil)
	_ json.Marshaler   = (*End)(nil)
)

func (r *End) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONEnd(*r)
}
func (r *End) _marshalJSONEnd(x End) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldID []byte
	fieldID, err = r._marshalJSONstring(x.ID)
	if err != nil {
		return nil, fmt.Errorf("workflow: End._marshalJSONEnd: field name ID; %w", err)
	}
	partial["ID"] = fieldID
	var fieldResult []byte
	fieldResult, err = r._marshalJSONReshaper(x.Result)
	if err != nil {
		return nil, fmt.Errorf("workflow: End._marshalJSONEnd: field name Result; %w", err)
	}
	partial["Result"] = fieldResult
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: End._marshalJSONEnd: struct; %w", err)
	}
	return result, nil
}
func (r *End) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: End._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *End) _marshalJSONReshaper(x Reshaper) ([]byte, error) {
	result, err := shared.JSONMarshal[Reshaper](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: End._marshalJSONReshaper:; %w", err)
	}
	return result, nil
}
func (r *End) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONEnd(data)
	if err != nil {
		return fmt.Errorf("workflow: End.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *End) _unmarshalJSONEnd(data []byte) (End, error) {
	result := End{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: End._unmarshalJSONEnd: native struct unwrap; %w", err)
	}
	if fieldID, ok := partial["ID"]; ok {
		result.ID, err = r._unmarshalJSONstring(fieldID)
		if err != nil {
			return result, fmt.Errorf("workflow: End._unmarshalJSONEnd: field ID; %w", err)
		}
	}
	if fieldResult, ok := partial["Result"]; ok {
		result.Result, err = r._unmarshalJSONReshaper(fieldResult)
		if err != nil {
			return result, fmt.Errorf("workflow: End._unmarshalJSONEnd: field Result; %w", err)
		}
	}
	return result, nil
}
func (r *End) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: End._unmarshalJSONstring: native string unwrap; %w", err)
	}
	return result, nil
}
func (r *End) _unmarshalJSONReshaper(data []byte) (Reshaper, error) {
	result, err := shared.JSONUnmarshal[Reshaper](data)
	if err != nil {
		return result, fmt.Errorf("workflow: End._unmarshalJSONReshaper: native ref unwrap; %w", err)
	}
	return result, nil
}

func AssignFromJSON(x []byte) (*Assign, error) {
	result := new(Assign)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func AssignToJSON(x *Assign) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Assign)(nil)
	_ json.Marshaler   = (*Assign)(nil)
)

func (r *Assign) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONAssign(*r)
}
func (r *Assign) _marshalJSONAssign(x Assign) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldID []byte
	fieldID, err = r._marshalJSONstring(x.ID)
	if err != nil {
		return nil, fmt.Errorf("workflow: Assign._marshalJSONAssign: field name ID; %w", err)
	}
	partial["ID"] = fieldID
	var fieldVarOk []byte
	fieldVarOk, err = r._marshalJSONstring(x.VarOk)
	if err != nil {
		return nil, fmt.Errorf("workflow: Assign._marshalJSONAssign: field name VarOk; %w", err)
	}
	partial["VarOk"] = fieldVarOk
	var fieldVarErr []byte
	fieldVarErr, err = r._marshalJSONstring(x.VarErr)
	if err != nil {
		return nil, fmt.Errorf("workflow: Assign._marshalJSONAssign: field name VarErr; %w", err)
	}
	partial["VarErr"] = fieldVarErr
	var fieldVal []byte
	fieldVal, err = r._marshalJSONExpr(x.Val)
	if err != nil {
		return nil, fmt.Errorf("workflow: Assign._marshalJSONAssign: field name Val; %w", err)
	}
	partial["Val"] = fieldVal
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Assign._marshalJSONAssign: struct; %w", err)
	}
	return result, nil
}
func (r *Assign) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Assign._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *Assign) _marshalJSONExpr(x Expr) ([]byte, error) {
	result, err := shared.JSONMarshal[Expr](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Assign._marshalJSONExpr:; %w", err)
	}
	return result, nil
}
func (r *Assign) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONAssign(data)
	if err != nil {
		return fmt.Errorf("workflow: Assign.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Assign) _unmarshalJSONAssign(data []byte) (Assign, error) {
	result := Assign{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Assign._unmarshalJSONAssign: native struct unwrap; %w", err)
	}
	if fieldID, ok := partial["ID"]; ok {
		result.ID, err = r._unmarshalJSONstring(fieldID)
		if err != nil {
			return result, fmt.Errorf("workflow: Assign._unmarshalJSONAssign: field ID; %w", err)
		}
	}
	if fieldVarOk, ok := partial["VarOk"]; ok {
		result.VarOk, err = r._unmarshalJSONstring(fieldVarOk)
		if err != nil {
			return result, fmt.Errorf("workflow: Assign._unmarshalJSONAssign: field VarOk; %w", err)
		}
	}
	if fieldVarErr, ok := partial["VarErr"]; ok {
		result.VarErr, err = r._unmarshalJSONstring(fieldVarErr)
		if err != nil {
			return result, fmt.Errorf("workflow: Assign._unmarshalJSONAssign: field VarErr; %w", err)
		}
	}
	if fieldVal, ok := partial["Val"]; ok {
		result.Val, err = r._unmarshalJSONExpr(fieldVal)
		if err != nil {
			return result, fmt.Errorf("workflow: Assign._unmarshalJSONAssign: field Val; %w", err)
		}
	}
	return result, nil
}
func (r *Assign) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: Assign._unmarshalJSONstring: native string unwrap; %w", err)
	}
	return result, nil
}
func (r *Assign) _unmarshalJSONExpr(data []byte) (Expr, error) {
	result, err := shared.JSONUnmarshal[Expr](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Assign._unmarshalJSONExpr: native ref unwrap; %w", err)
	}
	return result, nil
}

func ApplyFromJSON(x []byte) (*Apply, error) {
	result := new(Apply)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func ApplyToJSON(x *Apply) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Apply)(nil)
	_ json.Marshaler   = (*Apply)(nil)
)

func (r *Apply) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONApply(*r)
}
func (r *Apply) _marshalJSONApply(x Apply) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldID []byte
	fieldID, err = r._marshalJSONstring(x.ID)
	if err != nil {
		return nil, fmt.Errorf("workflow: Apply._marshalJSONApply: field name ID; %w", err)
	}
	partial["ID"] = fieldID
	var fieldName []byte
	fieldName, err = r._marshalJSONstring(x.Name)
	if err != nil {
		return nil, fmt.Errorf("workflow: Apply._marshalJSONApply: field name Name; %w", err)
	}
	partial["Name"] = fieldName
	var fieldArgs []byte
	fieldArgs, err = r._marshalJSONSliceReshaper(x.Args)
	if err != nil {
		return nil, fmt.Errorf("workflow: Apply._marshalJSONApply: field name Args; %w", err)
	}
	partial["Args"] = fieldArgs
	if x.Await != nil {
		var fieldAwait []byte
		fieldAwait, err = r._marshalJSONPtrApplyAwaitOptions(x.Await)
		if err != nil {
			return nil, fmt.Errorf("workflow: Apply._marshalJSONApply: field name Await; %w", err)
		}
		partial["Await"] = fieldAwait
	}
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Apply._marshalJSONApply: struct; %w", err)
	}
	return result, nil
}
func (r *Apply) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Apply._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *Apply) _marshalJSONSliceReshaper(x []Reshaper) ([]byte, error) {
	partial := make([]json.RawMessage, len(x))
	for i, v := range x {
		item, err := r._marshalJSONReshaper(v)
		if err != nil {
			return nil, fmt.Errorf("workflow: Apply._marshalJSONSliceReshaper: at index %d; %w", i, err)
		}
		partial[i] = item
	}
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Apply._marshalJSONSliceReshaper:; %w", err)
	}
	return result, nil
}
func (r *Apply) _marshalJSONReshaper(x Reshaper) ([]byte, error) {
	result, err := shared.JSONMarshal[Reshaper](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Apply._marshalJSONReshaper:; %w", err)
	}
	return result, nil
}
func (r *Apply) _marshalJSONPtrApplyAwaitOptions(x *ApplyAwaitOptions) ([]byte, error) {
	result, err := shared.JSONMarshal[*ApplyAwaitOptions](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Apply._marshalJSONPtrApplyAwaitOptions:; %w", err)
	}
	return result, nil
}
func (r *Apply) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONApply(data)
	if err != nil {
		return fmt.Errorf("workflow: Apply.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Apply) _unmarshalJSONApply(data []byte) (Apply, error) {
	result := Apply{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Apply._unmarshalJSONApply: native struct unwrap; %w", err)
	}
	if fieldID, ok := partial["ID"]; ok {
		result.ID, err = r._unmarshalJSONstring(fieldID)
		if err != nil {
			return result, fmt.Errorf("workflow: Apply._unmarshalJSONApply: field ID; %w", err)
		}
	}
	if fieldName, ok := partial["Name"]; ok {
		result.Name, err = r._unmarshalJSONstring(fieldName)
		if err != nil {
			return result, fmt.Errorf("workflow: Apply._unmarshalJSONApply: field Name; %w", err)
		}
	}
	if fieldArgs, ok := partial["Args"]; ok {
		result.Args, err = r._unmarshalJSONSliceReshaper(fieldArgs)
		if err != nil {
			return result, fmt.Errorf("workflow: Apply._unmarshalJSONApply: field Args; %w", err)
		}
	}
	if fieldAwait, ok := partial["Await"]; ok {
		result.Await, err = r._unmarshalJSONPtrApplyAwaitOptions(fieldAwait)
		if err != nil {
			return result, fmt.Errorf("workflow: Apply._unmarshalJSONApply: field Await; %w", err)
		}
	}
	return result, nil
}
func (r *Apply) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: Apply._unmarshalJSONstring: native string unwrap; %w", err)
	}
	return result, nil
}
func (r *Apply) _unmarshalJSONSliceReshaper(data []byte) ([]Reshaper, error) {
	result := make([]Reshaper, 0)
	var partial []json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Apply._unmarshalJSONSliceReshaper: native list unwrap; %w", err)
	}
	for i, v := range partial {
		item, err := r._unmarshalJSONReshaper(v)
		if err != nil {
			return result, fmt.Errorf("workflow: Apply._unmarshalJSONSliceReshaper: at index %d; %w", i, err)
		}
		result = append(result, item)
	}
	return result, nil
}
func (r *Apply) _unmarshalJSONReshaper(data []byte) (Reshaper, error) {
	result, err := shared.JSONUnmarshal[Reshaper](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Apply._unmarshalJSONReshaper: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *Apply) _unmarshalJSONPtrApplyAwaitOptions(data []byte) (*ApplyAwaitOptions, error) {
	result, err := shared.JSONUnmarshal[*ApplyAwaitOptions](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Apply._unmarshalJSONPtrApplyAwaitOptions: native ref unwrap; %w", err)
	}
	return result, nil
}

func ChooseFromJSON(x []byte) (*Choose, error) {
	result := new(Choose)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func ChooseToJSON(x *Choose) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Choose)(nil)
	_ json.Marshaler   = (*Choose)(nil)
)

func (r *Choose) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONChoose(*r)
}
func (r *Choose) _marshalJSONChoose(x Choose) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldID []byte
	fieldID, err = r._marshalJSONstring(x.ID)
	if err != nil {
		return nil, fmt.Errorf("workflow: Choose._marshalJSONChoose: field name ID; %w", err)
	}
	partial["ID"] = fieldID
	var fieldIf []byte
	fieldIf, err = r._marshalJSONPredicate(x.If)
	if err != nil {
		return nil, fmt.Errorf("workflow: Choose._marshalJSONChoose: field name If; %w", err)
	}
	partial["If"] = fieldIf
	var fieldThen []byte
	fieldThen, err = r._marshalJSONSliceExpr(x.Then)
	if err != nil {
		return nil, fmt.Errorf("workflow: Choose._marshalJSONChoose: field name Then; %w", err)
	}
	partial["Then"] = fieldThen
	var fieldElse []byte
	fieldElse, err = r._marshalJSONSliceExpr(x.Else)
	if err != nil {
		return nil, fmt.Errorf("workflow: Choose._marshalJSONChoose: field name Else; %w", err)
	}
	partial["Else"] = fieldElse
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Choose._marshalJSONChoose: struct; %w", err)
	}
	return result, nil
}
func (r *Choose) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Choose._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *Choose) _marshalJSONPredicate(x Predicate) ([]byte, error) {
	result, err := shared.JSONMarshal[Predicate](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Choose._marshalJSONPredicate:; %w", err)
	}
	return result, nil
}
func (r *Choose) _marshalJSONSliceExpr(x []Expr) ([]byte, error) {
	partial := make([]json.RawMessage, len(x))
	for i, v := range x {
		item, err := r._marshalJSONExpr(v)
		if err != nil {
			return nil, fmt.Errorf("workflow: Choose._marshalJSONSliceExpr: at index %d; %w", i, err)
		}
		partial[i] = item
	}
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Choose._marshalJSONSliceExpr:; %w", err)
	}
	return result, nil
}
func (r *Choose) _marshalJSONExpr(x Expr) ([]byte, error) {
	result, err := shared.JSONMarshal[Expr](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Choose._marshalJSONExpr:; %w", err)
	}
	return result, nil
}
func (r *Choose) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONChoose(data)
	if err != nil {
		return fmt.Errorf("workflow: Choose.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Choose) _unmarshalJSONChoose(data []byte) (Choose, error) {
	result := Choose{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Choose._unmarshalJSONChoose: native struct unwrap; %w", err)
	}
	if fieldID, ok := partial["ID"]; ok {
		result.ID, err = r._unmarshalJSONstring(fieldID)
		if err != nil {
			return result, fmt.Errorf("workflow: Choose._unmarshalJSONChoose: field ID; %w", err)
		}
	}
	if fieldIf, ok := partial["If"]; ok {
		result.If, err = r._unmarshalJSONPredicate(fieldIf)
		if err != nil {
			return result, fmt.Errorf("workflow: Choose._unmarshalJSONChoose: field If; %w", err)
		}
	}
	if fieldThen, ok := partial["Then"]; ok {
		result.Then, err = r._unmarshalJSONSliceExpr(fieldThen)
		if err != nil {
			return result, fmt.Errorf("workflow: Choose._unmarshalJSONChoose: field Then; %w", err)
		}
	}
	if fieldElse, ok := partial["Else"]; ok {
		result.Else, err = r._unmarshalJSONSliceExpr(fieldElse)
		if err != nil {
			return result, fmt.Errorf("workflow: Choose._unmarshalJSONChoose: field Else; %w", err)
		}
	}
	return result, nil
}
func (r *Choose) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: Choose._unmarshalJSONstring: native string unwrap; %w", err)
	}
	return result, nil
}
func (r *Choose) _unmarshalJSONPredicate(data []byte) (Predicate, error) {
	result, err := shared.JSONUnmarshal[Predicate](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Choose._unmarshalJSONPredicate: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *Choose) _unmarshalJSONSliceExpr(data []byte) ([]Expr, error) {
	result := make([]Expr, 0)
	var partial []json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Choose._unmarshalJSONSliceExpr: native list unwrap; %w", err)
	}
	for i, v := range partial {
		item, err := r._unmarshalJSONExpr(v)
		if err != nil {
			return result, fmt.Errorf("workflow: Choose._unmarshalJSONSliceExpr: at index %d; %w", i, err)
		}
		result = append(result, item)
	}
	return result, nil
}
func (r *Choose) _unmarshalJSONExpr(data []byte) (Expr, error) {
	result, err := shared.JSONUnmarshal[Expr](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Choose._unmarshalJSONExpr: native ref unwrap; %w", err)
	}
	return result, nil
}
