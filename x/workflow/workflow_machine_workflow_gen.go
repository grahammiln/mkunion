// Code generated by mkunion. DO NOT EDIT.
package workflow

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/f"
	"github.com/widmogrod/mkunion/x/shape"
	"github.com/widmogrod/mkunion/x/shared"
)

func init() {
	shape.Register(WorkflowShape())
	shape.Register(FlowShape())
	shape.Register(FlowRefShape())
}

//mkunion-extension:visitor

type WorkflowVisitor interface {
	VisitFlow(v *Flow) any
	VisitFlowRef(v *FlowRef) any
}

type Workflow interface {
	AcceptWorkflow(g WorkflowVisitor) any
}

func (r *Flow) AcceptWorkflow(v WorkflowVisitor) any    { return v.VisitFlow(r) }
func (r *FlowRef) AcceptWorkflow(v WorkflowVisitor) any { return v.VisitFlowRef(r) }

var (
	_ Workflow = (*Flow)(nil)
	_ Workflow = (*FlowRef)(nil)
)

func MatchWorkflow[TOut any](
	x Workflow,
	f1 func(x *Flow) TOut,
	f2 func(x *FlowRef) TOut,
	df func(x Workflow) TOut,
) TOut {
	return f.Match2(x, f1, f2, df)
}

func MatchWorkflowR2[TOut1, TOut2 any](
	x Workflow,
	f1 func(x *Flow) (TOut1, TOut2),
	f2 func(x *FlowRef) (TOut1, TOut2),
	df func(x Workflow) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.Match2R2(x, f1, f2, df)
}

func MustMatchWorkflow[TOut any](
	x Workflow,
	f1 func(x *Flow) TOut,
	f2 func(x *FlowRef) TOut,
) TOut {
	return f.MustMatch2(x, f1, f2)
}

func MustMatchWorkflowR0(
	x Workflow,
	f1 func(x *Flow),
	f2 func(x *FlowRef),
) {
	f.MustMatch2R0(x, f1, f2)
}

func MustMatchWorkflowR2[TOut1, TOut2 any](
	x Workflow,
	f1 func(x *Flow) (TOut1, TOut2),
	f2 func(x *FlowRef) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.MustMatch2R2(x, f1, f2)
}

//mkunion-extension:shape

func WorkflowShape() shape.Shape {
	return &shape.UnionLike{
		Name:          "Workflow",
		PkgName:       "workflow",
		PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
		Variant: []shape.Shape{
			FlowShape(),
			FlowRefShape(),
		},
	}
}

func FlowShape() shape.Shape {
	return &shape.StructLike{
		Name:          "Flow",
		PkgName:       "workflow",
		PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
		Fields: []*shape.FieldLike{
			{
				Name: "Name",
				Type: &shape.StringLike{},
			},
			{
				Name: "Arg",
				Type: &shape.StringLike{},
			},
			{
				Name: "Body",
				Type: &shape.ListLike{
					Element: &shape.RefName{
						Name:          "Expr",
						PkgName:       "workflow",
						PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
					},
				},
			},
		},
	}
}

func FlowRefShape() shape.Shape {
	return &shape.StructLike{
		Name:          "FlowRef",
		PkgName:       "workflow",
		PkgImportName: "github.com/widmogrod/mkunion/x/workflow",
		Fields: []*shape.FieldLike{
			{
				Name: "FlowID",
				Type: &shape.StringLike{},
			},
		},
	}
}

// mkunion-extension:json
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Workflow", WorkflowFromJSON, WorkflowToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.Flow", FlowFromJSON, FlowToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.FlowRef", FlowRefFromJSON, FlowRefToJSON)
}

type WorkflowUnionJSON struct {
	Type    string          `json:"$type,omitempty"`
	Flow    json.RawMessage `json:"workflow.Flow,omitempty"`
	FlowRef json.RawMessage `json:"workflow.FlowRef,omitempty"`
}

func WorkflowFromJSON(x []byte) (Workflow, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}

	var data WorkflowUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, err
	}

	switch data.Type {
	case "workflow.Flow":
		return FlowFromJSON(data.Flow)
	case "workflow.FlowRef":
		return FlowRefFromJSON(data.FlowRef)
	}

	if data.Flow != nil {
		return FlowFromJSON(data.Flow)
	} else if data.FlowRef != nil {
		return FlowRefFromJSON(data.FlowRef)
	}

	return nil, fmt.Errorf("workflow.Workflow: unknown type %s", data.Type)
}

func WorkflowToJSON(x Workflow) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return MustMatchWorkflowR2(
		x,
		func(x *Flow) ([]byte, error) {
			body, err := FlowToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(WorkflowUnionJSON{
				Type: "workflow.Flow",
				Flow: body,
			})
		},
		func(x *FlowRef) ([]byte, error) {
			body, err := FlowRefToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(WorkflowUnionJSON{
				Type:    "workflow.FlowRef",
				FlowRef: body,
			})
		},
	)
}

func FlowFromJSON(x []byte) (*Flow, error) {
	result := new(Flow)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func FlowToJSON(x *Flow) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Flow)(nil)
	_ json.Marshaler   = (*Flow)(nil)
)

func (r *Flow) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONFlow(*r)
}
func (r *Flow) _marshalJSONFlow(x Flow) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldName []byte
	fieldName, err = r._marshalJSONstring(x.Name)
	if err != nil {
		return nil, fmt.Errorf("workflow: Flow._marshalJSONFlow: field name Name; %w", err)
	}
	partial["Name"] = fieldName
	var fieldArg []byte
	fieldArg, err = r._marshalJSONstring(x.Arg)
	if err != nil {
		return nil, fmt.Errorf("workflow: Flow._marshalJSONFlow: field name Arg; %w", err)
	}
	partial["Arg"] = fieldArg
	var fieldBody []byte
	fieldBody, err = r._marshalJSONSliceExpr(x.Body)
	if err != nil {
		return nil, fmt.Errorf("workflow: Flow._marshalJSONFlow: field name Body; %w", err)
	}
	partial["Body"] = fieldBody
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Flow._marshalJSONFlow: struct; %w", err)
	}
	return result, nil
}
func (r *Flow) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Flow._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *Flow) _marshalJSONSliceExpr(x []Expr) ([]byte, error) {
	partial := make([]json.RawMessage, len(x))
	for i, v := range x {
		item, err := r._marshalJSONExpr(v)
		if err != nil {
			return nil, fmt.Errorf("workflow: Flow._marshalJSONSliceExpr: at index %d; %w", i, err)
		}
		partial[i] = item
	}
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: Flow._marshalJSONSliceExpr:; %w", err)
	}
	return result, nil
}
func (r *Flow) _marshalJSONExpr(x Expr) ([]byte, error) {
	result, err := shared.JSONMarshal[Expr](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: Flow._marshalJSONExpr:; %w", err)
	}
	return result, nil
}
func (r *Flow) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONFlow(data)
	if err != nil {
		return fmt.Errorf("workflow: Flow.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Flow) _unmarshalJSONFlow(data []byte) (Flow, error) {
	result := Flow{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Flow._unmarshalJSONFlow: native struct unwrap; %w", err)
	}
	if fieldName, ok := partial["Name"]; ok {
		result.Name, err = r._unmarshalJSONstring(fieldName)
		if err != nil {
			return result, fmt.Errorf("workflow: Flow._unmarshalJSONFlow: field Name; %w", err)
		}
	}
	if fieldArg, ok := partial["Arg"]; ok {
		result.Arg, err = r._unmarshalJSONstring(fieldArg)
		if err != nil {
			return result, fmt.Errorf("workflow: Flow._unmarshalJSONFlow: field Arg; %w", err)
		}
	}
	if fieldBody, ok := partial["Body"]; ok {
		result.Body, err = r._unmarshalJSONSliceExpr(fieldBody)
		if err != nil {
			return result, fmt.Errorf("workflow: Flow._unmarshalJSONFlow: field Body; %w", err)
		}
	}
	return result, nil
}
func (r *Flow) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: Flow._unmarshalJSONstring: native string unwrap; %w", err)
	}
	return result, nil
}
func (r *Flow) _unmarshalJSONSliceExpr(data []byte) ([]Expr, error) {
	result := make([]Expr, 0)
	var partial []json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: Flow._unmarshalJSONSliceExpr: native list unwrap; %w", err)
	}
	for i, v := range partial {
		item, err := r._unmarshalJSONExpr(v)
		if err != nil {
			return result, fmt.Errorf("workflow: Flow._unmarshalJSONSliceExpr: at index %d; %w", i, err)
		}
		result = append(result, item)
	}
	return result, nil
}
func (r *Flow) _unmarshalJSONExpr(data []byte) (Expr, error) {
	result, err := shared.JSONUnmarshal[Expr](data)
	if err != nil {
		return result, fmt.Errorf("workflow: Flow._unmarshalJSONExpr: native ref unwrap; %w", err)
	}
	return result, nil
}

func FlowRefFromJSON(x []byte) (*FlowRef, error) {
	result := new(FlowRef)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func FlowRefToJSON(x *FlowRef) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*FlowRef)(nil)
	_ json.Marshaler   = (*FlowRef)(nil)
)

func (r *FlowRef) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONFlowRef(*r)
}
func (r *FlowRef) _marshalJSONFlowRef(x FlowRef) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldFlowID []byte
	fieldFlowID, err = r._marshalJSONstring(x.FlowID)
	if err != nil {
		return nil, fmt.Errorf("workflow: FlowRef._marshalJSONFlowRef: field name FlowID; %w", err)
	}
	partial["FlowID"] = fieldFlowID
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: FlowRef._marshalJSONFlowRef: struct; %w", err)
	}
	return result, nil
}
func (r *FlowRef) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: FlowRef._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *FlowRef) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONFlowRef(data)
	if err != nil {
		return fmt.Errorf("workflow: FlowRef.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *FlowRef) _unmarshalJSONFlowRef(data []byte) (FlowRef, error) {
	result := FlowRef{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: FlowRef._unmarshalJSONFlowRef: native struct unwrap; %w", err)
	}
	if fieldFlowID, ok := partial["FlowID"]; ok {
		result.FlowID, err = r._unmarshalJSONstring(fieldFlowID)
		if err != nil {
			return result, fmt.Errorf("workflow: FlowRef._unmarshalJSONFlowRef: field FlowID; %w", err)
		}
	}
	return result, nil
}
func (r *FlowRef) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: FlowRef._unmarshalJSONstring: native string unwrap; %w", err)
	}
	return result, nil
}
