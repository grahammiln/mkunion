package generators

import (
	"bytes"
	_ "embed"
	"fmt"
	log "github.com/sirupsen/logrus"
	"github.com/widmogrod/mkunion/x/shape"
	"github.com/widmogrod/mkunion/x/shared"
	"text/template"
)

const (
	Header = `// Code generated by ` + shared.Program + `. DO NOT EDIT.`
)

type generatorOptions struct {
	Header      string
	PackageName string

	bufferImports bool
}

type GenerateOption func(o *generatorOptions)

func WithBufferedImports() GenerateOption {
	return func(o *generatorOptions) {
		o.bufferImports = true
	}
}

func WithPackageName(name string) GenerateOption {
	return func(o *generatorOptions) {
		o.PackageName = name
	}
}

type Generator interface {
	Generate() ([]byte, error)
}

func NewHelper(fs ...GenerateOption) *Helpers {
	options := generatorOptions{
		Header:      Header,
		PackageName: "visitor_generator.go.tmpl",
	}

	for _, f := range fs {
		f(&options)
	}

	return &Helpers{
		options: options,
		imports: nil,
	}
}

type Helpers struct {
	options generatorOptions

	imports []string
}

func (help *Helpers) RenderHeader() string {
	if help.options.bufferImports {
		return ""
	}

	return help.RenderBufferedHeader()
}

func (help *Helpers) RenderBufferedHeader() string {
	result := &bytes.Buffer{}
	fmt.Fprintf(result, "%s\n", help.options.Header)
	fmt.Fprintf(result, "package %s\n\n", help.options.PackageName)
	return result.String()
}

func (help *Helpers) RenderBufferedImport() string {
	result := &bytes.Buffer{}
	log.Debugf("render import %v", help.imports)
	for _, name := range help.imports {
		fmt.Fprintf(result, "import %q\n", name)
	}

	return result.String()
}

func (help *Helpers) RenderImport(importName ...string) string {
	if len(importName) == 0 {
		return ""
	}

	if help.options.bufferImports {
		log.Debugf("buffer import %v", importName)
		// dont append when already exists
		for _, name := range importName {
			exists := false
			for _, existsName := range help.imports {
				if existsName == name {
					exists = true
					break
				}
			}

			if !exists {
				help.imports = append(help.imports, name)
			}
		}
		return ""
	}

	result := &bytes.Buffer{}
	for _, name := range importName {
		fmt.Fprintf(result, "import %q\n", name)
	}

	result.WriteString("\n")

	return result.String()
}

func (help *Helpers) Func() template.FuncMap {
	return map[string]any{
		"RenderHeader": help.RenderHeader,
		"RenderImport": help.RenderImport,
		"GenIntSlice": func(from, to int) []int {
			var result []int
			for i := from; i <= to; i++ {
				result = append(result, i)
			}
			return result
		},
		"Add": func(a, b int) int {
			return a + b
		},
	}
}

var (
	//go:embed visitor_generator.go.tmpl
	visitorTmpl string
)

func NewVisitorGenerator(union *shape.UnionLike, helper *Helpers) *VisitorGenerator {
	return &VisitorGenerator{
		Union:    *union,
		template: template.Must(template.New("visitor_generator.go.tmpl").Funcs(helper.Func()).Parse(visitorTmpl)),
	}
}

type VisitorGenerator struct {
	Union    shape.UnionLike
	template *template.Template
}

func (g *VisitorGenerator) VariantName(x shape.Shape) string {
	return TemplateHelperShapeVariantToName(x)
}

func (g *VisitorGenerator) Generate() ([]byte, error) {
	result := &bytes.Buffer{}

	err := g.template.ExecuteTemplate(result, "visitor_generator.go.tmpl", g)

	if err != nil {
		return nil, err
	}

	return result.Bytes(), nil
}
