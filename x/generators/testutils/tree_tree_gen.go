// Code generated by mkunion. DO NOT EDIT.
package testutils

import "github.com/widmogrod/mkunion/f"
import "github.com/widmogrod/mkunion/x/shape"
import "github.com/widmogrod/mkunion/x/shared"
import "encoding/json"
import "fmt"

//mkunion-extension:visitor

type TreeVisitor interface {
	VisitBranch(v *Branch) any
	VisitLeaf(v *Leaf) any
	VisitK(v *K) any
	VisitP(v *P) any
}

type Tree interface {
	AcceptTree(g TreeVisitor) any
}

func (r *Branch) AcceptTree(v TreeVisitor) any { return v.VisitBranch(r) }
func (r *Leaf) AcceptTree(v TreeVisitor) any   { return v.VisitLeaf(r) }
func (r *K) AcceptTree(v TreeVisitor) any      { return v.VisitK(r) }
func (r *P) AcceptTree(v TreeVisitor) any      { return v.VisitP(r) }

var (
	_ Tree = (*Branch)(nil)
	_ Tree = (*Leaf)(nil)
	_ Tree = (*K)(nil)
	_ Tree = (*P)(nil)
)

func MatchTree[TOut any](
	x Tree,
	f1 func(x *Branch) TOut,
	f2 func(x *Leaf) TOut,
	f3 func(x *K) TOut,
	f4 func(x *P) TOut,
	df func(x Tree) TOut,
) TOut {
	return f.Match4(x, f1, f2, f3, f4, df)
}

func MatchTreeR2[TOut1, TOut2 any](
	x Tree,
	f1 func(x *Branch) (TOut1, TOut2),
	f2 func(x *Leaf) (TOut1, TOut2),
	f3 func(x *K) (TOut1, TOut2),
	f4 func(x *P) (TOut1, TOut2),
	df func(x Tree) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.Match4R2(x, f1, f2, f3, f4, df)
}

func MustMatchTree[TOut any](
	x Tree,
	f1 func(x *Branch) TOut,
	f2 func(x *Leaf) TOut,
	f3 func(x *K) TOut,
	f4 func(x *P) TOut,
) TOut {
	return f.MustMatch4(x, f1, f2, f3, f4)
}

func MustMatchTreeR0(
	x Tree,
	f1 func(x *Branch),
	f2 func(x *Leaf),
	f3 func(x *K),
	f4 func(x *P),
) {
	f.MustMatch4R0(x, f1, f2, f3, f4)
}

func MustMatchTreeR2[TOut1, TOut2 any](
	x Tree,
	f1 func(x *Branch) (TOut1, TOut2),
	f2 func(x *Leaf) (TOut1, TOut2),
	f3 func(x *K) (TOut1, TOut2),
	f4 func(x *P) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.MustMatch4R2(x, f1, f2, f3, f4)
}

// mkunion-extension:shape
func TreeShape() shape.Shape {
	return &shape.UnionLike{
		Name:          "Tree",
		PkgName:       "testutils",
		PkgImportName: "github.com/widmogrod/mkunion/x/generators/testutils",
		Variant: []shape.Shape{
			BranchShape(),
			LeafShape(),
			KShape(),
			PShape(),
		},
	}
}

func BranchShape() shape.Shape {
	return &shape.StructLike{
		Name:          "Branch",
		PkgName:       "testutils",
		PkgImportName: "github.com/widmogrod/mkunion/x/generators/testutils",
		Fields: []*shape.FieldLike{
			{
				Name: "Lit",
				Type: &shape.RefName{
					Name:          "Tree",
					PkgName:       "testutils",
					PkgImportName: "github.com/widmogrod/mkunion/x/generators/testutils",
					IsPointer:     false,
				},
			},
			{
				Name: "List",
				Type: &shape.ListLike{
					Element: &shape.RefName{
						Name:          "Tree",
						PkgName:       "testutils",
						PkgImportName: "github.com/widmogrod/mkunion/x/generators/testutils",
						IsPointer:     false,
					},
					ElementIsPointer: false,
				},
			},
			{
				Name: "Map",
				Type: &shape.MapLike{
					Key:          &shape.StringLike{},
					KeyIsPointer: false,
					Val: &shape.RefName{
						Name:          "Tree",
						PkgName:       "testutils",
						PkgImportName: "github.com/widmogrod/mkunion/x/generators/testutils",
						IsPointer:     false,
					},
					ValIsPointer: false,
				},
			},
		},
	}
}

func LeafShape() shape.Shape {
	return &shape.StructLike{
		Name:          "Leaf",
		PkgName:       "testutils",
		PkgImportName: "github.com/widmogrod/mkunion/x/generators/testutils",
		Fields: []*shape.FieldLike{
			{
				Name: "Value",
				Type: &shape.NumberLike{
					Kind: &shape.Int64{},
				},
			},
		},
	}
}

func KShape() shape.Shape {
	return &shape.AliasLike{
		Name:          "K",
		PkgName:       "testutils",
		PkgImportName: "github.com/widmogrod/mkunion/x/generators/testutils",
		IsAlias:       false,
		Type:          &shape.StringLike{},
	}
}

func PShape() shape.Shape {
	return &shape.AliasLike{
		Name:          "P",
		PkgName:       "testutils",
		PkgImportName: "github.com/widmogrod/mkunion/x/generators/testutils",
		IsAlias:       false,
		Type: &shape.RefName{
			Name:          "ListOf2",
			PkgName:       "testutils",
			PkgImportName: "github.com/widmogrod/mkunion/x/generators/testutils",
			IsPointer:     false,
			Indexed: []shape.Shape{
				&shape.RefName{
					Name:          "ListOf",
					PkgName:       "testutils",
					PkgImportName: "github.com/widmogrod/mkunion/x/generators/testutils",
					IsPointer:     false,
					Indexed: []shape.Shape{
						&shape.Any{},
					},
				},
				&shape.RefName{
					Name:          "ListOf2",
					PkgName:       "testutils",
					PkgImportName: "github.com/widmogrod/mkunion/x/generators/testutils",
					IsPointer:     true,
					Indexed: []shape.Shape{
						&shape.NumberLike{
							Kind: &shape.Int64{},
						},
						&shape.RefName{
							Name:          "Duration",
							PkgName:       "time",
							PkgImportName: "time",
							IsPointer:     true,
						},
					},
				},
			},
		},
	}
}

// mkunion-extension:json
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/generators/testutils.Tree", TreeFromJSON, TreeToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/generators/testutils.Branch", BranchFromJSON, BranchToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/generators/testutils.Leaf", LeafFromJSON, LeafToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/generators/testutils.K", KFromJSON, KToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/generators/testutils.P", PFromJSON, PToJSON)
}

type TreeUnionJSON struct {
	Type   string          `json:"$type,omitempty"`
	Branch json.RawMessage `json:"testutils.Branch,omitempty"`
	Leaf   json.RawMessage `json:"testutils.Leaf,omitempty"`
	K      json.RawMessage `json:"testutils.K,omitempty"`
	P      json.RawMessage `json:"testutils.P,omitempty"`
}

func TreeFromJSON(x []byte) (Tree, error) {
	var data TreeUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, err
	}

	switch data.Type {
	case "testutils.Branch":
		return BranchFromJSON(data.Branch)
	case "testutils.Leaf":
		return LeafFromJSON(data.Leaf)
	case "testutils.K":
		return KFromJSON(data.K)
	case "testutils.P":
		return PFromJSON(data.P)
	}

	if data.Branch != nil {
		return BranchFromJSON(data.Branch)
	} else if data.Leaf != nil {
		return LeafFromJSON(data.Leaf)
	} else if data.K != nil {
		return KFromJSON(data.K)
	} else if data.P != nil {
		return PFromJSON(data.P)
	}

	return nil, fmt.Errorf("testutils.Tree: unknown type %s", data.Type)
}

func TreeToJSON(x Tree) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return MustMatchTreeR2(
		x,
		func(x *Branch) ([]byte, error) {
			body, err := BranchToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(TreeUnionJSON{
				Type:   "testutils.Branch",
				Branch: body,
			})
		},
		func(x *Leaf) ([]byte, error) {
			body, err := LeafToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(TreeUnionJSON{
				Type: "testutils.Leaf",
				Leaf: body,
			})
		},
		func(x *K) ([]byte, error) {
			body, err := KToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(TreeUnionJSON{
				Type: "testutils.K",
				K:    body,
			})
		},
		func(x *P) ([]byte, error) {
			body, err := PToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(TreeUnionJSON{
				Type: "testutils.P",
				P:    body,
			})
		},
	)
}

func BranchFromJSON(x []byte) (*Branch, error) {
	var result *Branch = new(Branch)
	// if is Struct
	err := shared.JSONParseObject(x, func(key string, value []byte) error {
		switch key {
		case "Lit":
			res, err := TreeFromJSON(value)
			if err != nil {
				return fmt.Errorf("testutils._FromJSON: field Tree %w", err)
			}
			result.Lit = res
			return nil
		case "List":
			res, err := shared.JSONToListWithDeserializer(value, result.List, TreeFromJSON)
			if err != nil {
				return fmt.Errorf("testutils._FromJSON: field Tree %w", err)
			}
			result.List = res
			return nil
		case "Map":
			res, err := shared.JSONToMapWithDeserializer(value, result.Map, TreeFromJSON)
			if err != nil {
				return fmt.Errorf("testutils._FromJSON: field Tree %w", err)
			}
			result.Map = res
			return nil
		}

		return fmt.Errorf("testutils.BranchFromJSON: unknown key %s", key)
	})

	return result, err
}

func BranchToJSON(x *Branch) ([]byte, error) {
	field_Lit, err := TreeToJSON(x.Lit)
	if err != nil {
		return nil, err
	}
	field_List, err := shared.JSONListFromSerializer(x.List, TreeToJSON)
	if err != nil {
		return nil, err
	}
	field_Map, err := shared.JSONMapFromSerializer(x.Map, TreeToJSON)
	if err != nil {
		return nil, err
	}
	return json.Marshal(map[string]json.RawMessage{
		"Lit":  field_Lit,
		"List": field_List,
		"Map":  field_Map,
	})
}
func (self *Branch) MarshalJSON() ([]byte, error) {
	return BranchToJSON(self)
}

func (self *Branch) UnmarshalJSON(x []byte) error {
	n, err := BranchFromJSON(x)
	if err != nil {
		return err
	}
	*self = *n
	return nil
}

func LeafFromJSON(x []byte) (*Leaf, error) {
	var result *Leaf = new(Leaf)
	// if is Struct
	err := shared.JSONParseObject(x, func(key string, value []byte) error {
		switch key {
		case "Value":
			return json.Unmarshal(value, &result.Value)
		}

		return fmt.Errorf("testutils.LeafFromJSON: unknown key %s", key)
	})

	return result, err
}

func LeafToJSON(x *Leaf) ([]byte, error) {
	field_Value, err := json.Marshal(x.Value)
	if err != nil {
		return nil, err
	}
	return json.Marshal(map[string]json.RawMessage{
		"Value": field_Value,
	})
}
func (self *Leaf) MarshalJSON() ([]byte, error) {
	return LeafToJSON(self)
}

func (self *Leaf) UnmarshalJSON(x []byte) error {
	n, err := LeafFromJSON(x)
	if err != nil {
		return err
	}
	*self = *n
	return nil
}

func KFromJSON(x []byte) (*K, error) {
	var result *K = new(K)
	err := json.Unmarshal(x, result)

	return result, err
}

func KToJSON(x *K) ([]byte, error) {
	return json.Marshal(x)
}

func PFromJSON(x []byte) (*P, error) {
	var result *P = new(P)
	err := json.Unmarshal(x, result)

	return result, err
}

func PToJSON(x *P) ([]byte, error) {
	return json.Marshal(x)
}
