// Code generated by mkunion. DO NOT EDIT.
package testutils

import "github.com/widmogrod/mkunion/f"
import "github.com/widmogrod/mkunion/x/schema"
import "github.com/widmogrod/mkunion/x/shape"
import "github.com/widmogrod/mkunion/x/shared"
import "encoding/json"
import "fmt"

//mkunion-extension:visitor

type Tree2Visitor interface {
	VisitBranch2(v *Branch2) any
	VisitLeaf2(v *Leaf2) any
}

type Tree2 interface {
	AcceptTree2(g Tree2Visitor) any
}

func (r *Branch2) AcceptTree2(v Tree2Visitor) any { return v.VisitBranch2(r) }
func (r *Leaf2) AcceptTree2(v Tree2Visitor) any   { return v.VisitLeaf2(r) }

var (
	_ Tree2 = (*Branch2)(nil)
	_ Tree2 = (*Leaf2)(nil)
)

func MatchTree2[TOut any](
	x Tree2,
	f1 func(x *Branch2) TOut,
	f2 func(x *Leaf2) TOut,
	df func(x Tree2) TOut,
) TOut {
	return f.Match2(x, f1, f2, df)
}

func MatchTree2R2[TOut1, TOut2 any](
	x Tree2,
	f1 func(x *Branch2) (TOut1, TOut2),
	f2 func(x *Leaf2) (TOut1, TOut2),
	df func(x Tree2) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.Match2R2(x, f1, f2, df)
}

func MustMatchTree2[TOut any](
	x Tree2,
	f1 func(x *Branch2) TOut,
	f2 func(x *Leaf2) TOut,
) TOut {
	return f.MustMatch2(x, f1, f2)
}

func MustMatchTree2R0(
	x Tree2,
	f1 func(x *Branch2),
	f2 func(x *Leaf2),
) {
	f.MustMatch2R0(x, f1, f2)
}

func MustMatchTree2R2[TOut1, TOut2 any](
	x Tree2,
	f1 func(x *Branch2) (TOut1, TOut2),
	f2 func(x *Leaf2) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.MustMatch2R2(x, f1, f2)
}

// mkunion-extension:schema
func init() {
	schema.RegisterUnionTypes(Tree2SchemaDef())
}

func Tree2SchemaDef() *schema.UnionVariants[Tree2] {
	return schema.MustDefineUnion[Tree2](
		&Branch2{},
		&Leaf2{},
	)
}

// mkunion-extension:shape
func Tree2Shape() shape.Shape {
	return &shape.UnionLike{
		Name:          "Tree2",
		PkgName:       "testutils",
		PkgImportName: "github.com/widmogrod/mkunion/x/generators/testutils",
		Variant: []shape.Shape{
			Branch2Shape(),
			Leaf2Shape(),
		},
	}
}

func Branch2Shape() shape.Shape {
	return &shape.StructLike{
		Name:          "Branch2",
		PkgName:       "testutils",
		PkgImportName: "github.com/widmogrod/mkunion/x/generators/testutils",
		Fields: []*shape.FieldLike{
			{
				Name: "Lit",
				Type: &shape.RefName{
					Name:          "Tree2",
					PkgName:       "testutils",
					PkgImportName: "github.com/widmogrod/mkunion/x/generators/testutils",
				},
			},
			{
				Name: "List",
				Type: &shape.ListLike{
					Element: &shape.RefName{
						Name:          "Tree2",
						PkgName:       "testutils",
						PkgImportName: "github.com/widmogrod/mkunion/x/generators/testutils",
					},
					ElementIsPointer: false,
				},
			},
			{
				Name: "Map",
				Type: &shape.MapLike{
					Key:          &shape.StringLike{},
					KeyIsPointer: false,
					Val: &shape.RefName{
						Name:          "Tree2",
						PkgName:       "testutils",
						PkgImportName: "github.com/widmogrod/mkunion/x/generators/testutils",
					},
					ValIsPointer: false,
				},
			},
		},
	}
}

func Leaf2Shape() shape.Shape {
	return &shape.StructLike{
		Name:          "Leaf2",
		PkgName:       "testutils",
		PkgImportName: "github.com/widmogrod/mkunion/x/generators/testutils",
		Fields: []*shape.FieldLike{
			{
				Name: "Value",
				Type: &shape.NumberLike{},
			},
		},
	}
}

// mkunion-extension:json
type Tree2UnionJSON struct {
	Type    string          `json:"$type,omitempty"`
	Branch2 json.RawMessage `json:"github.com/widmogrod/mkunion/x/generators/testutils.Branch2,omitempty"`
	Leaf2   json.RawMessage `json:"github.com/widmogrod/mkunion/x/generators/testutils.Leaf2,omitempty"`
}

func Tree2FromJSON(x []byte) (Tree2, error) {
	var data Tree2UnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, err
	}

	switch data.Type {
	case "github.com/widmogrod/mkunion/x/generators/testutils.Branch2":
		return Branch2FromJSON(data.Branch2)
	case "github.com/widmogrod/mkunion/x/generators/testutils.Leaf2":
		return Leaf2FromJSON(data.Leaf2)
	}

	if data.Branch2 != nil {
		return Branch2FromJSON(data.Branch2)
	} else if data.Leaf2 != nil {
		return Leaf2FromJSON(data.Leaf2)
	}

	return nil, fmt.Errorf("unknown type %s", data.Type)
}

func Tree2ToJSON(x Tree2) ([]byte, error) {
	return MustMatchTree2R2(
		x,
		func(x *Branch2) ([]byte, error) {
			body, err := Branch2ToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(Tree2UnionJSON{
				Type:    "github.com/widmogrod/mkunion/x/generators/testutils.Branch2",
				Branch2: body,
			})
		},
		func(x *Leaf2) ([]byte, error) {
			body, err := Leaf2ToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(Tree2UnionJSON{
				Type:  "github.com/widmogrod/mkunion/x/generators/testutils.Leaf2",
				Leaf2: body,
			})
		},
	)
}

func Branch2FromJSON(x []byte) (*Branch2, error) {
	var result *Branch2 = &Branch2{}

	// if is Struct
	err := shared.JsonParseObject(x, func(key string, value []byte) error {
		switch key {
		case "Lit":
			res, err := Tree2FromJSON(value)
			if err != nil {
				return fmt.Errorf("testutils.Tree2FromJSON: %w", err)
			}
			result.Lit = res
			return nil
		case "List":
			return json.Unmarshal(value, &result.List)
		case "Map":
			return json.Unmarshal(value, &result.Map)
		}

		return fmt.Errorf("testutils.Branch2FromJSON: unknown key %s", key)
	})

	return result, err
}

func Branch2ToJSON(x *Branch2) ([]byte, error) {
	field_Lit, err := Tree2ToJSON(x.Lit)
	if err != nil {
		return nil, err
	}
	field_List, err := json.Marshal(x.List)
	if err != nil {
		return nil, err
	}
	field_Map, err := json.Marshal(x.Map)
	if err != nil {
		return nil, err
	}
	return json.Marshal(map[string]json.RawMessage{
		"Lit":  field_Lit,
		"List": field_List,
		"Map":  field_Map,
	})
}

func (self *Branch2) MarshalJSON() ([]byte, error) {
	return Branch2ToJSON(self)
}

func (self *Branch2) UnmarshalJSON(x []byte) error {
	n, err := Branch2FromJSON(x)
	if err != nil {
		return err
	}
	*self = *n
	return nil
}

func Leaf2FromJSON(x []byte) (*Leaf2, error) {
	var result *Leaf2 = &Leaf2{}

	// if is Struct
	err := shared.JsonParseObject(x, func(key string, value []byte) error {
		switch key {
		case "Value":
			return json.Unmarshal(value, &result.Value)
		}

		return fmt.Errorf("testutils.Leaf2FromJSON: unknown key %s", key)
	})

	return result, err
}

func Leaf2ToJSON(x *Leaf2) ([]byte, error) {
	field_Value, err := json.Marshal(x.Value)
	if err != nil {
		return nil, err
	}
	return json.Marshal(map[string]json.RawMessage{
		"Value": field_Value,
	})
}

func (self *Leaf2) MarshalJSON() ([]byte, error) {
	return Leaf2ToJSON(self)
}

func (self *Leaf2) UnmarshalJSON(x []byte) error {
	n, err := Leaf2FromJSON(x)
	if err != nil {
		return err
	}
	*self = *n
	return nil
}
