// Code generated by mkunion. DO NOT EDIT.
package testutils

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/f"
	"github.com/widmogrod/mkunion/x/shape"
	"github.com/widmogrod/mkunion/x/shared"
)

func init() {
	shape.Register(NumberShape())
	shape.Register(N0Shape())
	shape.Register(N1Shape())
}

//mkunion-extension:visitor

type NumberVisitor interface {
	VisitN0(v *N0) any
	VisitN1(v *N1) any
}

type Number interface {
	AcceptNumber(g NumberVisitor) any
}

func (r *N0) AcceptNumber(v NumberVisitor) any { return v.VisitN0(r) }
func (r *N1) AcceptNumber(v NumberVisitor) any { return v.VisitN1(r) }

var (
	_ Number = (*N0)(nil)
	_ Number = (*N1)(nil)
)

func MatchNumber[TOut any](
	x Number,
	f1 func(x *N0) TOut,
	f2 func(x *N1) TOut,
	df func(x Number) TOut,
) TOut {
	return f.Match2(x, f1, f2, df)
}

func MatchNumberR2[TOut1, TOut2 any](
	x Number,
	f1 func(x *N0) (TOut1, TOut2),
	f2 func(x *N1) (TOut1, TOut2),
	df func(x Number) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.Match2R2(x, f1, f2, df)
}

func MustMatchNumber[TOut any](
	x Number,
	f1 func(x *N0) TOut,
	f2 func(x *N1) TOut,
) TOut {
	return f.MustMatch2(x, f1, f2)
}

func MustMatchNumberR0(
	x Number,
	f1 func(x *N0),
	f2 func(x *N1),
) {
	f.MustMatch2R0(x, f1, f2)
}

func MustMatchNumberR2[TOut1, TOut2 any](
	x Number,
	f1 func(x *N0) (TOut1, TOut2),
	f2 func(x *N1) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.MustMatch2R2(x, f1, f2)
}

//mkunion-extension:shape

func NumberShape() shape.Shape {
	return &shape.UnionLike{
		Name:          "Number",
		PkgName:       "testutils",
		PkgImportName: "github.com/widmogrod/mkunion/x/generators/testutils",
		Variant: []shape.Shape{
			N0Shape(),
			N1Shape(),
		},
	}
}

func N0Shape() shape.Shape {
	return &shape.StructLike{
		Name:          "N0",
		PkgName:       "testutils",
		PkgImportName: "github.com/widmogrod/mkunion/x/generators/testutils",
	}
}

func N1Shape() shape.Shape {
	return &shape.StructLike{
		Name:          "N1",
		PkgName:       "testutils",
		PkgImportName: "github.com/widmogrod/mkunion/x/generators/testutils",
	}
}

// mkunion-extension:json
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/generators/testutils.Number", NumberFromJSON, NumberToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/generators/testutils.N0", N0FromJSON, N0ToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/generators/testutils.N1", N1FromJSON, N1ToJSON)
}

type NumberUnionJSON struct {
	Type string          `json:"$type,omitempty"`
	N0   json.RawMessage `json:"testutils.N0,omitempty"`
	N1   json.RawMessage `json:"testutils.N1,omitempty"`
}

func NumberFromJSON(x []byte) (Number, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}

	var data NumberUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, err
	}

	switch data.Type {
	case "testutils.N0":
		return N0FromJSON(data.N0)
	case "testutils.N1":
		return N1FromJSON(data.N1)
	}

	if data.N0 != nil {
		return N0FromJSON(data.N0)
	} else if data.N1 != nil {
		return N1FromJSON(data.N1)
	}

	return nil, fmt.Errorf("testutils.Number: unknown type %s", data.Type)
}

func NumberToJSON(x Number) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return MustMatchNumberR2(
		x,
		func(x *N0) ([]byte, error) {
			body, err := N0ToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(NumberUnionJSON{
				Type: "testutils.N0",
				N0:   body,
			})
		},
		func(x *N1) ([]byte, error) {
			body, err := N1ToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(NumberUnionJSON{
				Type: "testutils.N1",
				N1:   body,
			})
		},
	)
}

func N0FromJSON(x []byte) (*N0, error) {
	result := new(N0)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func N0ToJSON(x *N0) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*N0)(nil)
	_ json.Marshaler   = (*N0)(nil)
)

func (r *N0) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONN0(*r)
}
func (r *N0) _marshalJSONN0(x N0) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("testutils: N0._marshalJSONN0: struct; %w", err)
	}
	return result, nil
}
func (r *N0) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONN0(data)
	if err != nil {
		return fmt.Errorf("testutils: N0.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *N0) _unmarshalJSONN0(data []byte) (N0, error) {
	result := N0{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("testutils: N0._unmarshalJSONN0: native struct unwrap; %w", err)
	}
	return result, nil
}

func N1FromJSON(x []byte) (*N1, error) {
	result := new(N1)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func N1ToJSON(x *N1) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*N1)(nil)
	_ json.Marshaler   = (*N1)(nil)
)

func (r *N1) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONN1(*r)
}
func (r *N1) _marshalJSONN1(x N1) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("testutils: N1._marshalJSONN1: struct; %w", err)
	}
	return result, nil
}
func (r *N1) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONN1(data)
	if err != nil {
		return fmt.Errorf("testutils: N1.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *N1) _unmarshalJSONN1(data []byte) (N1, error) {
	result := N1{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("testutils: N1._unmarshalJSONN1: native struct unwrap; %w", err)
	}
	return result, nil
}
