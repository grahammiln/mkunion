// Code generated by mkunion. DO NOT EDIT.
package testutils

import "github.com/widmogrod/mkunion/x/shared"

import "encoding/json"

import "fmt"

type TreeUnionJSON struct {
	Type string `json:"$type,omitempty"`
	Branch json.RawMessage `json:"github.com/widmogrod/mkunion/x/generators/testutils.Branch,omitempty"`
	Leaf json.RawMessage `json:"github.com/widmogrod/mkunion/x/generators/testutils.Leaf,omitempty"`
	K json.RawMessage `json:"github.com/widmogrod/mkunion/x/generators/testutils.K,omitempty"`
}

func TreeFromJSON(x []byte) (Tree, error) {
	var data TreeUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, err
	}

	switch data.Type {
	case "github.com/widmogrod/mkunion/x/generators/testutils.Branch":
		return BranchFromJSON(data.Branch)
	case "github.com/widmogrod/mkunion/x/generators/testutils.Leaf":
		return LeafFromJSON(data.Leaf)
	case "github.com/widmogrod/mkunion/x/generators/testutils.K":
		return KFromJSON(data.K)
	}

	if data.Branch != nil {
		return BranchFromJSON(data.Branch)
	} else if data.Leaf != nil {
		return LeafFromJSON(data.Leaf)
	} else if data.K != nil {
		return KFromJSON(data.K)
	}

	return nil, fmt.Errorf("unknown type %s", data.Type)
}

func TreeToJSON(x Tree) ([]byte, error) {
	return MustMatchTreeR2(
		x,
		func(x *Branch) ([]byte, error) {
			body, err := BranchToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(TreeUnionJSON{
				Type: "github.com/widmogrod/mkunion/x/generators/testutils.Branch",
				Branch: body,
			})
		},
		func(x *Leaf) ([]byte, error) {
			body, err := LeafToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(TreeUnionJSON{
				Type: "github.com/widmogrod/mkunion/x/generators/testutils.Leaf",
				Leaf: body,
			})
		},
		func(x *K) ([]byte, error) {
			body, err := KToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(TreeUnionJSON{
				Type: "github.com/widmogrod/mkunion/x/generators/testutils.K",
				K: body,
			})
		},
	)
}

func BranchFromJSON(x []byte) (*Branch, error) {
	var result *Branch = new(Branch)
	// if is Struct
	err := shared.JsonParseObject(x, func(key string, value []byte) error {
		switch key {
		case "Lit":
			res, err := TreeFromJSON(value)
			if err != nil {
				return fmt.Errorf("testutils.TreeFromJSON: %w", err)
			}
			result.Lit = res
			return nil
		case "List":
			return json.Unmarshal(value, &result.List)
		case "Map":
			return json.Unmarshal(value, &result.Map)
		}

		return fmt.Errorf("testutils.BranchFromJSON: unknown key %s", key)
	})

	return result, err
}

func BranchToJSON(x *Branch) ([]byte, error) {
	field_Lit, err := TreeToJSON(x.Lit)
	if err != nil {
		return nil, err
	}
	field_List, err := json.Marshal(x.List)
	if err != nil {
		return nil, err
	}
	field_Map, err := json.Marshal(x.Map)
	if err != nil {
		return nil, err
	}
	return json.Marshal(map[string]json.RawMessage{
		"Lit": field_Lit,
		"List": field_List,
		"Map": field_Map,
	})
}

func (self *Branch) MarshalJSON() ([]byte, error) {
	return BranchToJSON(self)
}

func (self *Branch) UnmarshalJSON(x []byte) error {
	n, err := BranchFromJSON(x)
	if err != nil {
		return err
	}
	*self = *n
	return nil
}

func LeafFromJSON(x []byte) (*Leaf, error) {
	var result *Leaf = new(Leaf)
	// if is Struct
	err := shared.JsonParseObject(x, func(key string, value []byte) error {
		switch key {
		case "Value":
			return json.Unmarshal(value, &result.Value)
		}

		return fmt.Errorf("testutils.LeafFromJSON: unknown key %s", key)
	})

	return result, err
}

func LeafToJSON(x *Leaf) ([]byte, error) {
	field_Value, err := json.Marshal(x.Value)
	if err != nil {
		return nil, err
	}
	return json.Marshal(map[string]json.RawMessage{
		"Value": field_Value,
	})
}

func (self *Leaf) MarshalJSON() ([]byte, error) {
	return LeafToJSON(self)
}

func (self *Leaf) UnmarshalJSON(x []byte) error {
	n, err := LeafFromJSON(x)
	if err != nil {
		return err
	}
	*self = *n
	return nil
}

func KFromJSON(x []byte) (*K, error) {
	var result *K = new(K)
	err := json.Unmarshal(x, result)

	return result, err
}

func KToJSON(x *K) ([]byte, error) {
	return json.Marshal(x)
}

func (self *K) MarshalJSON() ([]byte, error) {
	return KToJSON(self)
}

func (self *K) UnmarshalJSON(x []byte) error {
	n, err := KFromJSON(x)
	if err != nil {
		return err
	}
	*self = *n
	return nil
}
