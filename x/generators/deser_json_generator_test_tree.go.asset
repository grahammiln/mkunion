package testutils

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/x/shared"
	"time"
)

func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/generators/testutils.Tree", TreeFromJSON, TreeToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/generators/testutils.Branch", BranchFromJSON, BranchToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/generators/testutils.Leaf", LeafFromJSON, LeafToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/generators/testutils.K", KFromJSON, KToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/generators/testutils.P", PFromJSON, PToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/generators/testutils.Ma", MaFromJSON, MaToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/generators/testutils.La", LaFromJSON, LaToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/generators/testutils.Ka", KaFromJSON, KaToJSON)
}

type TreeUnionJSON struct {
	Type string `json:"$type,omitempty"`
	Branch json.RawMessage `json:"testutils.Branch,omitempty"`
	Leaf json.RawMessage `json:"testutils.Leaf,omitempty"`
	K json.RawMessage `json:"testutils.K,omitempty"`
	P json.RawMessage `json:"testutils.P,omitempty"`
	Ma json.RawMessage `json:"testutils.Ma,omitempty"`
	La json.RawMessage `json:"testutils.La,omitempty"`
	Ka json.RawMessage `json:"testutils.Ka,omitempty"`
}

func TreeFromJSON(x []byte) (Tree, error) {
	var data TreeUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, err
	}

	switch data.Type {
	case "testutils.Branch":
		return BranchFromJSON(data.Branch)
	case "testutils.Leaf":
		return LeafFromJSON(data.Leaf)
	case "testutils.K":
		return KFromJSON(data.K)
	case "testutils.P":
		return PFromJSON(data.P)
	case "testutils.Ma":
		return MaFromJSON(data.Ma)
	case "testutils.La":
		return LaFromJSON(data.La)
	case "testutils.Ka":
		return KaFromJSON(data.Ka)
	}

	if data.Branch != nil {
		return BranchFromJSON(data.Branch)
	} else if data.Leaf != nil {
		return LeafFromJSON(data.Leaf)
	} else if data.K != nil {
		return KFromJSON(data.K)
	} else if data.P != nil {
		return PFromJSON(data.P)
	} else if data.Ma != nil {
		return MaFromJSON(data.Ma)
	} else if data.La != nil {
		return LaFromJSON(data.La)
	} else if data.Ka != nil {
		return KaFromJSON(data.Ka)
	}

	return nil, fmt.Errorf("testutils.Tree: unknown type %s", data.Type)
}

func TreeToJSON(x Tree) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return MustMatchTreeR2(
		x,
		func(x *Branch) ([]byte, error) {
			body, err := BranchToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(TreeUnionJSON{
				Type: "testutils.Branch",
				Branch: body,
			})
		},
		func(x *Leaf) ([]byte, error) {
			body, err := LeafToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(TreeUnionJSON{
				Type: "testutils.Leaf",
				Leaf: body,
			})
		},
		func(x *K) ([]byte, error) {
			body, err := KToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(TreeUnionJSON{
				Type: "testutils.K",
				K: body,
			})
		},
		func(x *P) ([]byte, error) {
			body, err := PToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(TreeUnionJSON{
				Type: "testutils.P",
				P: body,
			})
		},
		func(x *Ma) ([]byte, error) {
			body, err := MaToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(TreeUnionJSON{
				Type: "testutils.Ma",
				Ma: body,
			})
		},
		func(x *La) ([]byte, error) {
			body, err := LaToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(TreeUnionJSON{
				Type: "testutils.La",
				La: body,
			})
		},
		func(x *Ka) ([]byte, error) {
			body, err := KaToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(TreeUnionJSON{
				Type: "testutils.Ka",
				Ka: body,
			})
		},
	)
}

func BranchFromJSON(x []byte) (*Branch, error) {
	result := new(Branch)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func BranchToJSON(x *Branch) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Branch)(nil)
	_ json.Marshaler   = (*Branch)(nil)
)

func (r *Branch) MarshalJSON() ([]byte, error) {
	var err error
	result := make(map[string]json.RawMessage)

	fieldLit, err := shared.JSONMarshal[Tree](r.Lit)
	if err != nil {
		return nil, fmt.Errorf("testutils.Branch.MarshalJSON: field Lit; %w", err)
	}
	result["Lit"] = fieldLit

	fieldList := make([]json.RawMessage, len(r.List))
	for i, v := range r.List {
		fieldList[i], err = shared.JSONMarshal[Tree](v)
		if err != nil {
			return nil, fmt.Errorf("testutils.Branch.MarshalJSON: field List[%d]; %w", i, err)
		}
	}
	result["List"], err = json.Marshal(fieldList)
	if err != nil {
		return nil, fmt.Errorf("testutils.Branch.MarshalJSON: field List; %w", err)
	}

	fieldMap := make(map[string]json.RawMessage)
	for k, v := range r.Map {
		key, value, err := shared.JSONMarshalMap[string, Tree](k, v)
		if err != nil {
			return nil, fmt.Errorf("testutils.Branch.MarshalJSON:; %w", err)
		}
		fieldMap[key] = value
	}
	result["Map"], err = json.Marshal(fieldMap)
	if err != nil {
		return nil, fmt.Errorf("testutils.Branch.MarshalJSON: field Map; %w", err)
	}

	if r.Of != nil {
		fieldOf, err := shared.JSONMarshal[*ListOf[Tree]](r.Of)
		if err != nil {
			return nil, fmt.Errorf("testutils.Branch.MarshalJSON: field Of; %w", err)
		}
		result["just_of"] = fieldOf
	}

	output, err := json.Marshal(result)
	if err != nil {
		return nil, fmt.Errorf("testutils.Branch.MarshalJSON: final step; %w", err)
	}

	return output, nil
}

func (r *Branch) UnmarshalJSON(bytes []byte) error {
	return shared.JSONParseObject(bytes, func(key string, bytes []byte) error {
		switch key {
		case "Lit":
			var err error
			r.Lit, err = shared.JSONUnmarshal[Tree](bytes)
			if err != nil {
				return fmt.Errorf("testutils.Branch.UnmarshalJSON: field Lit; %w", err)
			}
			return nil

		case "List":
			err := shared.JSONParseList(bytes, func(index int, bytes []byte) error {
				item, err := shared.JSONUnmarshal[Tree](bytes)
				if err != nil {
					return fmt.Errorf("testutils.Branch.UnmarshalJSON: field List[%d]; %w", index, err)
				}
				r.List = append(r.List, item)
				return nil
			})
			if err != nil {
				return fmt.Errorf("testutils.Branch.UnmarshalJSON: field List; %w", err)
			}
			return nil

		case "Map":
			r.Map = make(map[string]Tree)
			err := shared.JSONParseObject(bytes, func(rawKey string, bytes []byte) error {
				item, err := shared.JSONUnmarshal[Tree](bytes)
				if err != nil {
					return fmt.Errorf("key=%s to type=%T item error;  %w", bytes, item, err)
				}

				var key2 string
				if _, ok := any(key2).(string); !ok {
					var err error
					key2, err = shared.JSONUnmarshal[string]([]byte(rawKey))
					if err != nil {
						return fmt.Errorf("key=%s to type=%T key error; %w", rawKey, key2, err)
					}
				} else {
					key2 = any(rawKey).(string)
				}

				r.Map[key2] = item
				return nil
			})
			if err != nil {
				return fmt.Errorf("testutils.Branch.UnmarshalJSON: field Map; %w", err)
			}
			return nil

		case "just_of":
			var err error
			r.Of, err = shared.JSONUnmarshal[*ListOf[Tree]](bytes)
			if err != nil {
				return fmt.Errorf("testutils.Branch.UnmarshalJSON: field Of; %w", err)
			}
			return nil

		}

		return nil
	})
}



func LeafFromJSON(x []byte) (*Leaf, error) {
	result := new(Leaf)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func LeafToJSON(x *Leaf) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Leaf)(nil)
	_ json.Marshaler   = (*Leaf)(nil)
)

func (r *Leaf) MarshalJSON() ([]byte, error) {
	var err error
	result := make(map[string]json.RawMessage)

	fieldValue, err := shared.JSONMarshal[int64](r.Value)
	if err != nil {
		return nil, fmt.Errorf("testutils.Leaf.MarshalJSON: field Value; %w", err)
	}
	result["Value"] = fieldValue

	output, err := json.Marshal(result)
	if err != nil {
		return nil, fmt.Errorf("testutils.Leaf.MarshalJSON: final step; %w", err)
	}

	return output, nil
}

func (r *Leaf) UnmarshalJSON(bytes []byte) error {
	return shared.JSONParseObject(bytes, func(key string, bytes []byte) error {
		switch key {
		case "Value":
			var err error
			r.Value, err = shared.JSONUnmarshal[int64](bytes)
			if err != nil {
				return fmt.Errorf("testutils.Leaf.UnmarshalJSON: field Value; %w", err)
			}
			return nil

		}

		return nil
	})
}



func KFromJSON(x []byte) (*K, error) {
	result := new(K)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func KToJSON(x *K) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*K)(nil)
	_ json.Marshaler   = (*K)(nil)
)

func (r *K) MarshalJSON() ([]byte, error) {
	result, err := shared.JSONMarshal[string](*r)
	if err != nil {
		return nil, fmt.Errorf("testutils.K.MarshalJSON: %w", err)
	}
	return result, nil
}

func (r *K) UnmarshalJSON(bytes []byte) error {
	result, err := shared.JSONUnmarshal[string](bytes)
	if err != nil {
		return fmt.Errorf("testutils.K.UnmarshalJSON: %w", err)
	}
	*r = K(result)
	return nil
}



func PFromJSON(x []byte) (*P, error) {
	result := new(P)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func PToJSON(x *P) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*P)(nil)
	_ json.Marshaler   = (*P)(nil)
)

func (r *P) MarshalJSON() ([]byte, error) {
	result, err := shared.JSONMarshal[ListOf2[ListOf[any],*ListOf2[int64,*time.Duration]]](*r)
	if err != nil {
		return nil, fmt.Errorf("testutils.P.MarshalJSON: %w", err)
	}
	return result, nil
}

func (r *P) UnmarshalJSON(bytes []byte) error {
	result, err := shared.JSONUnmarshal[ListOf2[ListOf[any],*ListOf2[int64,*time.Duration]]](bytes)
	if err != nil {
		return fmt.Errorf("testutils.P.UnmarshalJSON: %w", err)
	}
	*r = P(result)
	return nil
}



func MaFromJSON(x []byte) (*Ma, error) {
	result := new(Ma)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func MaToJSON(x *Ma) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Ma)(nil)
	_ json.Marshaler   = (*Ma)(nil)
)

func (r *Ma) MarshalJSON() ([]byte, error) {
	fieldMap := make(map[string]json.RawMessage)
	for k, v := range *r {
		key, value, err := shared.JSONMarshalMap[string, Tree](k, v)
		if err != nil {
			return nil, fmt.Errorf("testutils.Ma.MarshalJSON:; %w", err)
		}
		fieldMap[key] = value
	}
	result, err := json.Marshal(fieldMap)
	if err != nil {
		return nil, fmt.Errorf("testutils.Ma.MarshalJSON:; %w", err)
	}
	return result, nil
}

func (r *Ma) UnmarshalJSON(bytes []byte) error {
	*r = make(Ma)
	return shared.JSONParseObject(bytes, func(key string, value []byte) error {
		k, v, err := shared.JSONUnmarshalMap[string, Tree](key, value)
		if err != nil {
			return fmt.Errorf("testutils.Ma.UnmarshalJSON: key %s; %w", key, err)
		}
		(*r)[k] = v
		return nil
	})
}



func LaFromJSON(x []byte) (*La, error) {
	result := new(La)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func LaToJSON(x *La) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*La)(nil)
	_ json.Marshaler   = (*La)(nil)
)

func (r *La) MarshalJSON() ([]byte, error) {
	result, err := shared.JSONMarshal[[]Tree](*r)
	if err != nil {
		return nil, fmt.Errorf("testutils.La.MarshalJSON: %w", err)
	}
	return result, nil
}

func (r *La) UnmarshalJSON(bytes []byte) error {
	result, err := shared.JSONUnmarshal[[]Tree](bytes)
	if err != nil {
		return fmt.Errorf("testutils.La.UnmarshalJSON: %w", err)
	}
	*r = La(result)
	return nil
}



func KaFromJSON(x []byte) (*Ka, error) {
	result := new(Ka)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func KaToJSON(x *Ka) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Ka)(nil)
	_ json.Marshaler   = (*Ka)(nil)
)

func (r *Ka) MarshalJSON() ([]byte, error) {
	result, err := shared.JSONMarshal[[]map[string]Tree](*r)
	if err != nil {
		return nil, fmt.Errorf("testutils.Ka.MarshalJSON: %w", err)
	}
	return result, nil
}

func (r *Ka) UnmarshalJSON(bytes []byte) error {
	result, err := shared.JSONUnmarshal[[]map[string]Tree](bytes)
	if err != nil {
		return fmt.Errorf("testutils.Ka.UnmarshalJSON: %w", err)
	}
	*r = Ka(result)
	return nil
}


