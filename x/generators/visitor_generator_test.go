package generators

import (
	log "github.com/sirupsen/logrus"
	"github.com/stretchr/testify/assert"
	"github.com/widmogrod/mkunion/x/shape"
	"testing"
)

func TestGeneration(t *testing.T) {
	log.SetLevel(log.DebugLevel)
	inferred, err := shape.InferFromFile("testutils/tree_example_lit.go")
	assert.NoError(t, err)

	g := NewVisitorGenerator(
		inferred.RetrieveUnion("Tree2"),
		NewHelper(WithPackageName("testutils")),
	)

	result, err := g.Generate()
	assert.NoError(t, err)
	assert.Equal(t, `// Code generated by mkunion. DO NOT EDIT.
package testutils

import "github.com/widmogrod/mkunion/f"


type Tree2Visitor interface {
	VisitBranch2(v *Branch2) any
	VisitLeaf2(v *Leaf2) any
}

type Tree2 interface {
	AcceptTree2(g Tree2Visitor) any
}

func (r *Branch2) AcceptTree2(v Tree2Visitor) any { return v.VisitBranch2(r) }
func (r *Leaf2) AcceptTree2(v Tree2Visitor) any { return v.VisitLeaf2(r) }

var (
	_ Tree2 = (*Branch2)(nil)
	_ Tree2 = (*Leaf2)(nil)
)

func MatchTree2[TOut any](
	x Tree2,
	f1 func(x *Branch2) TOut,
	f2 func(x *Leaf2) TOut,
	df func(x Tree2) TOut,
) TOut {
	return f.Match2(x, f1, f2, df)
}

func MatchTree2R2[TOut1, TOut2 any](
	x Tree2,
	f1 func(x *Branch2) (TOut1, TOut2),
	f2 func(x *Leaf2) (TOut1, TOut2),
	df func(x Tree2) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.Match2R2(x, f1, f2, df)
}

func MustMatchTree2[TOut any](
	x Tree2,
	f1 func(x *Branch2) TOut,
	f2 func(x *Leaf2) TOut,
) TOut {
	return f.MustMatch2(x, f1, f2)
}

func MustMatchTree2R0(
	x Tree2,
	f1 func(x *Branch2),
	f2 func(x *Leaf2),
) {
	f.MustMatch2R0(x, f1, f2)
}

func MustMatchTree2R2[TOut1, TOut2 any](
	x Tree2,
	f1 func(x *Branch2) (TOut1, TOut2),
	f2 func(x *Leaf2) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.MustMatch2R2(x, f1, f2)
}`, string(result))
}
