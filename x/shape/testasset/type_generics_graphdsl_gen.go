// Code generated by mkunion. DO NOT EDIT.
package testasset

import "github.com/widmogrod/mkunion/f"
import "github.com/widmogrod/mkunion/x/shape"
import "github.com/widmogrod/mkunion/x/shared"
import "encoding/json"
import "fmt"

//mkunion-extension:visitor

type GraphDSLVisitor[T1 any] interface {
	VisitGraph(v *Graph[T1]) any
	VisitVertex(v *Vertex[T1]) any
	VisitEdge(v *Edge[T1]) any
}

type GraphDSL[T1 any] interface {
	AcceptGraphDSL(g GraphDSLVisitor[T1]) any
}

func (r *Graph[T1]) AcceptGraphDSL(v GraphDSLVisitor[T1]) any  { return v.VisitGraph(r) }
func (r *Vertex[T1]) AcceptGraphDSL(v GraphDSLVisitor[T1]) any { return v.VisitVertex(r) }
func (r *Edge[T1]) AcceptGraphDSL(v GraphDSLVisitor[T1]) any   { return v.VisitEdge(r) }

var (
	_ GraphDSL[any] = (*Graph[any])(nil)
	_ GraphDSL[any] = (*Vertex[any])(nil)
	_ GraphDSL[any] = (*Edge[any])(nil)
)

func MatchGraphDSL[T1, TOut any](
	x GraphDSL[T1],
	f1 func(x *Graph[T1]) TOut,
	f2 func(x *Vertex[T1]) TOut,
	f3 func(x *Edge[T1]) TOut,
	df func(x GraphDSL[T1]) TOut,
) TOut {
	return f.Match3(x, f1, f2, f3, df)
}

func MatchGraphDSLR2[T1, TOut1, TOut2 any](
	x GraphDSL[T1],
	f1 func(x *Graph[T1]) (TOut1, TOut2),
	f2 func(x *Vertex[T1]) (TOut1, TOut2),
	f3 func(x *Edge[T1]) (TOut1, TOut2),
	df func(x GraphDSL[T1]) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.Match3R2(x, f1, f2, f3, df)
}

func MustMatchGraphDSL[T1, TOut any](
	x GraphDSL[T1],
	f1 func(x *Graph[T1]) TOut,
	f2 func(x *Vertex[T1]) TOut,
	f3 func(x *Edge[T1]) TOut,
) TOut {
	return f.MustMatch3(x, f1, f2, f3)
}

func MustMatchGraphDSLR0[T1 any](
	x GraphDSL[T1],
	f1 func(x *Graph[T1]),
	f2 func(x *Vertex[T1]),
	f3 func(x *Edge[T1]),
) {
	f.MustMatch3R0(x, f1, f2, f3)
}

func MustMatchGraphDSLR2[T1, TOut1, TOut2 any](
	x GraphDSL[T1],
	f1 func(x *Graph[T1]) (TOut1, TOut2),
	f2 func(x *Vertex[T1]) (TOut1, TOut2),
	f3 func(x *Edge[T1]) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.MustMatch3R2(x, f1, f2, f3)
}

// mkunion-extension:shape
func GraphDSLShape() shape.Shape {
	return &shape.UnionLike{
		Name:          "GraphDSL",
		PkgName:       "testasset",
		PkgImportName: "github.com/widmogrod/mkunion/x/shape/testasset",
		Variant: []shape.Shape{
			GraphShape(),
			VertexShape(),
			EdgeShape(),
		},
	}
}

func GraphShape() shape.Shape {
	return &shape.StructLike{
		Name:          "Graph",
		PkgName:       "testasset",
		PkgImportName: "github.com/widmogrod/mkunion/x/shape/testasset",
		Fields: []*shape.FieldLike{
			{
				Name: "Vertices",
				Type: &shape.MapLike{
					Key:          &shape.StringLike{},
					KeyIsPointer: false,
					Val:          &shape.Any{},
					ValIsPointer: true,
				},
			},
		},
	}
}

func VertexShape() shape.Shape {
	return &shape.StructLike{
		Name:          "Vertex",
		PkgName:       "testasset",
		PkgImportName: "github.com/widmogrod/mkunion/x/shape/testasset",
		Fields: []*shape.FieldLike{
			{
				Name: "Value",
				Type: &shape.RefName{
					Name:          "T",
					PkgName:       "testasset",
					PkgImportName: "github.com/widmogrod/mkunion/x/shape/testasset",
				},
			},
			{
				Name: "Edges",
				Type: &shape.ListLike{
					Element:          &shape.Any{},
					ElementIsPointer: true,
				},
			},
		},
	}
}

func EdgeShape() shape.Shape {
	return &shape.StructLike{
		Name:          "Edge",
		PkgName:       "testasset",
		PkgImportName: "github.com/widmogrod/mkunion/x/shape/testasset",
		Fields: []*shape.FieldLike{
			{
				Name: "Weight",
				Type: &shape.NumberLike{
					Kind: &shape.Float64{},
				},
			},
		},
	}
}

// mkunion-extension:json
type GraphDSLUnionJSON struct {
	Type   string          `json:"$type,omitempty"`
	Graph  json.RawMessage `json:"testasset.Graph,omitempty"`
	Vertex json.RawMessage `json:"testasset.Vertex,omitempty"`
	Edge   json.RawMessage `json:"testasset.Edge,omitempty"`
}

func GraphDSLFromJSON[T1 any](x []byte) (GraphDSL[T1], error) {
	var data GraphDSLUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, err
	}

	switch data.Type {
	case "testasset.Graph":
		return GraphFromJSON[T1](data.Graph)
	case "testasset.Vertex":
		return VertexFromJSON[T1](data.Vertex)
	case "testasset.Edge":
		return EdgeFromJSON[T1](data.Edge)
	}

	if data.Graph != nil {
		return GraphFromJSON[T1](data.Graph)
	} else if data.Vertex != nil {
		return VertexFromJSON[T1](data.Vertex)
	} else if data.Edge != nil {
		return EdgeFromJSON[T1](data.Edge)
	}

	return nil, fmt.Errorf("unknown type %s", data.Type)
}

func GraphDSLToJSON[T1 any](x GraphDSL[T1]) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return MustMatchGraphDSLR2(
		x,
		func(x *Graph[T1]) ([]byte, error) {
			body, err := GraphToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(GraphDSLUnionJSON{
				Type:  "testasset.Graph",
				Graph: body,
			})
		},
		func(x *Vertex[T1]) ([]byte, error) {
			body, err := VertexToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(GraphDSLUnionJSON{
				Type:   "testasset.Vertex",
				Vertex: body,
			})
		},
		func(x *Edge[T1]) ([]byte, error) {
			body, err := EdgeToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(GraphDSLUnionJSON{
				Type: "testasset.Edge",
				Edge: body,
			})
		},
	)
}

func GraphFromJSON[T1 any](x []byte) (*Graph[T1], error) {
	var result *Graph[T1] = new(Graph[T1])
	// if is Struct
	err := shared.JSONParseObject(x, func(key string, value []byte) error {
		switch key {
		case "Vertices":
			return json.Unmarshal(value, &result.Vertices)
		}

		return fmt.Errorf("testasset.GraphFromJSON: unknown key %s", key)
	})

	return result, err
}

func GraphToJSON[T1 any](x *Graph[T1]) ([]byte, error) {
	field_Vertices, err := json.Marshal(x.Vertices)
	if err != nil {
		return nil, err
	}
	return json.Marshal(map[string]json.RawMessage{
		"Vertices": field_Vertices,
	})
}
func (self *Graph[T1]) MarshalJSON() ([]byte, error) {
	return GraphToJSON(self)
}

func (self *Graph[T1]) UnmarshalJSON(x []byte) error {
	n, err := GraphFromJSON[T1](x)
	if err != nil {
		return err
	}
	*self = *n
	return nil
}

func VertexFromJSON[T1 any](x []byte) (*Vertex[T1], error) {
	var result *Vertex[T1] = new(Vertex[T1])
	// if is Struct
	err := shared.JSONParseObject(x, func(key string, value []byte) error {
		switch key {
		case "Value":
			return json.Unmarshal(value, &result.Value)
		case "Edges":
			return json.Unmarshal(value, &result.Edges)
		}

		return fmt.Errorf("testasset.VertexFromJSON: unknown key %s", key)
	})

	return result, err
}

func VertexToJSON[T1 any](x *Vertex[T1]) ([]byte, error) {
	field_Value, err := json.Marshal(x.Value)
	if err != nil {
		return nil, err
	}
	field_Edges, err := json.Marshal(x.Edges)
	if err != nil {
		return nil, err
	}
	return json.Marshal(map[string]json.RawMessage{
		"Value": field_Value,
		"Edges": field_Edges,
	})
}
func (self *Vertex[T1]) MarshalJSON() ([]byte, error) {
	return VertexToJSON[T1](self)
}

func (self *Vertex[T1]) UnmarshalJSON(x []byte) error {
	n, err := VertexFromJSON[T1](x)
	if err != nil {
		return err
	}
	*self = *n
	return nil
}

func EdgeFromJSON[T1 any](x []byte) (*Edge[T1], error) {
	var result *Edge[T1] = new(Edge[T1])
	// if is Struct
	err := shared.JSONParseObject(x, func(key string, value []byte) error {
		switch key {
		case "Weight":
			return json.Unmarshal(value, &result.Weight)
		}

		return fmt.Errorf("testasset.EdgeFromJSON: unknown key %s", key)
	})

	return result, err
}

func EdgeToJSON[T1 any](x *Edge[T1]) ([]byte, error) {
	field_Weight, err := json.Marshal(x.Weight)
	if err != nil {
		return nil, err
	}
	return json.Marshal(map[string]json.RawMessage{
		"Weight": field_Weight,
	})
}
func (self *Edge[T1]) MarshalJSON() ([]byte, error) {
	return EdgeToJSON(self)
}

func (self *Edge[T1]) UnmarshalJSON(x []byte) error {
	n, err := EdgeFromJSON[T1](x)
	if err != nil {
		return err
	}
	*self = *n
	return nil
}
