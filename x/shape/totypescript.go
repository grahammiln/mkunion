package shape

import (
	"fmt"
	"os"
	"path"
	"strings"
)

type (
	TypeScriptOptions struct {
		currentPkgName string
		imports        map[packageName]packageImportName
	}

	packageImportName = string
	packageName       = string
)

func (o *TypeScriptOptions) IsCurrentPkgName(pkgName string) bool {
	return o.currentPkgName == pkgName
}

func (o *TypeScriptOptions) NeedsToImportPkgName(pkg packageName, imp packageImportName) {
	if o.imports == nil {
		o.imports = make(map[packageName]packageImportName)
	}

	o.imports[pkg] = imp
}

func ToTypeScript(x Shape, option *TypeScriptOptions) string {
	return MustMatchShape(
		x,
		func(x *Any) string {
			return "any"
		},
		func(x *RefName) string {
			if option.IsCurrentPkgName(x.PkgName) {
				return x.Name
			}

			option.NeedsToImportPkgName(x.PkgName, x.PkgImportName)

			return fmt.Sprintf("%s.%s", x.PkgName, x.Name)
		},
		func(x *BooleanLike) string {
			return "bool"
		},
		func(x *StringLike) string {
			return "string"
		},
		func(x *NumberLike) string {
			return "number"
		},
		func(x *ListLike) string {
			return fmt.Sprintf("%s[]", ToTypeScript(x.Element, option))
		},
		func(x *MapLike) string {
			return fmt.Sprintf("{[key: %s]: %s}", ToTypeScript(x.Key, option), ToTypeScript(x.Val, option))
		},
		func(x *StructLike) string {
			result := &strings.Builder{}
			_, _ = fmt.Fprintf(result, "export type %s = {\n", x.Name)
			for _, field := range x.Fields {
				result.WriteString(fmt.Sprintf("\t%s?: %s,\n", field.Name, ToTypeScript(field.Type, option)))
			}
			result.WriteString("}")
			result.WriteString("\n")

			return result.String()
		},
		func(x *UnionLike) string {
			result := &strings.Builder{}
			_, _ = fmt.Fprintf(result, "export type %s = {\n", x.Name)
			for idx, variant := range x.Variant {
				if idx > 0 {
					result.WriteString("\n} | {\n")
				}

				typeName := variant.Name
				typeNameFul := fmt.Sprintf("%s.%s", x.PkgName, variant.Name)
				_, _ = fmt.Fprintf(result, "\t"+`"%s": %s`, typeNameFul, typeName)
			}
			result.WriteString("\n}")

			result.WriteString("\n")
			for _, variant := range x.Variant {
				result.WriteString("\n")
				result.WriteString(ToTypeScript(variant, option))
			}
			result.WriteString("\n")

			return result.String()
		},
	)
}

func NewTypeScriptRenderer() *TypeScriptRenderer {
	return &TypeScriptRenderer{
		imports:  make(map[packageName]*TypeScriptOptions),
		contents: make(map[packageName]*strings.Builder),
	}
}

type TypeScriptRenderer struct {
	imports  map[packageName]*TypeScriptOptions
	contents map[packageName]*strings.Builder
}

func (r *TypeScriptRenderer) AddUnion(x *UnionLike) {
	if _, ok := r.contents[x.PkgName]; !ok {
		r.contents[x.PkgName] = &strings.Builder{}
	}

	if _, ok := r.imports[x.PkgName]; !ok {
		r.imports[x.PkgName] = &TypeScriptOptions{
			currentPkgName: x.PkgName,
			imports:        make(map[packageName]packageImportName),
		}
	}

	res := ToTypeScript(x, r.imports[x.PkgName])
	r.contents[x.PkgName].WriteString("//generated by mkunion\n")
	r.contents[x.PkgName].WriteString(res)
}

func (r *TypeScriptRenderer) WriteToDir(dir string) error {
	for pkgName, content := range r.contents {
		imports := r.imports[pkgName]
		if imports == nil {
			continue
		}

		importsContent := &strings.Builder{}
		for pkg, imp := range imports.imports {
			//if pkg == pkgName {
			//	continue
			//}

			_, err := fmt.Fprintf(importsContent, "import * as %s from '%s'\n", pkg, r.normaliseImport(imp))
			if err != nil {
				return fmt.Errorf("totypescript: WriteToDir failed to write imports: %w", err)
			}
		}

		_, err := fmt.Fprintf(content, "\n%s", importsContent.String())
		if err != nil {
			return fmt.Errorf("totypescript: WriteToDir failed to write imports: %w", err)
		}

		err = r.writeToFile(dir, pkgName, content.String())
		if err != nil {
			return fmt.Errorf("totypescript: WriteToDir failed to write file %s: %w", dir, err)
		}
	}

	return nil
}

func (r *TypeScriptRenderer) writeToFile(dir string, name packageName, content string) error {
	filename := path.Join(dir, fmt.Sprintf("%s.ts", name))
	err := os.MkdirAll(dir, 0755)
	if err != nil {
		return err
	}

	err = os.WriteFile(filename, []byte(content), 0644)
	if err != nil {
		return err
	}

	return nil
}

func (r *TypeScriptRenderer) AddStruct(like *StructLike) {
	if _, ok := r.contents[like.PkgName]; !ok {
		r.contents[like.PkgName] = &strings.Builder{}
	}

	if _, ok := r.imports[like.PkgName]; !ok {
		r.imports[like.PkgName] = &TypeScriptOptions{
			currentPkgName: like.PkgName,
			imports:        make(map[packageName]packageImportName),
		}
	}

	res := ToTypeScript(like, r.imports[like.PkgName])
	r.contents[like.PkgName].WriteString(res)
}

func (r *TypeScriptRenderer) normaliseImport(imp packageImportName) string {
	replace := strings.NewReplacer("/", "_", ".", "_")
	result := replace.Replace(imp)
	result = "./" + result
	return result
}
