// Code generated by mkunion. DO NOT EDIT.
package shape

import "github.com/widmogrod/mkunion/x/schema"
import "github.com/widmogrod/mkunion/f"

// mkunion-extension:schema
func init() {
	schema.RegisterUnionTypes(GuardSchemaDef())
}

func GuardSchemaDef() *schema.UnionVariants[Guard] {
	return schema.MustDefineUnion[Guard](
		&Enum{},
		&Required{},
		&AndGuard{},
	)
}

//mkunion-extension:visitor

type GuardVisitor interface {
	VisitEnum(v *Enum) any
	VisitRequired(v *Required) any
	VisitAndGuard(v *AndGuard) any
}

type Guard interface {
	AcceptGuard(g GuardVisitor) any
}

func (r *Enum) AcceptGuard(v GuardVisitor) any     { return v.VisitEnum(r) }
func (r *Required) AcceptGuard(v GuardVisitor) any { return v.VisitRequired(r) }
func (r *AndGuard) AcceptGuard(v GuardVisitor) any { return v.VisitAndGuard(r) }

var (
	_ Guard = (*Enum)(nil)
	_ Guard = (*Required)(nil)
	_ Guard = (*AndGuard)(nil)
)

func MatchGuard[TOut any](
	x Guard,
	f1 func(x *Enum) TOut,
	f2 func(x *Required) TOut,
	f3 func(x *AndGuard) TOut,
	df func(x Guard) TOut,
) TOut {
	return f.Match3(x, f1, f2, f3, df)
}

func MatchGuardR2[TOut1, TOut2 any](
	x Guard,
	f1 func(x *Enum) (TOut1, TOut2),
	f2 func(x *Required) (TOut1, TOut2),
	f3 func(x *AndGuard) (TOut1, TOut2),
	df func(x Guard) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.Match3R2(x, f1, f2, f3, df)
}

func MustMatchGuard[TOut any](
	x Guard,
	f1 func(x *Enum) TOut,
	f2 func(x *Required) TOut,
	f3 func(x *AndGuard) TOut,
) TOut {
	return f.MustMatch3(x, f1, f2, f3)
}

func MustMatchGuardR0(
	x Guard,
	f1 func(x *Enum),
	f2 func(x *Required),
	f3 func(x *AndGuard),
) {
	f.MustMatch3R0(x, f1, f2, f3)
}

func MustMatchGuardR2[TOut1, TOut2 any](
	x Guard,
	f1 func(x *Enum) (TOut1, TOut2),
	f2 func(x *Required) (TOut1, TOut2),
	f3 func(x *AndGuard) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.MustMatch3R2(x, f1, f2, f3)
}
