// Code generated by mkunion. DO NOT EDIT.
package schema

import "github.com/widmogrod/mkunion/f"

// mkunion-extension:default_visitor
type SchemaDefaultVisitor[A any] struct {
	Default  A
	OnNone   func(x *None) A
	OnBool   func(x *Bool) A
	OnNumber func(x *Number) A
	OnString func(x *String) A
	OnBinary func(x *Binary) A
	OnList   func(x *List) A
	OnMap    func(x *Map) A
}

func (t *SchemaDefaultVisitor[A]) VisitNone(v *None) any {
	if t.OnNone != nil {
		return t.OnNone(v)
	}
	return t.Default
}
func (t *SchemaDefaultVisitor[A]) VisitBool(v *Bool) any {
	if t.OnBool != nil {
		return t.OnBool(v)
	}
	return t.Default
}
func (t *SchemaDefaultVisitor[A]) VisitNumber(v *Number) any {
	if t.OnNumber != nil {
		return t.OnNumber(v)
	}
	return t.Default
}
func (t *SchemaDefaultVisitor[A]) VisitString(v *String) any {
	if t.OnString != nil {
		return t.OnString(v)
	}
	return t.Default
}
func (t *SchemaDefaultVisitor[A]) VisitBinary(v *Binary) any {
	if t.OnBinary != nil {
		return t.OnBinary(v)
	}
	return t.Default
}
func (t *SchemaDefaultVisitor[A]) VisitList(v *List) any {
	if t.OnList != nil {
		return t.OnList(v)
	}
	return t.Default
}
func (t *SchemaDefaultVisitor[A]) VisitMap(v *Map) any {
	if t.OnMap != nil {
		return t.OnMap(v)
	}
	return t.Default
}

//mkunion-extension:visitor

type SchemaVisitor interface {
	VisitNone(v *None) any
	VisitBool(v *Bool) any
	VisitNumber(v *Number) any
	VisitString(v *String) any
	VisitBinary(v *Binary) any
	VisitList(v *List) any
	VisitMap(v *Map) any
}

type Schema interface {
	AcceptSchema(g SchemaVisitor) any
}

func (r *None) AcceptSchema(v SchemaVisitor) any   { return v.VisitNone(r) }
func (r *Bool) AcceptSchema(v SchemaVisitor) any   { return v.VisitBool(r) }
func (r *Number) AcceptSchema(v SchemaVisitor) any { return v.VisitNumber(r) }
func (r *String) AcceptSchema(v SchemaVisitor) any { return v.VisitString(r) }
func (r *Binary) AcceptSchema(v SchemaVisitor) any { return v.VisitBinary(r) }
func (r *List) AcceptSchema(v SchemaVisitor) any   { return v.VisitList(r) }
func (r *Map) AcceptSchema(v SchemaVisitor) any    { return v.VisitMap(r) }

var (
	_ Schema = (*None)(nil)
	_ Schema = (*Bool)(nil)
	_ Schema = (*Number)(nil)
	_ Schema = (*String)(nil)
	_ Schema = (*Binary)(nil)
	_ Schema = (*List)(nil)
	_ Schema = (*Map)(nil)
)

func MatchSchema[TOut any](
	x Schema,
	f1 func(x *None) TOut,
	f2 func(x *Bool) TOut,
	f3 func(x *Number) TOut,
	f4 func(x *String) TOut,
	f5 func(x *Binary) TOut,
	f6 func(x *List) TOut,
	f7 func(x *Map) TOut,
	df func(x Schema) TOut,
) TOut {
	return f.Match7(x, f1, f2, f3, f4, f5, f6, f7, df)
}

func MatchSchemaR2[TOut1, TOut2 any](
	x Schema,
	f1 func(x *None) (TOut1, TOut2),
	f2 func(x *Bool) (TOut1, TOut2),
	f3 func(x *Number) (TOut1, TOut2),
	f4 func(x *String) (TOut1, TOut2),
	f5 func(x *Binary) (TOut1, TOut2),
	f6 func(x *List) (TOut1, TOut2),
	f7 func(x *Map) (TOut1, TOut2),
	df func(x Schema) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.Match7R2(x, f1, f2, f3, f4, f5, f6, f7, df)
}

func MustMatchSchema[TOut any](
	x Schema,
	f1 func(x *None) TOut,
	f2 func(x *Bool) TOut,
	f3 func(x *Number) TOut,
	f4 func(x *String) TOut,
	f5 func(x *Binary) TOut,
	f6 func(x *List) TOut,
	f7 func(x *Map) TOut,
) TOut {
	return f.MustMatch7(x, f1, f2, f3, f4, f5, f6, f7)
}

func MustMatchSchemaR0(
	x Schema,
	f1 func(x *None),
	f2 func(x *Bool),
	f3 func(x *Number),
	f4 func(x *String),
	f5 func(x *Binary),
	f6 func(x *List),
	f7 func(x *Map),
) {
	f.MustMatch7R0(x, f1, f2, f3, f4, f5, f6, f7)
}

func MustMatchSchemaR2[TOut1, TOut2 any](
	x Schema,
	f1 func(x *None) (TOut1, TOut2),
	f2 func(x *Bool) (TOut1, TOut2),
	f3 func(x *Number) (TOut1, TOut2),
	f4 func(x *String) (TOut1, TOut2),
	f5 func(x *Binary) (TOut1, TOut2),
	f6 func(x *List) (TOut1, TOut2),
	f7 func(x *Map) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.MustMatch7R2(x, f1, f2, f3, f4, f5, f6, f7)
}

// mkunion-extension:reducer_dfs
type (
	SchemaReducer[A any] interface {
		ReduceNone(x *None, agg A) (result A, stop bool)
		ReduceBool(x *Bool, agg A) (result A, stop bool)
		ReduceNumber(x *Number, agg A) (result A, stop bool)
		ReduceString(x *String, agg A) (result A, stop bool)
		ReduceBinary(x *Binary, agg A) (result A, stop bool)
		ReduceList(x *List, agg A) (result A, stop bool)
		ReduceMap(x *Map, agg A) (result A, stop bool)
	}
)

type SchemaDepthFirstVisitor[A any] struct {
	stop   bool
	result A
	reduce SchemaReducer[A]
}

var _ SchemaVisitor = (*SchemaDepthFirstVisitor[any])(nil)

func (d *SchemaDepthFirstVisitor[A]) VisitNone(v *None) any {
	d.result, d.stop = d.reduce.ReduceNone(v, d.result)
	if d.stop {
		return nil
	}

	return nil
}

func (d *SchemaDepthFirstVisitor[A]) VisitBool(v *Bool) any {
	d.result, d.stop = d.reduce.ReduceBool(v, d.result)
	if d.stop {
		return nil
	}

	return nil
}

func (d *SchemaDepthFirstVisitor[A]) VisitNumber(v *Number) any {
	d.result, d.stop = d.reduce.ReduceNumber(v, d.result)
	if d.stop {
		return nil
	}

	return nil
}

func (d *SchemaDepthFirstVisitor[A]) VisitString(v *String) any {
	d.result, d.stop = d.reduce.ReduceString(v, d.result)
	if d.stop {
		return nil
	}

	return nil
}

func (d *SchemaDepthFirstVisitor[A]) VisitBinary(v *Binary) any {
	d.result, d.stop = d.reduce.ReduceBinary(v, d.result)
	if d.stop {
		return nil
	}

	return nil
}

func (d *SchemaDepthFirstVisitor[A]) VisitList(v *List) any {
	d.result, d.stop = d.reduce.ReduceList(v, d.result)
	if d.stop {
		return nil
	}
	for idx := range v.Items {
		if _ = v.Items[idx].AcceptSchema(d); d.stop {
			return nil
		}
	}

	return nil
}

func (d *SchemaDepthFirstVisitor[A]) VisitMap(v *Map) any {
	d.result, d.stop = d.reduce.ReduceMap(v, d.result)
	if d.stop {
		return nil
	}

	return nil
}

func ReduceSchemaDepthFirst[A any](r SchemaReducer[A], v Schema, init A) A {
	reducer := &SchemaDepthFirstVisitor[A]{
		result: init,
		reduce: r,
	}

	_ = v.AcceptSchema(reducer)

	return reducer.result
}

// mkunion-extension:reducer_bfs
var _ SchemaVisitor = (*SchemaBreadthFirstVisitor[any])(nil)

type SchemaBreadthFirstVisitor[A any] struct {
	stop   bool
	result A
	reduce SchemaReducer[A]

	queue         []Schema
	visited       map[Schema]bool
	shouldExecute map[Schema]bool
}

func (d *SchemaBreadthFirstVisitor[A]) VisitNone(v *None) any {
	d.queue = append(d.queue, v)

	if d.shouldExecute[v] {
		d.shouldExecute[v] = false
		d.result, d.stop = d.reduce.ReduceNone(v, d.result)
	} else {
		d.execute()
	}
	return nil
}

func (d *SchemaBreadthFirstVisitor[A]) VisitBool(v *Bool) any {
	d.queue = append(d.queue, v)

	if d.shouldExecute[v] {
		d.shouldExecute[v] = false
		d.result, d.stop = d.reduce.ReduceBool(v, d.result)
	} else {
		d.execute()
	}
	return nil
}

func (d *SchemaBreadthFirstVisitor[A]) VisitNumber(v *Number) any {
	d.queue = append(d.queue, v)

	if d.shouldExecute[v] {
		d.shouldExecute[v] = false
		d.result, d.stop = d.reduce.ReduceNumber(v, d.result)
	} else {
		d.execute()
	}
	return nil
}

func (d *SchemaBreadthFirstVisitor[A]) VisitString(v *String) any {
	d.queue = append(d.queue, v)

	if d.shouldExecute[v] {
		d.shouldExecute[v] = false
		d.result, d.stop = d.reduce.ReduceString(v, d.result)
	} else {
		d.execute()
	}
	return nil
}

func (d *SchemaBreadthFirstVisitor[A]) VisitBinary(v *Binary) any {
	d.queue = append(d.queue, v)

	if d.shouldExecute[v] {
		d.shouldExecute[v] = false
		d.result, d.stop = d.reduce.ReduceBinary(v, d.result)
	} else {
		d.execute()
	}
	return nil
}

func (d *SchemaBreadthFirstVisitor[A]) VisitList(v *List) any {
	d.queue = append(d.queue, v)
	for idx := range v.Items {
		d.queue = append(d.queue, v.Items[idx])
	}

	if d.shouldExecute[v] {
		d.shouldExecute[v] = false
		d.result, d.stop = d.reduce.ReduceList(v, d.result)
	} else {
		d.execute()
	}
	return nil
}

func (d *SchemaBreadthFirstVisitor[A]) VisitMap(v *Map) any {
	d.queue = append(d.queue, v)

	if d.shouldExecute[v] {
		d.shouldExecute[v] = false
		d.result, d.stop = d.reduce.ReduceMap(v, d.result)
	} else {
		d.execute()
	}
	return nil
}

func (d *SchemaBreadthFirstVisitor[A]) execute() {
	for len(d.queue) > 0 {
		if d.stop {
			return
		}

		i := d.pop()
		if d.visited[i] {
			continue
		}
		d.visited[i] = true
		d.shouldExecute[i] = true
		i.AcceptSchema(d)
	}

	return
}

func (d *SchemaBreadthFirstVisitor[A]) pop() Schema {
	i := d.queue[0]
	d.queue = d.queue[1:]
	return i
}

func ReduceSchemaBreadthFirst[A any](r SchemaReducer[A], v Schema, init A) A {
	reducer := &SchemaBreadthFirstVisitor[A]{
		result:        init,
		reduce:        r,
		queue:         []Schema{v},
		visited:       make(map[Schema]bool),
		shouldExecute: make(map[Schema]bool),
	}

	_ = v.AcceptSchema(reducer)

	return reducer.result
}

// mkunion-extension:default_reducer
var _ SchemaReducer[any] = (*SchemaDefaultReduction[any])(nil)

type (
	SchemaDefaultReduction[A any] struct {
		PanicOnFallback      bool
		DefaultStopReduction bool
		OnNone               func(x *None, agg A) (result A, stop bool)
		OnBool               func(x *Bool, agg A) (result A, stop bool)
		OnNumber             func(x *Number, agg A) (result A, stop bool)
		OnString             func(x *String, agg A) (result A, stop bool)
		OnBinary             func(x *Binary, agg A) (result A, stop bool)
		OnList               func(x *List, agg A) (result A, stop bool)
		OnMap                func(x *Map, agg A) (result A, stop bool)
	}
)

func (t *SchemaDefaultReduction[A]) ReduceNone(x *None, agg A) (result A, stop bool) {
	if t.OnNone != nil {
		return t.OnNone(x, agg)
	}
	if t.PanicOnFallback {
		panic("no fallback allowed on undefined ReduceBranch")
	}
	return agg, t.DefaultStopReduction
}

func (t *SchemaDefaultReduction[A]) ReduceBool(x *Bool, agg A) (result A, stop bool) {
	if t.OnBool != nil {
		return t.OnBool(x, agg)
	}
	if t.PanicOnFallback {
		panic("no fallback allowed on undefined ReduceBranch")
	}
	return agg, t.DefaultStopReduction
}

func (t *SchemaDefaultReduction[A]) ReduceNumber(x *Number, agg A) (result A, stop bool) {
	if t.OnNumber != nil {
		return t.OnNumber(x, agg)
	}
	if t.PanicOnFallback {
		panic("no fallback allowed on undefined ReduceBranch")
	}
	return agg, t.DefaultStopReduction
}

func (t *SchemaDefaultReduction[A]) ReduceString(x *String, agg A) (result A, stop bool) {
	if t.OnString != nil {
		return t.OnString(x, agg)
	}
	if t.PanicOnFallback {
		panic("no fallback allowed on undefined ReduceBranch")
	}
	return agg, t.DefaultStopReduction
}

func (t *SchemaDefaultReduction[A]) ReduceBinary(x *Binary, agg A) (result A, stop bool) {
	if t.OnBinary != nil {
		return t.OnBinary(x, agg)
	}
	if t.PanicOnFallback {
		panic("no fallback allowed on undefined ReduceBranch")
	}
	return agg, t.DefaultStopReduction
}

func (t *SchemaDefaultReduction[A]) ReduceList(x *List, agg A) (result A, stop bool) {
	if t.OnList != nil {
		return t.OnList(x, agg)
	}
	if t.PanicOnFallback {
		panic("no fallback allowed on undefined ReduceBranch")
	}
	return agg, t.DefaultStopReduction
}

func (t *SchemaDefaultReduction[A]) ReduceMap(x *Map, agg A) (result A, stop bool) {
	if t.OnMap != nil {
		return t.OnMap(x, agg)
	}
	if t.PanicOnFallback {
		panic("no fallback allowed on undefined ReduceBranch")
	}
	return agg, t.DefaultStopReduction
}
