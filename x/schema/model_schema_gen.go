// Code generated by mkunion. DO NOT EDIT.
package schema

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/f"
	"github.com/widmogrod/mkunion/x/shape"
	"github.com/widmogrod/mkunion/x/shared"
)

func init() {
	shape.Register(SchemaShape())
	shape.Register(NoneShape())
	shape.Register(BoolShape())
	shape.Register(NumberShape())
	shape.Register(StringShape())
	shape.Register(BinaryShape())
	shape.Register(ListShape())
	shape.Register(MapShape())
}

//mkunion-extension:visitor

type SchemaVisitor interface {
	VisitNone(v *None) any
	VisitBool(v *Bool) any
	VisitNumber(v *Number) any
	VisitString(v *String) any
	VisitBinary(v *Binary) any
	VisitList(v *List) any
	VisitMap(v *Map) any
}

type Schema interface {
	AcceptSchema(g SchemaVisitor) any
}

func (r *None) AcceptSchema(v SchemaVisitor) any   { return v.VisitNone(r) }
func (r *Bool) AcceptSchema(v SchemaVisitor) any   { return v.VisitBool(r) }
func (r *Number) AcceptSchema(v SchemaVisitor) any { return v.VisitNumber(r) }
func (r *String) AcceptSchema(v SchemaVisitor) any { return v.VisitString(r) }
func (r *Binary) AcceptSchema(v SchemaVisitor) any { return v.VisitBinary(r) }
func (r *List) AcceptSchema(v SchemaVisitor) any   { return v.VisitList(r) }
func (r *Map) AcceptSchema(v SchemaVisitor) any    { return v.VisitMap(r) }

var (
	_ Schema = (*None)(nil)
	_ Schema = (*Bool)(nil)
	_ Schema = (*Number)(nil)
	_ Schema = (*String)(nil)
	_ Schema = (*Binary)(nil)
	_ Schema = (*List)(nil)
	_ Schema = (*Map)(nil)
)

func MatchSchema[TOut any](
	x Schema,
	f1 func(x *None) TOut,
	f2 func(x *Bool) TOut,
	f3 func(x *Number) TOut,
	f4 func(x *String) TOut,
	f5 func(x *Binary) TOut,
	f6 func(x *List) TOut,
	f7 func(x *Map) TOut,
	df func(x Schema) TOut,
) TOut {
	return f.Match7(x, f1, f2, f3, f4, f5, f6, f7, df)
}

func MatchSchemaR2[TOut1, TOut2 any](
	x Schema,
	f1 func(x *None) (TOut1, TOut2),
	f2 func(x *Bool) (TOut1, TOut2),
	f3 func(x *Number) (TOut1, TOut2),
	f4 func(x *String) (TOut1, TOut2),
	f5 func(x *Binary) (TOut1, TOut2),
	f6 func(x *List) (TOut1, TOut2),
	f7 func(x *Map) (TOut1, TOut2),
	df func(x Schema) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.Match7R2(x, f1, f2, f3, f4, f5, f6, f7, df)
}

func MustMatchSchema[TOut any](
	x Schema,
	f1 func(x *None) TOut,
	f2 func(x *Bool) TOut,
	f3 func(x *Number) TOut,
	f4 func(x *String) TOut,
	f5 func(x *Binary) TOut,
	f6 func(x *List) TOut,
	f7 func(x *Map) TOut,
) TOut {
	return f.MustMatch7(x, f1, f2, f3, f4, f5, f6, f7)
}

func MustMatchSchemaR0(
	x Schema,
	f1 func(x *None),
	f2 func(x *Bool),
	f3 func(x *Number),
	f4 func(x *String),
	f5 func(x *Binary),
	f6 func(x *List),
	f7 func(x *Map),
) {
	f.MustMatch7R0(x, f1, f2, f3, f4, f5, f6, f7)
}

func MustMatchSchemaR2[TOut1, TOut2 any](
	x Schema,
	f1 func(x *None) (TOut1, TOut2),
	f2 func(x *Bool) (TOut1, TOut2),
	f3 func(x *Number) (TOut1, TOut2),
	f4 func(x *String) (TOut1, TOut2),
	f5 func(x *Binary) (TOut1, TOut2),
	f6 func(x *List) (TOut1, TOut2),
	f7 func(x *Map) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.MustMatch7R2(x, f1, f2, f3, f4, f5, f6, f7)
}

// mkunion-extension:shape
func SchemaShape() shape.Shape {
	return &shape.UnionLike{
		Name:          "Schema",
		PkgName:       "schema",
		PkgImportName: "github.com/widmogrod/mkunion/x/schema",
		Variant: []shape.Shape{
			NoneShape(),
			BoolShape(),
			NumberShape(),
			StringShape(),
			BinaryShape(),
			ListShape(),
			MapShape(),
		},
	}
}

func NoneShape() shape.Shape {
	return &shape.StructLike{
		Name:          "None",
		PkgName:       "schema",
		PkgImportName: "github.com/widmogrod/mkunion/x/schema",
	}
}

func BoolShape() shape.Shape {
	return &shape.AliasLike{
		Name:          "Bool",
		PkgName:       "schema",
		PkgImportName: "github.com/widmogrod/mkunion/x/schema",
		IsAlias:       false,
		Type:          &shape.BooleanLike{},
	}
}

func NumberShape() shape.Shape {
	return &shape.AliasLike{
		Name:          "Number",
		PkgName:       "schema",
		PkgImportName: "github.com/widmogrod/mkunion/x/schema",
		IsAlias:       false,
		Type: &shape.NumberLike{
			Kind: &shape.Float64{},
		},
	}
}

func StringShape() shape.Shape {
	return &shape.AliasLike{
		Name:          "String",
		PkgName:       "schema",
		PkgImportName: "github.com/widmogrod/mkunion/x/schema",
		IsAlias:       false,
		Type:          &shape.StringLike{},
	}
}

func BinaryShape() shape.Shape {
	return &shape.AliasLike{
		Name:          "Binary",
		PkgName:       "schema",
		PkgImportName: "github.com/widmogrod/mkunion/x/schema",
		IsAlias:       false,
		Type: &shape.ListLike{
			Element: &shape.NumberLike{
				Kind: &shape.UInt8{},
			},
			ElementIsPointer: false,
		},
	}
}

func ListShape() shape.Shape {
	return &shape.AliasLike{
		Name:          "List",
		PkgName:       "schema",
		PkgImportName: "github.com/widmogrod/mkunion/x/schema",
		IsAlias:       false,
		Type: &shape.ListLike{
			Element: &shape.RefName{
				Name:          "Schema",
				PkgName:       "schema",
				PkgImportName: "github.com/widmogrod/mkunion/x/schema",
				IsPointer:     false,
			},
			ElementIsPointer: false,
		},
	}
}

func MapShape() shape.Shape {
	return &shape.AliasLike{
		Name:          "Map",
		PkgName:       "schema",
		PkgImportName: "github.com/widmogrod/mkunion/x/schema",
		IsAlias:       false,
		Type: &shape.MapLike{
			Key:          &shape.StringLike{},
			KeyIsPointer: false,
			Val: &shape.RefName{
				Name:          "Schema",
				PkgName:       "schema",
				PkgImportName: "github.com/widmogrod/mkunion/x/schema",
				IsPointer:     false,
			},
			ValIsPointer: false,
		},
	}
}

// mkunion-extension:json
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/schema.Schema", SchemaFromJSON, SchemaToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/schema.None", NoneFromJSON, NoneToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/schema.Bool", BoolFromJSON, BoolToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/schema.Number", NumberFromJSON, NumberToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/schema.String", StringFromJSON, StringToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/schema.Binary", BinaryFromJSON, BinaryToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/schema.List", ListFromJSON, ListToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/schema.Map", MapFromJSON, MapToJSON)
}

type SchemaUnionJSON struct {
	Type   string          `json:"$type,omitempty"`
	None   json.RawMessage `json:"schema.None,omitempty"`
	Bool   json.RawMessage `json:"schema.Bool,omitempty"`
	Number json.RawMessage `json:"schema.Number,omitempty"`
	String json.RawMessage `json:"schema.String,omitempty"`
	Binary json.RawMessage `json:"schema.Binary,omitempty"`
	List   json.RawMessage `json:"schema.List,omitempty"`
	Map    json.RawMessage `json:"schema.Map,omitempty"`
}

func SchemaFromJSON(x []byte) (Schema, error) {
	var data SchemaUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, err
	}

	switch data.Type {
	case "schema.None":
		return NoneFromJSON(data.None)
	case "schema.Bool":
		return BoolFromJSON(data.Bool)
	case "schema.Number":
		return NumberFromJSON(data.Number)
	case "schema.String":
		return StringFromJSON(data.String)
	case "schema.Binary":
		return BinaryFromJSON(data.Binary)
	case "schema.List":
		return ListFromJSON(data.List)
	case "schema.Map":
		return MapFromJSON(data.Map)
	}

	if data.None != nil {
		return NoneFromJSON(data.None)
	} else if data.Bool != nil {
		return BoolFromJSON(data.Bool)
	} else if data.Number != nil {
		return NumberFromJSON(data.Number)
	} else if data.String != nil {
		return StringFromJSON(data.String)
	} else if data.Binary != nil {
		return BinaryFromJSON(data.Binary)
	} else if data.List != nil {
		return ListFromJSON(data.List)
	} else if data.Map != nil {
		return MapFromJSON(data.Map)
	}

	return nil, fmt.Errorf("schema.Schema: unknown type %s", data.Type)
}

func SchemaToJSON(x Schema) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return MustMatchSchemaR2(
		x,
		func(x *None) ([]byte, error) {
			body, err := NoneToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(SchemaUnionJSON{
				Type: "schema.None",
				None: body,
			})
		},
		func(x *Bool) ([]byte, error) {
			body, err := BoolToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(SchemaUnionJSON{
				Type: "schema.Bool",
				Bool: body,
			})
		},
		func(x *Number) ([]byte, error) {
			body, err := NumberToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(SchemaUnionJSON{
				Type:   "schema.Number",
				Number: body,
			})
		},
		func(x *String) ([]byte, error) {
			body, err := StringToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(SchemaUnionJSON{
				Type:   "schema.String",
				String: body,
			})
		},
		func(x *Binary) ([]byte, error) {
			body, err := BinaryToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(SchemaUnionJSON{
				Type:   "schema.Binary",
				Binary: body,
			})
		},
		func(x *List) ([]byte, error) {
			body, err := ListToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(SchemaUnionJSON{
				Type: "schema.List",
				List: body,
			})
		},
		func(x *Map) ([]byte, error) {
			body, err := MapToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(SchemaUnionJSON{
				Type: "schema.Map",
				Map:  body,
			})
		},
	)
}

func NoneFromJSON(x []byte) (*None, error) {
	result := new(None)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func NoneToJSON(x *None) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*None)(nil)
	_ json.Marshaler   = (*None)(nil)
)

func (r *None) MarshalJSON() ([]byte, error) {
	var err error
	result := make(map[string]json.RawMessage)

	output, err := json.Marshal(result)
	if err != nil {
		return nil, fmt.Errorf("schema.None.MarshalJSON: final step; %w", err)
	}

	return output, nil
}

func (r *None) UnmarshalJSON(bytes []byte) error {
	return shared.JSONParseObject(bytes, func(key string, bytes []byte) error {
		switch key {
		}

		return nil
	})
}

func BoolFromJSON(x []byte) (*Bool, error) {
	result := new(Bool)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func BoolToJSON(x *Bool) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Bool)(nil)
	_ json.Marshaler   = (*Bool)(nil)
)

func (r *Bool) MarshalJSON() ([]byte, error) {
	result, err := shared.JSONMarshal[bool](*r)
	if err != nil {
		return nil, fmt.Errorf("schema.Bool.MarshalJSON: %w", err)
	}
	return result, nil
}

func (r *Bool) UnmarshalJSON(bytes []byte) error {
	result, err := shared.JSONUnmarshal[bool](bytes)
	if err != nil {
		return fmt.Errorf("schema.Bool.UnmarshalJSON: %w", err)
	}
	*r = Bool(result)
	return nil
}

func NumberFromJSON(x []byte) (*Number, error) {
	result := new(Number)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func NumberToJSON(x *Number) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Number)(nil)
	_ json.Marshaler   = (*Number)(nil)
)

func (r *Number) MarshalJSON() ([]byte, error) {
	result, err := shared.JSONMarshal[float64](*r)
	if err != nil {
		return nil, fmt.Errorf("schema.Number.MarshalJSON: %w", err)
	}
	return result, nil
}

func (r *Number) UnmarshalJSON(bytes []byte) error {
	result, err := shared.JSONUnmarshal[float64](bytes)
	if err != nil {
		return fmt.Errorf("schema.Number.UnmarshalJSON: %w", err)
	}
	*r = Number(result)
	return nil
}

func StringFromJSON(x []byte) (*String, error) {
	result := new(String)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func StringToJSON(x *String) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*String)(nil)
	_ json.Marshaler   = (*String)(nil)
)

func (r *String) MarshalJSON() ([]byte, error) {
	result, err := shared.JSONMarshal[string](*r)
	if err != nil {
		return nil, fmt.Errorf("schema.String.MarshalJSON: %w", err)
	}
	return result, nil
}

func (r *String) UnmarshalJSON(bytes []byte) error {
	result, err := shared.JSONUnmarshal[string](bytes)
	if err != nil {
		return fmt.Errorf("schema.String.UnmarshalJSON: %w", err)
	}
	*r = String(result)
	return nil
}

func BinaryFromJSON(x []byte) (*Binary, error) {
	result := new(Binary)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func BinaryToJSON(x *Binary) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Binary)(nil)
	_ json.Marshaler   = (*Binary)(nil)
)

func (r *Binary) MarshalJSON() ([]byte, error) {
	result, err := shared.JSONMarshal[[]uint8](*r)
	if err != nil {
		return nil, fmt.Errorf("schema.Binary.MarshalJSON: %w", err)
	}
	return result, nil
}

func (r *Binary) UnmarshalJSON(bytes []byte) error {
	result, err := shared.JSONUnmarshal[[]uint8](bytes)
	if err != nil {
		return fmt.Errorf("schema.Binary.UnmarshalJSON: %w", err)
	}
	*r = Binary(result)
	return nil
}

func ListFromJSON(x []byte) (*List, error) {
	result := new(List)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func ListToJSON(x *List) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*List)(nil)
	_ json.Marshaler   = (*List)(nil)
)

func (r *List) MarshalJSON() ([]byte, error) {
	result, err := shared.JSONMarshal[[]Schema](*r)
	if err != nil {
		return nil, fmt.Errorf("schema.List.MarshalJSON: %w", err)
	}
	return result, nil
}

func (r *List) UnmarshalJSON(bytes []byte) error {
	result, err := shared.JSONUnmarshal[[]Schema](bytes)
	if err != nil {
		return fmt.Errorf("schema.List.UnmarshalJSON: %w", err)
	}
	*r = List(result)
	return nil
}

func MapFromJSON(x []byte) (*Map, error) {
	result := new(Map)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func MapToJSON(x *Map) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Map)(nil)
	_ json.Marshaler   = (*Map)(nil)
)

func (r *Map) MarshalJSON() ([]byte, error) {
	fieldMap := make(map[string]json.RawMessage)
	for k, v := range *r {
		key, value, err := shared.JSONMarshalMap[string, Schema](k, v)
		if err != nil {
			return nil, fmt.Errorf("schema.Map.MarshalJSON:; %w", err)
		}
		fieldMap[key] = value
	}
	result, err := json.Marshal(fieldMap)
	if err != nil {
		return nil, fmt.Errorf("schema.Map.MarshalJSON:; %w", err)
	}
	return result, nil
}

func (r *Map) UnmarshalJSON(bytes []byte) error {
	*r = make(Map)
	return shared.JSONParseObject(bytes, func(key string, value []byte) error {
		k, v, err := shared.JSONUnmarshalMap[string, Schema](key, value)
		if err != nil {
			return fmt.Errorf("schema.Map.UnmarshalJSON: key %s; %w", key, err)
		}
		(*r)[k] = v
		return nil
	})
}
