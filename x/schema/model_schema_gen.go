// Code generated by mkunion. DO NOT EDIT.
package schema

import "github.com/widmogrod/mkunion/f"
import "github.com/widmogrod/mkunion/x/shared"
import "encoding/json"
import "fmt"

//mkunion-extension:visitor

type SchemaVisitor interface {
	VisitNone(v *None) any
	VisitBool(v *Bool) any
	VisitNumber(v *Number) any
	VisitString(v *String) any
	VisitBinary(v *Binary) any
	VisitList(v *List) any
	VisitMap(v *Map) any
}

type Schema interface {
	AcceptSchema(g SchemaVisitor) any
}

func (r *None) AcceptSchema(v SchemaVisitor) any   { return v.VisitNone(r) }
func (r *Bool) AcceptSchema(v SchemaVisitor) any   { return v.VisitBool(r) }
func (r *Number) AcceptSchema(v SchemaVisitor) any { return v.VisitNumber(r) }
func (r *String) AcceptSchema(v SchemaVisitor) any { return v.VisitString(r) }
func (r *Binary) AcceptSchema(v SchemaVisitor) any { return v.VisitBinary(r) }
func (r *List) AcceptSchema(v SchemaVisitor) any   { return v.VisitList(r) }
func (r *Map) AcceptSchema(v SchemaVisitor) any    { return v.VisitMap(r) }

var (
	_ Schema = (*None)(nil)
	_ Schema = (*Bool)(nil)
	_ Schema = (*Number)(nil)
	_ Schema = (*String)(nil)
	_ Schema = (*Binary)(nil)
	_ Schema = (*List)(nil)
	_ Schema = (*Map)(nil)
)

func MatchSchema[TOut any](
	x Schema,
	f1 func(x *None) TOut,
	f2 func(x *Bool) TOut,
	f3 func(x *Number) TOut,
	f4 func(x *String) TOut,
	f5 func(x *Binary) TOut,
	f6 func(x *List) TOut,
	f7 func(x *Map) TOut,
	df func(x Schema) TOut,
) TOut {
	return f.Match7(x, f1, f2, f3, f4, f5, f6, f7, df)
}

func MatchSchemaR2[TOut1, TOut2 any](
	x Schema,
	f1 func(x *None) (TOut1, TOut2),
	f2 func(x *Bool) (TOut1, TOut2),
	f3 func(x *Number) (TOut1, TOut2),
	f4 func(x *String) (TOut1, TOut2),
	f5 func(x *Binary) (TOut1, TOut2),
	f6 func(x *List) (TOut1, TOut2),
	f7 func(x *Map) (TOut1, TOut2),
	df func(x Schema) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.Match7R2(x, f1, f2, f3, f4, f5, f6, f7, df)
}

func MustMatchSchema[TOut any](
	x Schema,
	f1 func(x *None) TOut,
	f2 func(x *Bool) TOut,
	f3 func(x *Number) TOut,
	f4 func(x *String) TOut,
	f5 func(x *Binary) TOut,
	f6 func(x *List) TOut,
	f7 func(x *Map) TOut,
) TOut {
	return f.MustMatch7(x, f1, f2, f3, f4, f5, f6, f7)
}

func MustMatchSchemaR0(
	x Schema,
	f1 func(x *None),
	f2 func(x *Bool),
	f3 func(x *Number),
	f4 func(x *String),
	f5 func(x *Binary),
	f6 func(x *List),
	f7 func(x *Map),
) {
	f.MustMatch7R0(x, f1, f2, f3, f4, f5, f6, f7)
}

func MustMatchSchemaR2[TOut1, TOut2 any](
	x Schema,
	f1 func(x *None) (TOut1, TOut2),
	f2 func(x *Bool) (TOut1, TOut2),
	f3 func(x *Number) (TOut1, TOut2),
	f4 func(x *String) (TOut1, TOut2),
	f5 func(x *Binary) (TOut1, TOut2),
	f6 func(x *List) (TOut1, TOut2),
	f7 func(x *Map) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.MustMatch7R2(x, f1, f2, f3, f4, f5, f6, f7)
}

// mkunion-extension:json
type SchemaUnionJSON struct {
	Type   string          `json:"$type,omitempty"`
	None   json.RawMessage `json:"schema.None,omitempty"`
	Bool   json.RawMessage `json:"schema.Bool,omitempty"`
	Number json.RawMessage `json:"schema.Number,omitempty"`
	String json.RawMessage `json:"schema.String,omitempty"`
	Binary json.RawMessage `json:"schema.Binary,omitempty"`
	List   json.RawMessage `json:"schema.List,omitempty"`
	Map    json.RawMessage `json:"schema.Map,omitempty"`
}

func SchemaFromJSON(x []byte) (Schema, error) {
	var data SchemaUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, err
	}

	switch data.Type {
	case "schema.None":
		return NoneFromJSON(data.None)
	case "schema.Bool":
		return BoolFromJSON(data.Bool)
	case "schema.Number":
		return NumberFromJSON(data.Number)
	case "schema.String":
		return StringFromJSON(data.String)
	case "schema.Binary":
		return BinaryFromJSON(data.Binary)
	case "schema.List":
		return ListFromJSON(data.List)
	case "schema.Map":
		return MapFromJSON(data.Map)
	}

	if data.None != nil {
		return NoneFromJSON(data.None)
	} else if data.Bool != nil {
		return BoolFromJSON(data.Bool)
	} else if data.Number != nil {
		return NumberFromJSON(data.Number)
	} else if data.String != nil {
		return StringFromJSON(data.String)
	} else if data.Binary != nil {
		return BinaryFromJSON(data.Binary)
	} else if data.List != nil {
		return ListFromJSON(data.List)
	} else if data.Map != nil {
		return MapFromJSON(data.Map)
	}

	return nil, fmt.Errorf("unknown type %s", data.Type)
}

func SchemaToJSON(x Schema) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return MustMatchSchemaR2(
		x,
		func(x *None) ([]byte, error) {
			body, err := NoneToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(SchemaUnionJSON{
				Type: "schema.None",
				None: body,
			})
		},
		func(x *Bool) ([]byte, error) {
			body, err := BoolToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(SchemaUnionJSON{
				Type: "schema.Bool",
				Bool: body,
			})
		},
		func(x *Number) ([]byte, error) {
			body, err := NumberToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(SchemaUnionJSON{
				Type:   "schema.Number",
				Number: body,
			})
		},
		func(x *String) ([]byte, error) {
			body, err := StringToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(SchemaUnionJSON{
				Type:   "schema.String",
				String: body,
			})
		},
		func(x *Binary) ([]byte, error) {
			body, err := BinaryToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(SchemaUnionJSON{
				Type:   "schema.Binary",
				Binary: body,
			})
		},
		func(x *List) ([]byte, error) {
			body, err := ListToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(SchemaUnionJSON{
				Type: "schema.List",
				List: body,
			})
		},
		func(x *Map) ([]byte, error) {
			body, err := MapToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(SchemaUnionJSON{
				Type: "schema.Map",
				Map:  body,
			})
		},
	)
}

func NoneFromJSON(x []byte) (*None, error) {
	var result *None = new(None)
	// if is Struct
	err := shared.JSONParseObject(x, func(key string, value []byte) error {
		switch key {
		}

		return fmt.Errorf("schema.NoneFromJSON: unknown key %s", key)
	})

	return result, err
}

func NoneToJSON(x *None) ([]byte, error) {
	return json.Marshal(map[string]json.RawMessage{})
}
func (self *None) MarshalJSON() ([]byte, error) {
	return NoneToJSON(self)
}

func (self *None) UnmarshalJSON(x []byte) error {
	n, err := NoneFromJSON(x)
	if err != nil {
		return err
	}
	*self = *n
	return nil
}

func BoolFromJSON(x []byte) (*Bool, error) {
	var result *Bool = new(Bool)
	err := json.Unmarshal(x, result)

	return result, err
}

func BoolToJSON(x *Bool) ([]byte, error) {
	return json.Marshal(x)
}

func NumberFromJSON(x []byte) (*Number, error) {
	var result *Number = new(Number)
	err := json.Unmarshal(x, result)

	return result, err
}

func NumberToJSON(x *Number) ([]byte, error) {
	return json.Marshal(x)
}

func StringFromJSON(x []byte) (*String, error) {
	var result *String = new(String)
	err := json.Unmarshal(x, result)

	return result, err
}

func StringToJSON(x *String) ([]byte, error) {
	return json.Marshal(x)
}

func BinaryFromJSON(x []byte) (*Binary, error) {
	var result *Binary = new(Binary)
	err := json.Unmarshal(x, result)

	return result, err
}

func BinaryToJSON(x *Binary) ([]byte, error) {
	return json.Marshal(x)
}

func ListFromJSON(x []byte) (*List, error) {
	var result *List = new(List)
	err := json.Unmarshal(x, result)

	return result, err
}

func ListToJSON(x *List) ([]byte, error) {
	return json.Marshal(x)
}

func MapFromJSON(x []byte) (*Map, error) {
	var result *Map = new(Map)
	err := json.Unmarshal(x, result)

	return result, err
}

func MapToJSON(x *Map) ([]byte, error) {
	return json.Marshal(x)
}
