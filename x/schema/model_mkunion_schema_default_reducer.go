// Code generated by mkunion. DO NOT EDIT.
package schema

var _ SchemaReducer[any] = (*SchemaDefaultReduction[any])(nil)

type (
	SchemaDefaultReduction[A any] struct {
		PanicOnFallback      bool
		DefaultStopReduction bool
		OnNone               func(x *None, agg A) (result A, stop bool)
		OnBool               func(x *Bool, agg A) (result A, stop bool)
		OnNumber             func(x *Number, agg A) (result A, stop bool)
		OnString             func(x *String, agg A) (result A, stop bool)
		OnBinary             func(x *Binary, agg A) (result A, stop bool)
		OnList               func(x *List, agg A) (result A, stop bool)
		OnMap                func(x *Map, agg A) (result A, stop bool)
	}
)

func (t *SchemaDefaultReduction[A]) ReduceNone(x *None, agg A) (result A, stop bool) {
	if t.OnNone != nil {
		return t.OnNone(x, agg)
	}
	if t.PanicOnFallback {
		panic("no fallback allowed on undefined ReduceBranch")
	}
	return agg, t.DefaultStopReduction
}

func (t *SchemaDefaultReduction[A]) ReduceBool(x *Bool, agg A) (result A, stop bool) {
	if t.OnBool != nil {
		return t.OnBool(x, agg)
	}
	if t.PanicOnFallback {
		panic("no fallback allowed on undefined ReduceBranch")
	}
	return agg, t.DefaultStopReduction
}

func (t *SchemaDefaultReduction[A]) ReduceNumber(x *Number, agg A) (result A, stop bool) {
	if t.OnNumber != nil {
		return t.OnNumber(x, agg)
	}
	if t.PanicOnFallback {
		panic("no fallback allowed on undefined ReduceBranch")
	}
	return agg, t.DefaultStopReduction
}

func (t *SchemaDefaultReduction[A]) ReduceString(x *String, agg A) (result A, stop bool) {
	if t.OnString != nil {
		return t.OnString(x, agg)
	}
	if t.PanicOnFallback {
		panic("no fallback allowed on undefined ReduceBranch")
	}
	return agg, t.DefaultStopReduction
}

func (t *SchemaDefaultReduction[A]) ReduceBinary(x *Binary, agg A) (result A, stop bool) {
	if t.OnBinary != nil {
		return t.OnBinary(x, agg)
	}
	if t.PanicOnFallback {
		panic("no fallback allowed on undefined ReduceBranch")
	}
	return agg, t.DefaultStopReduction
}

func (t *SchemaDefaultReduction[A]) ReduceList(x *List, agg A) (result A, stop bool) {
	if t.OnList != nil {
		return t.OnList(x, agg)
	}
	if t.PanicOnFallback {
		panic("no fallback allowed on undefined ReduceBranch")
	}
	return agg, t.DefaultStopReduction
}

func (t *SchemaDefaultReduction[A]) ReduceMap(x *Map, agg A) (result A, stop bool) {
	if t.OnMap != nil {
		return t.OnMap(x, agg)
	}
	if t.PanicOnFallback {
		panic("no fallback allowed on undefined ReduceBranch")
	}
	return agg, t.DefaultStopReduction
}
