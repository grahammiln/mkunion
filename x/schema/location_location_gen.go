// Code generated by mkunion. DO NOT EDIT.
package schema

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/f"
	"github.com/widmogrod/mkunion/x/shared"
)

//mkunion-extension:visitor

type LocationVisitor interface {
	VisitLocationField(v *LocationField) any
	VisitLocationIndex(v *LocationIndex) any
	VisitLocationAnything(v *LocationAnything) any
}

type Location interface {
	AcceptLocation(g LocationVisitor) any
}

func (r *LocationField) AcceptLocation(v LocationVisitor) any    { return v.VisitLocationField(r) }
func (r *LocationIndex) AcceptLocation(v LocationVisitor) any    { return v.VisitLocationIndex(r) }
func (r *LocationAnything) AcceptLocation(v LocationVisitor) any { return v.VisitLocationAnything(r) }

var (
	_ Location = (*LocationField)(nil)
	_ Location = (*LocationIndex)(nil)
	_ Location = (*LocationAnything)(nil)
)

func MatchLocation[TOut any](
	x Location,
	f1 func(x *LocationField) TOut,
	f2 func(x *LocationIndex) TOut,
	f3 func(x *LocationAnything) TOut,
	df func(x Location) TOut,
) TOut {
	return f.Match3(x, f1, f2, f3, df)
}

func MatchLocationR2[TOut1, TOut2 any](
	x Location,
	f1 func(x *LocationField) (TOut1, TOut2),
	f2 func(x *LocationIndex) (TOut1, TOut2),
	f3 func(x *LocationAnything) (TOut1, TOut2),
	df func(x Location) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.Match3R2(x, f1, f2, f3, df)
}

func MustMatchLocation[TOut any](
	x Location,
	f1 func(x *LocationField) TOut,
	f2 func(x *LocationIndex) TOut,
	f3 func(x *LocationAnything) TOut,
) TOut {
	return f.MustMatch3(x, f1, f2, f3)
}

func MustMatchLocationR0(
	x Location,
	f1 func(x *LocationField),
	f2 func(x *LocationIndex),
	f3 func(x *LocationAnything),
) {
	f.MustMatch3R0(x, f1, f2, f3)
}

func MustMatchLocationR2[TOut1, TOut2 any](
	x Location,
	f1 func(x *LocationField) (TOut1, TOut2),
	f2 func(x *LocationIndex) (TOut1, TOut2),
	f3 func(x *LocationAnything) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.MustMatch3R2(x, f1, f2, f3)
}

// mkunion-extension:json
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/schema.Location", LocationFromJSON, LocationToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/schema.LocationField", LocationFieldFromJSON, LocationFieldToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/schema.LocationIndex", LocationIndexFromJSON, LocationIndexToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/schema.LocationAnything", LocationAnythingFromJSON, LocationAnythingToJSON)
}

type LocationUnionJSON struct {
	Type             string          `json:"$type,omitempty"`
	LocationField    json.RawMessage `json:"schema.LocationField,omitempty"`
	LocationIndex    json.RawMessage `json:"schema.LocationIndex,omitempty"`
	LocationAnything json.RawMessage `json:"schema.LocationAnything,omitempty"`
}

func LocationFromJSON(x []byte) (Location, error) {
	var data LocationUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, err
	}

	switch data.Type {
	case "schema.LocationField":
		return LocationFieldFromJSON(data.LocationField)
	case "schema.LocationIndex":
		return LocationIndexFromJSON(data.LocationIndex)
	case "schema.LocationAnything":
		return LocationAnythingFromJSON(data.LocationAnything)
	}

	if data.LocationField != nil {
		return LocationFieldFromJSON(data.LocationField)
	} else if data.LocationIndex != nil {
		return LocationIndexFromJSON(data.LocationIndex)
	} else if data.LocationAnything != nil {
		return LocationAnythingFromJSON(data.LocationAnything)
	}

	return nil, fmt.Errorf("schema.Location: unknown type %s", data.Type)
}

func LocationToJSON(x Location) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return MustMatchLocationR2(
		x,
		func(x *LocationField) ([]byte, error) {
			body, err := LocationFieldToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(LocationUnionJSON{
				Type:          "schema.LocationField",
				LocationField: body,
			})
		},
		func(x *LocationIndex) ([]byte, error) {
			body, err := LocationIndexToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(LocationUnionJSON{
				Type:          "schema.LocationIndex",
				LocationIndex: body,
			})
		},
		func(x *LocationAnything) ([]byte, error) {
			body, err := LocationAnythingToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(LocationUnionJSON{
				Type:             "schema.LocationAnything",
				LocationAnything: body,
			})
		},
	)
}

func LocationFieldFromJSON(x []byte) (*LocationField, error) {
	result := new(LocationField)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func LocationFieldToJSON(x *LocationField) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*LocationField)(nil)
	_ json.Marshaler   = (*LocationField)(nil)
)

func (r *LocationField) MarshalJSON() ([]byte, error) {
	var err error
	result := make(map[string]json.RawMessage)

	fieldName, err := shared.JSONMarshal[string](r.Name)
	if err != nil {
		return nil, fmt.Errorf("schema.LocationField.MarshalJSON: field Name; %w", err)
	}
	result["Name"] = fieldName

	output, err := json.Marshal(result)
	if err != nil {
		return nil, fmt.Errorf("schema.LocationField.MarshalJSON: final step; %w", err)
	}

	return output, nil
}

func (r *LocationField) UnmarshalJSON(bytes []byte) error {
	return shared.JSONParseObject(bytes, func(key string, bytes []byte) error {
		switch key {
		case "Name":
			var err error
			r.Name, err = shared.JSONUnmarshal[string](bytes)
			if err != nil {
				return fmt.Errorf("schema.LocationField.UnmarshalJSON: field Name; %w", err)
			}
			return nil

		}

		return nil
	})
}

func LocationIndexFromJSON(x []byte) (*LocationIndex, error) {
	result := new(LocationIndex)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func LocationIndexToJSON(x *LocationIndex) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*LocationIndex)(nil)
	_ json.Marshaler   = (*LocationIndex)(nil)
)

func (r *LocationIndex) MarshalJSON() ([]byte, error) {
	var err error
	result := make(map[string]json.RawMessage)

	fieldIndex, err := shared.JSONMarshal[int](r.Index)
	if err != nil {
		return nil, fmt.Errorf("schema.LocationIndex.MarshalJSON: field Index; %w", err)
	}
	result["Index"] = fieldIndex

	output, err := json.Marshal(result)
	if err != nil {
		return nil, fmt.Errorf("schema.LocationIndex.MarshalJSON: final step; %w", err)
	}

	return output, nil
}

func (r *LocationIndex) UnmarshalJSON(bytes []byte) error {
	return shared.JSONParseObject(bytes, func(key string, bytes []byte) error {
		switch key {
		case "Index":
			var err error
			r.Index, err = shared.JSONUnmarshal[int](bytes)
			if err != nil {
				return fmt.Errorf("schema.LocationIndex.UnmarshalJSON: field Index; %w", err)
			}
			return nil

		}

		return nil
	})
}

func LocationAnythingFromJSON(x []byte) (*LocationAnything, error) {
	result := new(LocationAnything)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func LocationAnythingToJSON(x *LocationAnything) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*LocationAnything)(nil)
	_ json.Marshaler   = (*LocationAnything)(nil)
)

func (r *LocationAnything) MarshalJSON() ([]byte, error) {
	var err error
	result := make(map[string]json.RawMessage)

	output, err := json.Marshal(result)
	if err != nil {
		return nil, fmt.Errorf("schema.LocationAnything.MarshalJSON: final step; %w", err)
	}

	return output, nil
}

func (r *LocationAnything) UnmarshalJSON(bytes []byte) error {
	return shared.JSONParseObject(bytes, func(key string, bytes []byte) error {
		switch key {
		}

		return nil
	})
}
