package main

import (
	"bytes"
	"context"
	"fmt"
	log "github.com/sirupsen/logrus"
	"github.com/urfave/cli/v2"
	"github.com/widmogrod/mkunion/x/generators"
	"github.com/widmogrod/mkunion/x/shape"
	"github.com/widmogrod/mkunion/x/shared"
	"os"
	"os/signal"
	"path"
	"sort"
	"strings"
	"syscall"
)

func main() {
	ctx, _ := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)

	// set log level to error
	log.SetOutput(os.Stderr)
	log.SetLevel(log.ErrorLevel)

	var app *cli.App
	app = &cli.App{
		Name:                   shared.Program,
		Description:            "VisitorGenerator union type and visitor pattern gor golang",
		EnableBashCompletion:   true,
		UseShortOptionHandling: true,
		Flags: []cli.Flag{
			&cli.StringSliceFlag{
				Name:     "name",
				Aliases:  []string{"n"},
				Required: false,
			},
			&cli.StringSliceFlag{
				Name:      "input-go-file",
				Aliases:   []string{"i", "input"},
				Usage:     `When not provided, it will try to use GOFILE environment variable, used when combined with //go:generate mkunion -name=MyUnionType`,
				TakesFile: true,
			},
			&cli.BoolFlag{
				Name:     "verbose",
				Aliases:  []string{"v"},
				Required: false,
				Value:    false,
			},
			&cli.BoolFlag{
				Name:  "type-registry",
				Value: false,
			},
		},
		Action: func(c *cli.Context) error {
			if c.Bool("verbose") {
				log.SetLevel(log.DebugLevel)
			}

			sourcePaths := c.StringSlice("input-go-file")
			if len(sourcePaths) == 0 && os.Getenv("GOFILE") != "" {
				cwd, _ := syscall.Getwd()
				sourceName := path.Base(os.Getenv("GOFILE"))
				sourcePaths = []string{
					path.Join(cwd, sourceName),
				}
			}

			if len(sourcePaths) == 0 {
				// show usage
				cli.ShowAppHelpAndExit(c, 1)
			}

			packages := make(map[string]*shape.InferredInfo)

			for _, sourcePath := range sourcePaths {
				// file name without extension
				inferred, err := shape.InferFromFile(sourcePath)
				if err != nil {
					return err
				}

				if _, ok := packages[inferred.PackageImportName()]; !ok {
					packages[inferred.PackageImportName()] = inferred
				}

				contents, err := GenerateUnions(inferred)
				if err != nil {
					return fmt.Errorf("failed generating union in %s: %w", sourcePath, err)
				}

				err = SaveFile(contents, sourcePath, "union_gen")
				if err != nil {
					return fmt.Errorf("failed saving union in %s: %w", sourcePath, err)
				}

				contents, err = GenerateSerde(inferred)
				if err != nil {
					return fmt.Errorf("failed generating serde in %s: %w", sourcePath, err)
				}

				err = SaveFile(contents, sourcePath, "serde_gen")
				if err != nil {
					return fmt.Errorf("failed saving serde in %s: %w", sourcePath, err)
				}

				contents, err = GenerateShape(inferred)
				if err != nil {
					return fmt.Errorf("failed generating shape in %s: %w", sourcePath, err)
				}

				err = SaveFile(contents, sourcePath, "shape_gen")
				if err != nil {
					return fmt.Errorf("failed saving shape in %s: %w", sourcePath, err)
				}
			}

			if c.Bool("type-registry") {
				for _, inferred := range packages {
					dir := path.Dir(inferred.FileName())

					// walk through all *.go files in the same directory
					// and generate type registry for all inferred packages
					// in the same directory

					indexed, err := shape.NewIndexTypeInDir(dir)
					if err != nil {
						return fmt.Errorf("mkunion: failed indexing types in directory %s: %w", dir, err)
					}

					if len(indexed.IndexedShapes()) > 0 {
						contents, err := GenerateTypeRegistry(indexed)
						if err != nil {
							return fmt.Errorf("mkunion: failed walking through directory %s: %w", dir, err)
						}

						regPath := path.Join(dir, "types.go")
						err = SaveFile(contents, regPath, "reg_gen")
						if err != nil {
							return fmt.Errorf("mkunion: failed saving type registry in %s: %w", regPath, err)
						}
					}
				}
			}

			return nil
		},
		Commands: []*cli.Command{
			{
				Name: "match",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:     "name",
						Required: true,
					},
				},
				Action: func(c *cli.Context) error {
					cwd, _ := syscall.Getwd()
					sourceName := path.Base(os.Getenv("GOFILE"))
					sourcePath := path.Join(cwd, sourceName)

					baseName := strings.TrimSuffix(sourceName, path.Ext(sourceName))

					// file name without extension
					inferred, err := generators.InferDeriveFuncMatchFromFile(sourcePath)
					if err != nil {
						return err
					}

					specName := c.String("name")
					spec, err := inferred.MatchSpec(specName)
					if err != nil {
						return err
					}

					derived := generators.DeriveFuncMatchGenerator{
						Header:      "// Code generated by mkunion. DO NOT EDIT.",
						PackageName: inferred.PackageName,
						MatchSpec:   *spec,
					}

					b, err := derived.Generate()
					if err != nil {
						return err
					}
					err = os.WriteFile(path.Join(
						cwd,
						baseName+"_match_"+strings.ToLower(derived.MatchSpec.Name)+".go"), b, 0644)
					if err != nil {
						return fmt.Errorf("failed to write %s for %s in %s: %w", "gen", derived.MatchSpec.Name, sourcePath, err)
					}

					return nil
				},
			},
			{
				Name: "shape-export",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "language",
						Aliases:     []string{"lang"},
						DefaultText: "typescript",
					},
					&cli.StringFlag{
						Name:    "output-dir",
						Aliases: []string{"o", "output"},
					},
					&cli.StringSliceFlag{
						Name:      "input-go-file",
						Aliases:   []string{"i", "input"},
						Usage:     `When not provided, it will try to use GOFILE environment variable, used when combined with //go:generate mkunion -name=MyUnionType`,
						TakesFile: true,
					},
					&cli.BoolFlag{
						Name:     "verbose",
						Aliases:  []string{"v"},
						Required: false,
						Value:    false,
					},
				},
				Action: func(c *cli.Context) error {
					if c.Bool("verbose") {
						log.SetLevel(log.DebugLevel)
					}

					sourcePaths := c.StringSlice("input-go-file")
					if len(sourcePaths) == 0 && os.Getenv("GOFILE") != "" {
						cwd, _ := syscall.Getwd()
						sourceName := path.Base(os.Getenv("GOFILE"))
						sourcePaths = []string{
							path.Join(cwd, sourceName),
						}
					}

					if len(sourcePaths) == 0 {
						// show usage
						cli.ShowAppHelpAndExit(c, 1)
					}

					tsr := shape.NewTypeScriptRenderer()
					for _, sourcePath := range sourcePaths {
						// file name without extension
						inferred, err := shape.InferFromFile(sourcePath)
						if err != nil {
							return err
						}

						for _, x := range inferred.RetrieveShapes() {
							tsr.AddShape(x)
						}
					}

					err := tsr.WriteToDir(c.String("output-dir"))
					if err != nil {
						return fmt.Errorf("failed to write to dir %s: %w", c.String("output-dir"), err)
					}

					return nil
				},
			},
		},
	}

	err := app.RunContext(ctx, os.Args)
	if err != nil {
		log.Fatal(err)
	}
}

func GenerateUnions(inferred *shape.InferredInfo) (bytes.Buffer, error) {
	shapesContents := bytes.Buffer{}
	unions := inferred.RetrieveUnions()
	if len(unions) == 0 {
		return shapesContents, nil
	}

	var err error
	packageName := "main"
	pkgMap := make(generators.PkgMap)
	initFunc := make(generators.InitFuncs, 0)

	for _, union := range unions {
		packageName = shape.ToGoPkgName(union)

		genVisitor := generators.NewVisitorGenerator(union)
		genVisitor.SkipImportsAndPackage(true)

		contents := []byte("//union:genVisitor\n")
		contents, err = genVisitor.Generate()
		if err != nil {
			return shapesContents, fmt.Errorf("failed to generate genVisitor for %s: %w", shape.ToGoTypeName(union), err)
		}
		shapesContents.Write(contents)

		if shape.TagHasOption(union.Tags, "mkunion", "noserde") {
			continue
		}

		genSerde := generators.NewSerdeJSONUnion(union)
		genSerde.SkipImportsAndPackage(true)

		contents = []byte("//union:serde:json\n")
		contents, err = genSerde.Generate()
		if err != nil {
			return shapesContents, fmt.Errorf("mkunion.GenerateUnions: failed to generate json serde for %s: %w", shape.ToGoTypeName(union), err)
		}
		shapesContents.Write(contents)

		pkgMap = generators.MergePkgMaps(pkgMap,
			genSerde.ExtractImports(union),
		)
	}

	contents := bytes.Buffer{}
	contents.WriteString("// Code generated by mkunion. DO NOT EDIT.\n")
	contents.WriteString(fmt.Sprintf("package %s\n\n", packageName))
	contents.WriteString(generators.GenerateImports(pkgMap))
	contents.WriteString(generators.GenerateInitFunc(initFunc))
	_, err = shapesContents.WriteTo(&contents)
	if err != nil {
		return shapesContents, fmt.Errorf("mkunion.GenerateUnions: failed to write shapes contents: %w", err)
	}

	return contents, nil
}

func GenerateSerde(inferred *shape.InferredInfo) (bytes.Buffer, error) {
	shapesContents := bytes.Buffer{}
	shapes := inferred.RetrieveShapesTaggedAs("serde")
	if len(shapes) == 0 {
		return shapesContents, nil
	}

	var err error
	packageName := "main"
	pkgMap := make(generators.PkgMap)
	initFunc := make(generators.InitFuncs, 0, 0)

	for _, x := range shapes {
		packageName = shape.ToGoPkgName(x)
		genSerde := generators.NewSerdeJSONTagged(x)
		genSerde.SkipImportsAndPackage(true)

		contents := "//shape:serde:json\n"
		contents, err = genSerde.Generate()
		if err != nil {
			return shapesContents, fmt.Errorf("mkunion.GenerateSerde: failed to generate json serde for %s: %w", shape.ToGoTypeName(x), err)
		}
		shapesContents.WriteString(contents)

		pkgMap = generators.MergePkgMaps(pkgMap,
			genSerde.ExtractImports(x),
		)
	}

	contents := bytes.Buffer{}
	contents.WriteString("// Code generated by mkunion. DO NOT EDIT.\n")
	contents.WriteString(fmt.Sprintf("package %s\n\n", packageName))
	contents.WriteString(generators.GenerateImports(pkgMap))
	contents.WriteString(generators.GenerateInitFunc(initFunc))

	_, err = shapesContents.WriteTo(&contents)
	if err != nil {
		return shapesContents, fmt.Errorf("mkunion.GenerateSerde: failed to write shapes contents: %w", err)
	}

	return contents, nil
}

func GenerateShape(inferred *shape.InferredInfo) (bytes.Buffer, error) {
	shapesContents := bytes.Buffer{}
	shapes := inferred.RetrieveShapes()
	if len(shapes) == 0 {
		return shapesContents, nil
	}

	packageName := "main"
	pkgMap := make(generators.PkgMap)
	initFunc := make(generators.InitFuncs, 0)

	for _, x := range shapes {
		packageName = shape.ToGoPkgName(x)
		contents, err := GenerateShapeFollow(x, &pkgMap, &initFunc, inferred)
		if err != nil {
			return shapesContents, fmt.Errorf("mkunion.GenerateShape: failed to generate shape for %s: %w", shape.ToGoTypeName(x), err)
		}
		if contents != nil {
			_, err = contents.WriteTo(&shapesContents)
			if err != nil {
				return shapesContents, fmt.Errorf("mkunion.GenerateShape: failed to write shape for %s: %w", shape.ToGoTypeName(x), err)
			}
		}
	}

	contents := bytes.Buffer{}
	contents.WriteString("// Code generated by mkunion. DO NOT EDIT.\n")
	contents.WriteString(fmt.Sprintf("package %s\n\n", packageName))
	contents.WriteString(generators.GenerateImports(pkgMap))
	contents.WriteString(generators.GenerateInitFunc(initFunc))
	_, err := shapesContents.WriteTo(&contents)
	if err != nil {
		return shapesContents, fmt.Errorf("mkunion.GenerateUnions: failed to write shapes contents: %w", err)
	}

	return contents, nil
}

func GenerateShapeFollow(x shape.Shape, pkgMap *generators.PkgMap, initFunc *[]string, inferred *shape.InferredInfo) (*bytes.Buffer, error) {
	var result *bytes.Buffer
	for _, y := range shape.ExtractRefs(x) {
		// filter types that are not from the same package
		if y.PkgImportName != shape.ToGoPkgImportName(x) {
			log.Debugf("mkunion.GenerateShapeFollow: skipping %s, not from the same package", shape.ToGoTypeName(y))
			continue
		}

		contents, err := GenerateShapeOnce(y, pkgMap, initFunc, inferred)
		if err != nil {
			return nil, fmt.Errorf("mkunion.GenerateShapeFollow: failed to generate shape for %s: %w", shape.ToGoTypeName(y), err)
		}

		if contents == nil {
			continue
		}

		if result == nil {
			result = contents
		} else {
			_, err = contents.WriteTo(result)
			if err != nil {
				return nil, fmt.Errorf("mkunion.GenerateShapeFollow: failed to write shape for %s: %w", shape.ToGoTypeName(y), err)
			}
		}
	}

	return result, nil
}

var _generatedShape = map[string]bool{}

func GenerateShapeOnce(x shape.Shape, pkgMap *generators.PkgMap, initFunc *[]string, inferred *shape.InferredInfo) (*bytes.Buffer, error) {
	key := shape.ToGoTypeName(x, shape.WithPkgImportName())
	if _generatedShape[key] {
		log.Debugf("mkunion.GenerateShapeOnce: shape %s already generated", key)
		return nil, nil
	}

	result := bytes.Buffer{}

	switch x := x.(type) {
	case *shape.RefName:
		y := inferred.RetrieveShapeFromRef(x)
		if y == nil {
			log.Warnf("mkunion.GenerateShapeOnce: failed to lookup shape %s", shape.ToGoTypeName(x, shape.WithPkgImportName()))
			return nil, nil
		}

		switch y := y.(type) {
		case *shape.RefName:
			log.Warnf("mkunion.GenerateShapeOnce: lookup RefName %s", shape.ToGoTypeName(y, shape.WithPkgImportName()))
			return nil, nil
		}

		return GenerateShapeOnce(y, pkgMap, initFunc, inferred)

	case *shape.UnionLike:
		for _, v := range x.Variant {
			key := shape.ToGoTypeName(v, shape.WithPkgImportName())
			_generatedShape[key] = true
		}
	}

	_generatedShape[key] = true

	gen := generators.NewShapeTagged(x)
	gen.SkipImportsAndPackage(true)
	gen.SkipInitFunc(true)

	result.WriteString("//shape:shape\n")
	contents, err := gen.Generate()
	if err != nil {
		return nil, fmt.Errorf("mkunion.GenerateShapeOnce: failed to generate tagged shape for %s: %w", shape.ToGoTypeName(x, shape.WithPkgImportName()), err)
	}
	result.WriteString(contents)

	*pkgMap = generators.MergePkgMaps(*pkgMap,
		gen.ExtractImports(x),
	)

	*initFunc = append(*initFunc, gen.ExtractImportFuncs(x)...)

	return &result, nil
}

func SaveFile(contents bytes.Buffer, sourcePath string, infix string) error {
	if len(contents.Bytes()) == 0 {
		return nil
	}

	sourceName := path.Base(sourcePath)
	baseName := strings.TrimSuffix(sourceName, path.Ext(sourceName))
	fileName := path.Join(
		path.Dir(sourcePath),
		fmt.Sprintf("%s_%s.go", baseName, infix),
	)

	log.Infof("writing %s", fileName)
	err := os.WriteFile(fileName, contents.Bytes(), 0644)
	if err != nil {
		return fmt.Errorf("mkunion.SaveFile: failed to write serde in %s: %w", sourcePath, err)
	}
	return nil
}

func GenerateTypeRegistry(inferred *shape.IndexedTypeWalker) (bytes.Buffer, error) {
	packageName := inferred.PackageName()

	contents := bytes.Buffer{}
	contents.WriteString("// Code generated by mkunion. DO NOT EDIT.\n")
	contents.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	found := inferred.ExpandedShapes()
	if len(found) == 0 {
		return contents, nil
	}

	sortedKeys := make([]string, 0, len(found))
	for k := range found {
		sortedKeys = append(sortedKeys, k)
	}

	sort.Strings(sortedKeys)

	maps := []generators.PkgMap{
		{
			"shared": "github.com/widmogrod/mkunion/x/shared",
		},
	}
	for _, key := range sortedKeys {
		inst := found[key]
		next := shape.ExtractPkgImportNamesForTypeInitialisation(inst)
		maps = append(maps, next)
	}
	pkgMap := generators.MergePkgMaps(maps...)
	delete(pkgMap, packageName)

	contents.WriteString(generators.GenerateImports(pkgMap))

	contents.WriteString("func init() {\n")
	// generate type registry

	for _, key := range sortedKeys {
		inst := found[key]
		instantiatedTypeName := shape.ToGoTypeName(inst,
			shape.WithInstantiation(),
			shape.WithRootPackage(packageName),
		)
		fullTypeName := shape.ToGoTypeName(inst,
			shape.WithInstantiation(),
			shape.WithPkgImportName(),
		)

		contents.WriteString(fmt.Sprintf("\tshared.TypeRegistryStore[%s](%q)\n", instantiatedTypeName, fullTypeName))
	}

	contents.WriteString("}\n")

	return contents, nil
}
