package main

import (
	"bytes"
	"context"
	"fmt"
	log "github.com/sirupsen/logrus"
	"github.com/urfave/cli/v2"
	"github.com/widmogrod/mkunion/x/generators"
	"github.com/widmogrod/mkunion/x/shape"
	"github.com/widmogrod/mkunion/x/shared"
	"os"
	"os/signal"
	"path"
	"strings"
	"syscall"
)

type extractImports interface {
	ExtractImports(x shape.Shape) generators.PkgMap
	SkipImportsAndPackage(x bool)
}

type extractInitFuncs interface {
	ExtractImportFuncs(s shape.Shape) []string
	SkipInitFunc(flag bool)
}

func main() {
	ctx, _ := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)

	// set log level to error
	log.SetOutput(os.Stderr)
	log.SetLevel(log.ErrorLevel)

	var app *cli.App
	app = &cli.App{
		Name:                   shared.Program,
		Description:            "VisitorGenerator union type and visitor pattern gor golang",
		EnableBashCompletion:   true,
		UseShortOptionHandling: true,
		Flags: []cli.Flag{
			&cli.StringSliceFlag{
				Name:     "name",
				Aliases:  []string{"n"},
				Required: false,
			},
			&cli.StringFlag{
				Name:     "skip-extension",
				Aliases:  []string{"skip-ext"},
				Value:    "",
				Required: false,
			},
			&cli.StringFlag{
				Name:     "include-extension",
				Aliases:  []string{"inc-ext"},
				Required: false,
			},
			&cli.StringSliceFlag{
				Name:      "input-go-file",
				Aliases:   []string{"i", "input"},
				Usage:     `When not provided, it will try to use GOFILE environment variable, used when combined with //go:generate mkunion -name=MyUnionType`,
				TakesFile: true,
			},
			&cli.BoolFlag{
				Name:     "verbose",
				Aliases:  []string{"v"},
				Required: false,
				Value:    false,
			},
			&cli.BoolFlag{
				Name:     "no-compact",
				Required: false,
			},
		},
		Action: func(c *cli.Context) error {
			if c.Bool("verbose") {
				log.SetLevel(log.DebugLevel)
			}

			sourcePaths := c.StringSlice("input-go-file")
			if len(sourcePaths) == 0 && os.Getenv("GOFILE") != "" {
				cwd, _ := syscall.Getwd()
				sourceName := path.Base(os.Getenv("GOFILE"))
				sourcePaths = []string{
					path.Join(cwd, sourceName),
				}
			}

			if len(sourcePaths) == 0 {
				// show usage
				cli.ShowAppHelpAndExit(c, 1)
			}

			for _, sourcePath := range sourcePaths {
				// file name without extension
				inferred, err := shape.InferFromFile(sourcePath)
				if err != nil {
					return err
				}

				contents, err := GenerateUnions(inferred)
				if err != nil {
					return fmt.Errorf("failed generating union in %s: %w", sourcePath, err)
				}

				err = SaveFile(contents, sourcePath, "union_gen")
				if err != nil {
					return fmt.Errorf("failed saving union in %s: %w", sourcePath, err)
				}

				contents, err = GenerateSerde(inferred)
				if err != nil {
					return fmt.Errorf("failed generating serde in %s: %w", sourcePath, err)
				}

				err = SaveFile(contents, sourcePath, "serde_gen")
				if err != nil {
					return fmt.Errorf("failed saving serde in %s: %w", sourcePath, err)
				}
			}

			return nil
		},
		Commands: []*cli.Command{
			{
				Name: "match",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:     "name",
						Required: true,
					},
				},
				Action: func(c *cli.Context) error {
					cwd, _ := syscall.Getwd()
					sourceName := path.Base(os.Getenv("GOFILE"))
					sourcePath := path.Join(cwd, sourceName)

					baseName := strings.TrimSuffix(sourceName, path.Ext(sourceName))

					// file name without extension
					inferred, err := generators.InferDeriveFuncMatchFromFile(sourcePath)
					if err != nil {
						return err
					}

					specName := c.String("name")
					spec, err := inferred.MatchSpec(specName)
					if err != nil {
						return err
					}

					derived := generators.DeriveFuncMatchGenerator{
						Header:      "// Code generated by mkunion. DO NOT EDIT.",
						PackageName: inferred.PackageName,
						MatchSpec:   *spec,
					}

					b, err := derived.Generate()
					if err != nil {
						return err
					}
					err = os.WriteFile(path.Join(
						cwd,
						baseName+"_match_"+strings.ToLower(derived.MatchSpec.Name)+".go"), b, 0644)
					if err != nil {
						return fmt.Errorf("failed to write %s for %s in %s: %w", "gen", derived.MatchSpec.Name, sourcePath, err)
					}

					return nil
				},
			},
			{
				Name: "serde",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "type",
						DefaultText: "json",
					},
					&cli.StringSliceFlag{
						Name:      "input-go-file",
						Aliases:   []string{"i", "input"},
						Usage:     `When not provided, it will try to use GOFILE environment variable, used when combined with //go:generate mkunion -name=MyUnionType`,
						TakesFile: true,
					},
					&cli.BoolFlag{
						Name:     "verbose",
						Aliases:  []string{"v"},
						Required: false,
						Value:    false,
					},
				},
				Action: func(c *cli.Context) error {
					if c.Bool("verbose") {
						log.SetLevel(log.DebugLevel)
					}

					sourcePaths := c.StringSlice("input-go-file")
					if len(sourcePaths) == 0 && os.Getenv("GOFILE") != "" {
						cwd, _ := syscall.Getwd()
						sourceName := path.Base(os.Getenv("GOFILE"))
						sourcePaths = []string{
							path.Join(cwd, sourceName),
						}
					}

					if len(sourcePaths) == 0 {
						// show usage
						cli.ShowAppHelpAndExit(c, 1)
					}

					for _, sourcePath := range sourcePaths {
						inferred, err := shape.InferFromFile(sourcePath)
						if err != nil {
							return fmt.Errorf("failed inferring shape in %s; %w", sourcePath, err)
						}

						contents, err := GenerateSerde(inferred)
						if err != nil {
							return fmt.Errorf("failed generating serde in %s; %w", sourcePath, err)
						}

						err = SaveFile(contents, sourcePath, "serde_gen")
						if err != nil {
							return fmt.Errorf("failed saving serde in %s; %w", sourcePath, err)
						}
					}

					return nil
				},
			},
			{
				Name: "shape-export",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "language",
						Aliases:     []string{"lang"},
						DefaultText: "typescript",
					},
					&cli.StringFlag{
						Name:    "output-dir",
						Aliases: []string{"o", "output"},
					},
					&cli.StringSliceFlag{
						Name:      "input-go-file",
						Aliases:   []string{"i", "input"},
						Usage:     `When not provided, it will try to use GOFILE environment variable, used when combined with //go:generate mkunion -name=MyUnionType`,
						TakesFile: true,
					},
					&cli.BoolFlag{
						Name:     "verbose",
						Aliases:  []string{"v"},
						Required: false,
						Value:    false,
					},
				},
				Action: func(c *cli.Context) error {
					if c.Bool("verbose") {
						log.SetLevel(log.DebugLevel)
					}

					sourcePaths := c.StringSlice("input-go-file")
					if len(sourcePaths) == 0 && os.Getenv("GOFILE") != "" {
						cwd, _ := syscall.Getwd()
						sourceName := path.Base(os.Getenv("GOFILE"))
						sourcePaths = []string{
							path.Join(cwd, sourceName),
						}
					}

					if len(sourcePaths) == 0 {
						// show usage
						cli.ShowAppHelpAndExit(c, 1)
					}

					tsr := shape.NewTypeScriptRenderer()
					for _, sourcePath := range sourcePaths {
						// file name without extension
						inferred, err := shape.InferFromFile(sourcePath)
						if err != nil {
							return err
						}

						for _, x := range inferred.RetrieveShapes() {
							tsr.AddShape(x)
						}
					}

					err := tsr.WriteToDir(c.String("output-dir"))
					if err != nil {
						return fmt.Errorf("failed to write to dir %s: %w", c.String("output-dir"), err)
					}

					return nil
				},
			},
		},
	}

	err := app.RunContext(ctx, os.Args)
	if err != nil {
		log.Fatal(err)
	}
}

func GenerateUnions(inferred *shape.InferredInfo) (bytes.Buffer, error) {
	shapesContents := bytes.Buffer{}
	unions := inferred.RetrieveUnions()
	if len(unions) == 0 {
		return shapesContents, nil
	}

	var err error
	packageName := "main"
	pkgMap := make(generators.PkgMap)
	initFunc := make(generators.InitFuncs, 0, 0)

	for _, union := range unions {
		packageName = shape.ToGoPkgName(union)

		genVisitor := generators.NewVisitorGenerator(union)
		genVisitor.SkipImportsAndPackage(true)

		contents := []byte("//union:genVisitor\n")
		contents, err = genVisitor.Generate()
		if err != nil {
			return shapesContents, fmt.Errorf("failed to generate genVisitor for %s: %w", shape.ToGoTypeName(union), err)
		}
		shapesContents.Write(contents)

		genShape := generators.NewShapeUnion(union)
		genShape.SkipImportsAndPackage(true)
		genShape.SkipInitFunc(true)

		contents = []byte("//union:shape\n")
		contents, err = genShape.Generate()
		if err != nil {
			return shapesContents, fmt.Errorf("mkunion.GenerateUnions: failed to generate shape for %s: %w", shape.ToGoTypeName(union), err)
		}
		shapesContents.Write(contents)

		genSerde := generators.NewSerdeJSONUnion(union)
		genSerde.SkipImportsAndPackage(true)

		contents = []byte("//union:serde:json\n")
		contents, err = genSerde.Generate()
		if err != nil {
			return shapesContents, fmt.Errorf("mkunion.GenerateUnions: failed to generate json serde for %s: %w", shape.ToGoTypeName(union), err)
		}
		shapesContents.Write(contents)

		pkgMap = generators.MergePkgMaps(pkgMap,
			genShape.ExtractImports(union),
			genSerde.ExtractImports(union),
		)

		initFunc = append(initFunc, genShape.ExtractImportFuncs(union)...)
	}

	contents := bytes.Buffer{}
	contents.WriteString("// Code generated by mkunion. DO NOT EDIT.\n")
	contents.WriteString(fmt.Sprintf("package %s\n\n", packageName))
	contents.WriteString(generators.GenerateImports(pkgMap))
	contents.WriteString(generators.GenerateInitFunc(initFunc))
	_, err = shapesContents.WriteTo(&contents)
	if err != nil {
		return shapesContents, fmt.Errorf("mkunion.GenerateUnions: failed to write shapes contents: %w", err)
	}

	return contents, nil
}

func GenerateSerde(inferred *shape.InferredInfo) (bytes.Buffer, error) {
	shapesContents := bytes.Buffer{}
	shapes := inferred.RetrieveShapesTaggedAs("serde")
	if len(shapes) == 0 {
		return shapesContents, nil
	}

	var err error
	packageName := "main"
	pkgMap := make(generators.PkgMap)
	initFunc := make(generators.InitFuncs, 0, 0)

	for _, x := range shapes {
		packageName = shape.ToGoPkgName(x)
		genSerde := generators.NewSerdeJSONTagged(x)
		genSerde.SkipImportsAndPackage(true)

		genShape := generators.NewShapeTagged(x)
		genShape.SkipImportsAndPackage(true)
		genShape.SkipInitFunc(true)

		contents := "//shape:serde:json\n"
		contents, err = genSerde.Generate()
		if err != nil {
			return shapesContents, fmt.Errorf("mkunion.GenerateSerde: failed to generate json serde for %s: %w", shape.ToGoTypeName(x), err)
		}
		shapesContents.WriteString(contents)

		contents = "//shape:shape\n"
		contents, err = genShape.Generate()
		if err != nil {
			return shapesContents, fmt.Errorf("mkunion.GenerateSerde: failed to generate shape for %s: %w", shape.ToGoTypeName(x), err)
		}
		shapesContents.WriteString(contents)

		pkgMap = generators.MergePkgMaps(pkgMap,
			genSerde.ExtractImports(x),
			genShape.ExtractImports(x),
		)

		initFunc = append(initFunc, genShape.ExtractImportFuncs(x)...)
	}

	contents := bytes.Buffer{}
	contents.WriteString("// Code generated by mkunion. DO NOT EDIT.\n")
	contents.WriteString(fmt.Sprintf("package %s\n\n", packageName))
	contents.WriteString(generators.GenerateImports(pkgMap))
	contents.WriteString(generators.GenerateInitFunc(initFunc))

	_, err = shapesContents.WriteTo(&contents)
	if err != nil {
		return shapesContents, fmt.Errorf("mkunion.GenerateSerde: failed to write shapes contents: %w", err)
	}

	return contents, nil
}

func SaveFile(contents bytes.Buffer, sourcePath string, infix string) error {
	if len(contents.Bytes()) == 0 {
		return nil
	}

	sourceName := path.Base(sourcePath)
	baseName := strings.TrimSuffix(sourceName, path.Ext(sourceName))
	fileName := path.Join(
		path.Dir(sourcePath),
		fmt.Sprintf("%s_%s.go", baseName, infix),
	)

	log.Infof("writing %s", fileName)
	err := os.WriteFile(fileName, contents.Bytes(), 0644)
	if err != nil {
		return fmt.Errorf("mkunion.SaveFile: failed to write serde in %s: %w", sourcePath, err)
	}
	return nil
}
