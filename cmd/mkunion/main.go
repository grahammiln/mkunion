package main

import (
	"bytes"
	"context"
	"fmt"
	log "github.com/sirupsen/logrus"
	"github.com/urfave/cli/v2"
	"github.com/widmogrod/mkunion/x/generators"
	"github.com/widmogrod/mkunion/x/shape"
	"github.com/widmogrod/mkunion/x/shared"
	"os"
	"os/signal"
	"path"
	"strings"
	"syscall"
)

type extractImports interface {
	ExtractImports(x shape.Shape) generators.PkgMap
	SkipImportsAndPackage(x bool)
}

type extractInitFuncs interface {
	ExtractImportFuncs(s shape.Shape) []string
	SkipInitFunc(flag bool)
}

func main() {
	ctx, _ := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)

	// set log level to error
	log.SetOutput(os.Stderr)
	log.SetLevel(log.ErrorLevel)

	var app *cli.App
	app = &cli.App{
		Name:                   shared.Program,
		Description:            "VisitorGenerator union type and visitor pattern gor golang",
		EnableBashCompletion:   true,
		UseShortOptionHandling: true,
		Flags: []cli.Flag{
			&cli.StringSliceFlag{
				Name:     "name",
				Aliases:  []string{"n"},
				Required: false,
			},
			&cli.StringFlag{
				Name:     "skip-extension",
				Aliases:  []string{"skip-ext"},
				Value:    "",
				Required: false,
			},
			&cli.StringFlag{
				Name:     "include-extension",
				Aliases:  []string{"inc-ext"},
				Required: false,
			},
			&cli.StringSliceFlag{
				Name:      "input-go-file",
				Aliases:   []string{"i", "input"},
				Usage:     `When not provided, it will try to use GOFILE environment variable, used when combined with //go:generate mkunion -name=MyUnionType`,
				TakesFile: true,
			},
			&cli.BoolFlag{
				Name:     "verbose",
				Aliases:  []string{"v"},
				Required: false,
				Value:    false,
			},
			&cli.BoolFlag{
				Name:     "no-compact",
				Required: false,
			},
		},
		Action: func(c *cli.Context) error {
			if c.Bool("verbose") {
				log.SetLevel(log.DebugLevel)
			}

			sourcePaths := c.StringSlice("input-go-file")
			if len(sourcePaths) == 0 && os.Getenv("GOFILE") != "" {
				cwd, _ := syscall.Getwd()
				sourceName := path.Base(os.Getenv("GOFILE"))
				sourcePaths = []string{
					path.Join(cwd, sourceName),
				}
			}

			if len(sourcePaths) == 0 {
				// show usage
				cli.ShowAppHelpAndExit(c, 1)
			}

			for _, sourcePath := range sourcePaths {
				// file name without extension
				inferred, err := shape.InferFromFile(sourcePath)
				if err != nil {
					return err
				}

				unions := inferred.RetrieveUnions()
				if len(unions) == 0 {
					log.Infof("no union found in %s", sourcePath)
					continue
				}

				packageName := "main"
				pkgMap := make(generators.PkgMap)
				initFunc := make(generators.InitFuncs, 0, 0)
				shapesContents := bytes.Buffer{}

				for _, union := range unions {
					packageName = shape.ToGoPkgName(union)

					genVisitor := generators.NewVisitorGenerator(union)
					genVisitor.SkipImportsAndPackage(true)

					contents := []byte("//union:genVisitor\n")
					contents, err = genVisitor.Generate()
					if err != nil {
						return fmt.Errorf("failed to generate genVisitor for %s in %s: %w", shape.ToGoTypeName(union), sourcePath, err)
					}
					shapesContents.Write(contents)

					genShape := generators.NewShapeUnion(union)
					genShape.SkipImportsAndPackage(true)
					genShape.SkipInitFunc(true)

					contents = []byte("//union:shape\n")
					contents, err = genShape.Generate()
					if err != nil {
						return fmt.Errorf("failed to generate shape for %s in %s: %w", shape.ToGoTypeName(union), sourcePath, err)
					}
					shapesContents.Write(contents)

					genSerde := generators.NewSerdeJSONUnion(union)
					genSerde.SkipImportsAndPackage(true)

					contents = []byte("//union:serde:json\n")
					contents, err = genSerde.Generate()
					if err != nil {
						return fmt.Errorf("failed to generate json serde for %s in %s: %w", shape.ToGoTypeName(union), sourcePath, err)
					}
					shapesContents.Write(contents)

					pkgMap = generators.MergePkgMaps(pkgMap,
						genShape.ExtractImports(union),
						genSerde.ExtractImports(union),
					)

					initFunc = append(initFunc, genShape.ExtractImportFuncs(union)...)
				}

				contents := "// Code generated by mkunion. DO NOT EDIT.\n"
				contents += fmt.Sprintf("package %s\n\n", packageName)
				contents += generators.GenerateImports(pkgMap)
				contents += generators.GenerateInitFunc(initFunc)
				contents += shapesContents.String()

				sourceName := path.Base(sourcePath)
				baseName := strings.TrimSuffix(sourceName, path.Ext(sourceName))
				fileName := path.Join(
					path.Dir(sourcePath),
					fmt.Sprintf("%s_union_gen.go", baseName),
				)

				log.Infof("writing %s", fileName)
				err = os.WriteFile(fileName, []byte(contents), 0644)
				if err != nil {
					return fmt.Errorf("failed to write union in %s: %w", sourcePath, err)
				}
			}

			return nil
		},
		Commands: []*cli.Command{
			{
				Name: "match",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:     "name",
						Required: true,
					},
				},
				Action: func(c *cli.Context) error {
					cwd, _ := syscall.Getwd()
					sourceName := path.Base(os.Getenv("GOFILE"))
					sourcePath := path.Join(cwd, sourceName)

					baseName := strings.TrimSuffix(sourceName, path.Ext(sourceName))

					// file name without extension
					inferred, err := generators.InferDeriveFuncMatchFromFile(sourcePath)
					if err != nil {
						return err
					}

					specName := c.String("name")
					spec, err := inferred.MatchSpec(specName)
					if err != nil {
						return err
					}

					derived := generators.DeriveFuncMatchGenerator{
						Header:      "// Code generated by mkunion. DO NOT EDIT.",
						PackageName: inferred.PackageName,
						MatchSpec:   *spec,
					}

					b, err := derived.Generate()
					if err != nil {
						return err
					}
					err = os.WriteFile(path.Join(
						cwd,
						baseName+"_match_"+strings.ToLower(derived.MatchSpec.Name)+".go"), b, 0644)
					if err != nil {
						return fmt.Errorf("failed to write %s for %s in %s: %w", "gen", derived.MatchSpec.Name, sourcePath, err)
					}

					return nil
				},
			},
			{
				Name: "serde",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "type",
						DefaultText: "json",
					},
					&cli.StringSliceFlag{
						Name:      "input-go-file",
						Aliases:   []string{"i", "input"},
						Usage:     `When not provided, it will try to use GOFILE environment variable, used when combined with //go:generate mkunion -name=MyUnionType`,
						TakesFile: true,
					},
					&cli.BoolFlag{
						Name:     "verbose",
						Aliases:  []string{"v"},
						Required: false,
						Value:    false,
					},
				},
				Action: func(c *cli.Context) error {
					if c.Bool("verbose") {
						log.SetLevel(log.DebugLevel)
					}

					sourcePaths := c.StringSlice("input-go-file")
					if len(sourcePaths) == 0 && os.Getenv("GOFILE") != "" {
						cwd, _ := syscall.Getwd()
						sourceName := path.Base(os.Getenv("GOFILE"))
						sourcePaths = []string{
							path.Join(cwd, sourceName),
						}
					}

					if len(sourcePaths) == 0 {
						// show usage
						cli.ShowAppHelpAndExit(c, 1)
					}

					for _, sourcePath := range sourcePaths {
						inferred, err := shape.InferFromFile(sourcePath)
						if err != nil {
							return fmt.Errorf("failed inferring shape in %s; %w", sourcePath, err)
						}

						shapes := inferred.RetrieveShapesTaggedAs("serde")
						if len(shapes) == 0 {
							log.Infof("no shape found in %s", sourcePath)
							continue
						}

						packageName := "main"
						pkgMap := make(generators.PkgMap)
						initFunc := make(generators.InitFuncs, 0, 0)
						shapesContents := bytes.Buffer{}

						for _, x := range shapes {
							packageName = shape.ToGoPkgName(x)
							genSerde := generators.NewSerdeJSONTagged(x)
							genSerde.SkipImportsAndPackage(true)

							genShape := generators.NewShapeTagged(x)
							genShape.SkipImportsAndPackage(true)
							genShape.SkipInitFunc(true)

							contents := "//shape:serde:json\n"
							contents, err = genSerde.Generate()
							if err != nil {
								return fmt.Errorf("failed to generate json serde for %s in %s: %w", shape.ToGoTypeName(x), sourcePath, err)
							}
							shapesContents.WriteString(contents)

							contents = "//shape:shape\n"
							contents, err = genShape.Generate()
							if err != nil {
								return fmt.Errorf("failed to generate shape for %s in %s: %w", shape.ToGoTypeName(x), sourcePath, err)
							}
							shapesContents.WriteString(contents)

							pkgMap = generators.MergePkgMaps(pkgMap,
								genSerde.ExtractImports(x),
								genShape.ExtractImports(x),
							)

							initFunc = append(initFunc, genShape.ExtractImportFuncs(x)...)
						}

						contents := "// Code generated by mkunion. DO NOT EDIT.\n"
						contents += fmt.Sprintf("package %s\n\n", packageName)
						contents += generators.GenerateImports(pkgMap)
						contents += generators.GenerateInitFunc(initFunc)
						contents += shapesContents.String()

						sourceName := path.Base(sourcePath)
						baseName := strings.TrimSuffix(sourceName, path.Ext(sourceName))
						fileName := path.Join(
							path.Dir(sourcePath),
							fmt.Sprintf("%s_serde_gen.go", baseName),
						)

						log.Infof("writing %s", fileName)
						err = os.WriteFile(fileName, []byte(contents), 0644)
						if err != nil {
							return fmt.Errorf("failed to write serde in %s: %w", sourcePath, err)
						}

						return nil
					}

					return nil
				},
			},
			{
				Name: "shape-export",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "language",
						Aliases:     []string{"lang"},
						DefaultText: "typescript",
					},
					&cli.StringFlag{
						Name:    "output-dir",
						Aliases: []string{"o", "output"},
					},
					&cli.StringSliceFlag{
						Name:      "input-go-file",
						Aliases:   []string{"i", "input"},
						Usage:     `When not provided, it will try to use GOFILE environment variable, used when combined with //go:generate mkunion -name=MyUnionType`,
						TakesFile: true,
					},
					&cli.BoolFlag{
						Name:     "verbose",
						Aliases:  []string{"v"},
						Required: false,
						Value:    false,
					},
				},
				Action: func(c *cli.Context) error {
					if c.Bool("verbose") {
						log.SetLevel(log.DebugLevel)
					}

					sourcePaths := c.StringSlice("input-go-file")
					if len(sourcePaths) == 0 && os.Getenv("GOFILE") != "" {
						cwd, _ := syscall.Getwd()
						sourceName := path.Base(os.Getenv("GOFILE"))
						sourcePaths = []string{
							path.Join(cwd, sourceName),
						}
					}

					if len(sourcePaths) == 0 {
						// show usage
						cli.ShowAppHelpAndExit(c, 1)
					}

					tsr := shape.NewTypeScriptRenderer()
					for _, sourcePath := range sourcePaths {
						// file name without extension
						inferred, err := shape.InferFromFile(sourcePath)
						if err != nil {
							return err
						}

						for _, x := range inferred.RetrieveShapes() {
							tsr.AddShape(x)
						}
					}

					err := tsr.WriteToDir(c.String("output-dir"))
					if err != nil {
						return fmt.Errorf("failed to write to dir %s: %w", c.String("output-dir"), err)
					}

					return nil
				},
			},
		},
	}

	err := app.RunContext(ctx, os.Args)
	if err != nil {
		log.Fatal(err)
	}
}
