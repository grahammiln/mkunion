{{ .Header }}
package {{ .PackageName }}

import (
	"github.com/widmogrod/mkunion/f"
)

{{ $name := .Name }}
type {{ $name }}Visitor interface {
	{{- range .Types }}
	Visit{{ . }}(v *{{ . }}) any
	{{- end }}
}

type {{ $name }} interface {
	Accept(g {{ $name }}Visitor) any
}
{{ range .Types }}
func (r *{{ . }}) Accept(v {{ $name }}Visitor) any { return v.Visit{{ . }}(r) }
{{- end }}

var (
	{{- range .Types }}
	_ {{ $name }} = (*{{ . }})(nil)
	{{- end }}
)
{{ $i := len .Types}}
func Match{{ $name }}[TOut any](
	x {{ $name }},
	{{- range $k, $t := .Types }}
	f{{ Add $k 1}} func(x *{{ $t }}) TOut,
    {{- end }}
	df func(x {{ $name }}) TOut,
) TOut {
	return f.Match{{ $i }}(x {{- range $k := GenIntSlice 1 $i }}, f{{ $k }} {{- end }}, df)
}
{{ $i := len .Types}}
func Match{{ $name }}R2[TOut1, TOut2 any](
	x {{ $name }},
	{{- range $k, $t := .Types }}
	f{{ Add $k 1}} func(x *{{ $t }}) (TOut1, TOut2),
    {{- end }}
	df func(x {{ $name }}) (TOut1, TOut2),
) (TOut1, TOut2) {
	return f.Match{{ $i }}R2(x {{- range $k := GenIntSlice 1 $i }}, f{{ $k }} {{- end }}, df)
}
{{ $i := len .Types}}
func MustMatch{{ $name }}[TOut any](
	x {{ $name }},
	{{- range $k, $t := .Types }}
	f{{ Add $k 1}} func(x *{{ $t }}) TOut,
    {{- end }}
) TOut {
	return f.MustMatch{{ $i }}(x {{- range $k := GenIntSlice 1 $i }}, f{{ $k }} {{- end }})
}
{{ $i := len .Types}}
func MustMatch{{ $name }}R0(
	x {{ $name }},
	{{- range $k, $t := .Types }}
	f{{ Add $k 1}} func(x *{{ $t }}),
    {{- end }}
) {
	f.MustMatch{{ $i }}R0(x {{- range $k := GenIntSlice 1 $i }}, f{{ $k }} {{- end }})
}
{{ $i := len .Types}}
func MustMatch{{ $name }}R2[TOut1, TOut2 any](
	x {{ $name }},
	{{- range $k, $t := .Types }}
	f{{ Add $k 1}} func(x *{{ $t }}) (TOut1, TOut2),
    {{- end }}
) (TOut1, TOut2) {
	return f.MustMatch{{ $i }}R2(x {{- range $k := GenIntSlice 1 $i }}, f{{ $k }} {{- end }})
}